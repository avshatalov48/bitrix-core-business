this.BX=this.BX||{};this.BX.UI=this.BX.UI||{};(function(t,e,n,r){"use strict";const o=Symbol("name");const s=Symbol("group");const i=Symbol("validate");const a=Symbol("before");const l=Symbol("convert");const h=Symbol("forChild");const u=Symbol("after");const c=Symbol("formatter");const f=()=>true;const d=({node:t})=>t;const m=({element:t})=>t;class p{constructor(t={}){this[o]="unknown";this[s]=null;this[a]=null;this[l]=null;this[h]=null;this[u]=null;if(n.Type.isArray(t.name)){this[s]=[...t.name]}else{this.setName(t.name)}if(!n.Type.isNil(t.formatter)){this.setFormatter(t.formatter)}this.setValidate(t.validate);this.setBefore(t.before);this.setConvert(t.convert);this.setForChild(t.forChild);this.setAfter(t.after)}setName(t){if(!n.Type.isStringFilled(t)){throw new TypeError("Name is not a string")}this[o]=t}getName(){return this[o]}setValidate(t){if(n.Type.isFunction(t)){this[i]=t}else{this[i]=f}}validate(t){const e=this[i](t);if(n.Type.isBoolean(e)){return e}throw new TypeError(`Validate callback for "${this.getName()}" returned not boolean`)}setBefore(t){if(n.Type.isFunction(t)){this[a]=t}else{this[a]=d}}runBefore(t){return this[a](t)}setConvert(t){if(!n.Type.isFunction(t)){throw new TypeError("Convert is not a function")}this[l]=t}runConvert(t){return this[l](t)}setForChild(t){if(n.Type.isFunction(t)){this[h]=t}else{this[h]=m}}runForChild(t){return this[h](t)}setAfter(t){if(n.Type.isFunction(t)){this[u]=t}else{this[u]=m}}runAfter(t){return this[u](t)}setFormatter(t){this[c]=t}getFormatter(){return this[c]}}const y=Symbol("formatters");const w=Symbol("onUnknown");const T=Symbol("data");class N{constructor(t={}){this[y]=new Map;this[w]=null;this[T]=null;this.setNodeFormatters(t.formatters);if(n.Type.isNil(t.onUnknown)){this.setOnUnknown(this.getDefaultUnknownNodeCallback())}else{this.setOnUnknown(t.onUnknown)}}isElement(t){return n.Type.isObject(t)&&n.Type.isFunction(t.appendChild)}static prepareSourceNode(t){if(t instanceof r.BBCodeNode){return t}if(n.Type.isString(t)){return(new e.BBCodeParser).parse(t)}return null}setData(t){this[T]=t}getData(){return this[T]}setNodeFormatters(t){if(n.Type.isArrayFilled(t)){t.forEach((t=>{this.setNodeFormatter(t)}))}}setNodeFormatter(t){if(t instanceof p){this[y].set(t.getName(),t)}else{throw new TypeError("formatter is not a NodeFormatter instance.")}}getDefaultUnknownNodeCallback(){throw new TypeError("Must be implemented in subclass")}setOnUnknown(t){if(n.Type.isFunction(t)){this[w]=t}else{throw new TypeError("OnUnknown callback is not a function.")}}runOnUnknown(t){const e=this[w](t);if(e instanceof p||n.Type.isNull(e)){return e}throw new TypeError("OnUnknown callback returned not NodeFormatter instance or null.")}getNodeFormatter(t){const e=this[y].get(t.getName());if(e instanceof p){return e}return this.runOnUnknown({node:t,formatter:this})}getNodeFormatters(){return this[y]}format(t){if(!n.Type.isPlainObject(t)){throw new TypeError("options is not a object")}const{source:e,data:r={}}=t;if(!n.Type.isUndefined(r)&&!n.Type.isPlainObject(r)){throw new TypeError("options.data is not a object")}this.setData(r);const o=N.prepareSourceNode(e);if(n.Type.isNull(o)){throw new TypeError("options.source is not a BBCodeNode or string")}const s=this.getNodeFormatter(o);const i=s.validate({node:o,formatter:this,data:r});if(!i){return null}const a=s.runBefore({node:o,formatter:this,data:r});if(n.Type.isNull(a)){return null}const l=s.runConvert({node:a,formatter:this,data:r});if(n.Type.isNull(l)){return null}a.getChildren().forEach((t=>{const e=this.format({source:t,data:r});if(e!==null){const n=s.runForChild({node:t,element:e,formatter:this,data:r});if(n!==null&&this.isElement(l)){l.appendChild(n)}}}));return s.runAfter({node:a,element:l,formatter:this,data:r})}}t.Formatter=N;t.NodeFormatter=p})(this.BX.UI.BBCode=this.BX.UI.BBCode||{},BX.UI.BBCode,BX,BX.UI.BBCode);
//# sourceMappingURL=formatter.bundle.map.js