{"version":3,"file":"text-parser.bundle.js","sources":["../src/code-point.js","../src/text-parser.js","../src/token-tree.js"],"sourcesContent":["export const CodePoint = {\n\tTAB: 9,\n\tSPACE: 32,\n\tNBSP: 160,\n\tNEW_LINE: 10, // \\n\n\tRETURN: 13, // \\r\n\tLINE_FEED: 12, // \\f\n\tEXCLAMATION: 33, // !\n\tDOUBLE_QUOTE: 34,\n\tHASH: 35, // #\n\tSINGLE_QUOTE: 39,\n\tASTERISK: 42,\n\tCOMMA: 44,\n\tDOT: 46,\n\tCOLON: 58,\n\tSEMI_COLON: 59,\n\tQUESTION: 63,\n\tROUND_BRACKET_OPEN: 40,\n\tROUND_BRACKET_CLOSE: 41,\n\tSQUARE_BRACKET_OPEN: 91,\n\tSQUARE_BRACKET_CLOSE: 93,\n\tCURLY_BRACKET_OPEN: 123,\n\tPIPE: 124,\n\tCURLY_BRACKET_CLOSE: 125,\n\tHYPHEN: 45,\n};\n","import { Type } from 'main.core';\nimport { CodePoint } from './code-point';\nimport type { TreeIndex } from './token-tree';\n\nexport class TextParser\n{\n\t#currentPosition: number;\n\t#text: string;\n\t#textStart: number = -1;\n\t#textEnd: number = -1;\n\n\tconstructor(text: string, position = 0)\n\t{\n\t\tthis.#text = text;\n\t\tthis.#currentPosition = position;\n\t}\n\n\tgetCurrentPosition(): number\n\t{\n\t\treturn this.#currentPosition;\n\t}\n\n\ttryChangePosition(fn: Function): boolean\n\t{\n\t\tconst currentPosition = this.#currentPosition;\n\t\tconst success = fn();\n\t\tif (!success)\n\t\t{\n\t\t\tthis.#currentPosition = currentPosition;\n\t\t}\n\n\t\treturn success;\n\t}\n\n\tpeek(): number | undefined\n\t{\n\t\treturn this.#text.codePointAt(this.#currentPosition);\n\t}\n\n\tmoveNext(): number\n\t{\n\t\treturn this.hasNext() ? this.#moveNext(this.peek()) : NaN;\n\t}\n\n\t#moveNext(code: number): number\n\t{\n\t\tthis.#currentPosition += code > 0xFFFF ? 2 : 1;\n\n\t\treturn code;\n\t}\n\n\tpeekPrevious(): number\n\t{\n\t\treturn this.#text.codePointAt(this.#currentPosition - 1);\n\t}\n\n\thasNext(): boolean\n\t{\n\t\treturn this.#currentPosition < this.#text.length;\n\t}\n\n\thasPendingText(): boolean\n\t{\n\t\treturn this.#textStart !== this.#textEnd;\n\t}\n\n\tflushText(): void\n\t{\n\t\tif (this.hasPendingText())\n\t\t{\n\t\t\tthis.#textStart = -1;\n\t\t\tthis.#textEnd = -1;\n\t\t}\n\t}\n\n\tconsume(match: number | Function): boolean\n\t{\n\t\tconst codePoint = this.peek();\n\t\tconst success = Type.isFunction(match) ? match(codePoint) : codePoint === match;\n\t\tif (success)\n\t\t{\n\t\t\tthis.moveNext(codePoint);\n\t\t}\n\n\t\treturn success;\n\t}\n\n\tconsumeWhile(match: number | Function): boolean\n\t{\n\t\tconst start = this.#currentPosition;\n\t\twhile (this.hasNext() && this.consume(match))\n\t\t{\n\t\t\t/* */\n\t\t}\n\n\t\treturn this.#currentPosition !== start;\n\t}\n\n\tconsumePoints(codePoints: number[]): boolean\n\t{\n\t\tconst currentPosition = this.#currentPosition;\n\t\tfor (const codePoint of codePoints)\n\t\t{\n\t\t\tconst currentCodePoint = this.moveNext();\n\t\t\tif (codePoint !== currentCodePoint)\n\t\t\t{\n\t\t\t\tthis.#currentPosition = currentPosition;\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconsumeTree(treeIndex: TreeIndex): boolean\n\t{\n\t\tconst currentPosition = this.#currentPosition;\n\t\tlet node = treeIndex;\n\t\twhile (this.hasNext())\n\t\t{\n\t\t\tconst codePoint = this.moveNext();\n\t\t\tconst index = node.get(codePoint);\n\t\t\tif (Type.isUndefined(index))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst [isLeaf, entry] = index;\n\t\t\tif (isLeaf === true)\n\t\t\t{\n\t\t\t\tthis.consumeTree(entry);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = entry;\n\t\t}\n\n\t\tthis.#currentPosition = currentPosition;\n\n\t\treturn false;\n\t}\n\n\tconsumeText(): true\n\t{\n\t\tif (this.#textStart === -1)\n\t\t{\n\t\t\tthis.#textStart = this.#currentPosition;\n\t\t\tthis.#textEnd = this.#currentPosition;\n\t\t}\n\n\t\tthis.moveNext();\n\n\t\tthis.#textEnd = this.#currentPosition;\n\n\t\treturn true;\n\t}\n\n\tisWordBoundary(): boolean\n\t{\n\t\tif (this.#currentPosition === 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.hasPendingText())\n\t\t{\n\t\t\treturn isDelimiter(this.peekPrevious());\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n// [.,;:!?#-*|[](){}]\nconst wordBoundaries = new Set([\n\tCodePoint.DOT,\n\tCodePoint.COMMA,\n\tCodePoint.SEMI_COLON,\n\tCodePoint.COLON,\n\tCodePoint.EXCLAMATION,\n\tCodePoint.QUESTION,\n\tCodePoint.HASH,\n\tCodePoint.HYPHEN,\n\tCodePoint.ASTERISK,\n\tCodePoint.PIPE,\n\tCodePoint.ROUND_BRACKET_OPEN,\n\tCodePoint.ROUND_BRACKET_CLOSE,\n\tCodePoint.SQUARE_BRACKET_OPEN,\n\tCodePoint.SQUARE_BRACKET_CLOSE,\n\tCodePoint.CURLY_BRACKET_OPEN,\n\tCodePoint.CURLY_BRACKET_CLOSE,\n]);\n\nexport function isWordBoundary(ch: number): boolean\n{\n\treturn wordBoundaries.has(ch);\n}\n\nexport function isTextBound(codePoint: number): boolean\n{\n\treturn Type.isUndefined(codePoint) || Number.isNaN(codePoint) || isNewLine(codePoint) || isWhitespace(codePoint);\n}\n\nexport function isDelimiter(codePoint: number): boolean\n{\n\treturn isTextBound(codePoint) || isWordBoundary(codePoint);\n}\n\nexport function isWhitespace(codePoint: number): boolean\n{\n\treturn codePoint === CodePoint.SPACE || codePoint === CodePoint.TAB || codePoint === CodePoint.NBSP;\n}\n\nexport function isNewLine(codePoint: number): boolean\n{\n\treturn codePoint === CodePoint.NEW_LINE || codePoint === CodePoint.RETURN || codePoint === CodePoint.LINE_FEED;\n}\n","import { Type } from 'main.core';\n\nexport type TreeIndex = Map<number, [boolean, TreeIndex]>;\n\nexport class TokenTree\n{\n\t#index: TreeIndex = new Map();\n\n\tgetTreeIndex(): TreeIndex\n\t{\n\t\treturn this.#index;\n\t}\n\n\taddToken(token: string): void\n\t{\n\t\tif (!Type.isStringFilled(token))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlet index = this.#index;\n\t\tfor (let i = 0; i < token.length; i++)\n\t\t{\n\t\t\tconst codePoint: number = token.codePointAt(i);\n\t\t\tif (i === token.length - 1)\n\t\t\t{\n\t\t\t\tif (index.has(codePoint))\n\t\t\t\t{\n\t\t\t\t\tindex.get(codePoint)[0] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tindex.set(codePoint, [true, new Map()]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!index.has(codePoint))\n\t\t\t\t{\n\t\t\t\t\tindex.set(codePoint, [false, new Map()]);\n\t\t\t\t}\n\n\t\t\t\t[, index] = index.get(codePoint);\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":["CodePoint","TAB","SPACE","NBSP","NEW_LINE","RETURN","LINE_FEED","EXCLAMATION","DOUBLE_QUOTE","HASH","SINGLE_QUOTE","ASTERISK","COMMA","DOT","COLON","SEMI_COLON","QUESTION","ROUND_BRACKET_OPEN","ROUND_BRACKET_CLOSE","SQUARE_BRACKET_OPEN","SQUARE_BRACKET_CLOSE","CURLY_BRACKET_OPEN","PIPE","CURLY_BRACKET_CLOSE","HYPHEN","TextParser","constructor","text","position","getCurrentPosition","tryChangePosition","fn","currentPosition","success","peek","codePointAt","moveNext","hasNext","NaN","peekPrevious","length","hasPendingText","flushText","consume","match","codePoint","Type","isFunction","consumeWhile","start","consumePoints","codePoints","currentCodePoint","consumeTree","treeIndex","node","index","get","isUndefined","isLeaf","entry","consumeText","isWordBoundary","isDelimiter","code","wordBoundaries","Set","ch","has","isTextBound","Number","isNaN","isNewLine","isWhitespace","TokenTree","Map","getTreeIndex","addToken","token","isStringFilled","i","set"],"mappings":"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"}