{"version":3,"file":"lexical.dev.bundle.js","sources":["../../node_modules/lexical/Lexical.dev.mjs","../../node_modules/lexical/Lexical.prod.mjs","../../node_modules/lexical/Lexical.mjs","../../node_modules/@lexical/selection/LexicalSelection.dev.mjs","../../node_modules/@lexical/selection/LexicalSelection.prod.mjs","../../node_modules/@lexical/selection/LexicalSelection.mjs","../../node_modules/@lexical/utils/LexicalUtils.dev.mjs","../../node_modules/@lexical/utils/LexicalUtils.prod.mjs","../../node_modules/@lexical/utils/LexicalUtils.mjs","../../node_modules/@lexical/html/LexicalHtml.dev.mjs","../../node_modules/@lexical/html/LexicalHtml.prod.mjs","../../node_modules/@lexical/html/LexicalHtml.mjs","../../node_modules/@lexical/list/LexicalList.dev.mjs","../../node_modules/@lexical/list/LexicalList.prod.mjs","../../node_modules/@lexical/list/LexicalList.mjs","../../node_modules/@lexical/link/LexicalLink.dev.mjs","../../node_modules/@lexical/link/LexicalLink.prod.mjs","../../node_modules/@lexical/link/LexicalLink.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs","../../node_modules/@lexical/clipboard/LexicalClipboard.mjs","../../node_modules/@lexical/history/LexicalHistory.dev.mjs","../../node_modules/@lexical/history/LexicalHistory.prod.mjs","../../node_modules/@lexical/history/LexicalHistory.mjs","../../node_modules/@lexical/text/LexicalText.dev.mjs","../../node_modules/@lexical/text/LexicalText.prod.mjs","../../node_modules/@lexical/text/LexicalText.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.dev.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.prod.mjs","../../node_modules/@lexical/rich-text/LexicalRichText.mjs","../../node_modules/@lexical/table/LexicalTable.dev.mjs","../../node_modules/@lexical/table/LexicalTable.prod.mjs","../../node_modules/@lexical/table/LexicalTable.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isRootNode(node) || $isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = new Map();\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n    for (const [nodeKey, node] of editorState._nodeMap) {\n      const nodeType = node.__type;\n      let nodeMap = typeToNodeMap.get(nodeType);\n      if (!nodeMap) {\n        nodeMap = new Map();\n        typeToNodeMap.set(nodeType, nodeMap);\n      }\n      nodeMap.set(nodeKey, node);\n    }\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], dom, insertDOM);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        try {\n          dom.removeChild(element);\n        } catch (error) {\n          if (typeof error === 'object' && error != null) {\n            const msg = `${error.toString()} Parent: ${dom.tagName}, child: ${element.tagName}.`;\n            throw new Error(msg);\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileParagraphFormat(element) {\n  if ($isParagraphNode(element) && subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileParagraphStyle(element) {\n  if ($isParagraphNode(element) && subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  reconcileParagraphFormat(nextElement);\n  reconcileParagraphStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFrstChildKey, null, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFrstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          $reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (lastNode instanceof ParagraphNode && lastNode.getChildrenSize() === 0) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        const firstElement = firstPoint.getNode();\n        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          throw Error(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    this.__text = prevNode.__text;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be an ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset);\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          if (!(pendingEditorState !== null)) {\n            throw Error(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  static getType() {\n    return 'paragraph';\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    node.setTextFormat(serializedNode.textFormat);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst DEFAULT_SKIP_INITIALIZATION = true;\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (default is currently true for backwards compatibility in 0.16.x but will change to false in 0.17.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    $commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.17.1+dev.esm\";\n\nexport { $addUpdateTag, $applyNodeReplacement, $cloneWithProperties, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getNodeByKeyOrThrow, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $isTokenOrSegmented, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, ArtificialNode__DO_NOT_USE, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, IS_ALL_FORMATTING, IS_BOLD, IS_CODE, IS_HIGHLIGHT, IS_ITALIC, IS_STRIKETHROUGH, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_UNDERLINE, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TEXT_TYPE_TO_FORMAT, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getEditorPropertyFromDOMNode, getNearestEditorFromDOMNode, isBlockDomNode, isCurrentlyReadOnlyMode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode, isLexicalEditor, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor, resetRandomKey };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction t(t){return{}}const e={},n={},r={},i={},s={},o={},l={},c={},a={},u={},f={},d={},h={},g={},_={},p={},y={},m={},x={},v={},S={},T={},C={},k={},b={},w={},N={},E={},P={},F={},D={},L={},O={},I={},A={},M={},W={},z={},B={},R={},K={},$={},J={},U={},V={},j=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,H=j&&\"documentMode\"in document?document.documentMode:null,q=j&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),Q=j&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),X=!(!j||!(\"InputEvent\"in window)||H)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),Y=j&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),Z=j&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,G=j&&/Android/.test(navigator.userAgent),tt=j&&/^(?=.*Chrome).*/i.test(navigator.userAgent),et=j&&G&&tt,nt=j&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!tt,rt=1,it=3,st=0,ot=1,lt=2,ct=0,at=1,ut=2,ft=1,dt=2,ht=4,gt=8,_t=16,pt=32,yt=64,mt=128,xt=112|(3|ht|gt)|mt,vt=1,St=2,Tt=3,Ct=4,kt=5,bt=6,wt=Y||Z||nt?\" \":\"​\",Nt=\"\\n\\n\",Et=Q?\" \":wt,Pt=\"֑-߿יִ-﷽ﹰ-ﻼ\",Ft=\"A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿\",Dt=new RegExp(\"^[^\"+Ft+\"]*[\"+Pt+\"]\"),Lt=new RegExp(\"^[^\"+Pt+\"]*[\"+Ft+\"]\"),Ot={bold:1,code:16,highlight:mt,italic:2,strikethrough:ht,subscript:32,superscript:64,underline:gt},It={directionless:1,unmergeable:2},At={center:St,end:bt,justify:Ct,left:vt,right:Tt,start:kt},Mt={[St]:\"center\",[bt]:\"end\",[Ct]:\"justify\",[vt]:\"left\",[Tt]:\"right\",[kt]:\"start\"},Wt={normal:0,segmented:2,token:1},zt={[ct]:\"normal\",[ut]:\"segmented\",[at]:\"token\"};function Bt(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,\"default\")?t.default:t}var Rt=Bt((function(t){const e=new URLSearchParams;e.append(\"code\",t);for(let t=1;t<arguments.length;t++)e.append(\"v\",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));function Kt(...t){const e=[];for(const n of t)if(n&&\"string\"==typeof n)for(const[t]of n.matchAll(/\\S+/g))e.push(t);return e}const $t=100;let Jt=!1,Ut=0;function Vt(t){Ut=t.timeStamp}function jt(t,e,n){return e.__lexicalLineBreak===t||void 0!==t[`__lexicalKey_${n._key}`]}function Ht(t,e,n){const r=yn(n._window);let i=null,s=null;null!==r&&r.anchorNode===t&&(i=r.anchorOffset,s=r.focusOffset);const o=t.nodeValue;null!==o&&Me(e,o,i,s,!1)}function qt(t,e,n){if(yi(t)){const e=t.anchor.getNode();if(e.is(n)&&t.format!==e.getFormat())return!1}return e.nodeType===it&&n.isAttached()}function Qt(t,e,n){Jt=!0;const r=performance.now()-Ut>$t;try{hs(t,(()=>{const i=Oi()||function(t){return t.getEditorState().read((()=>{const t=Oi();return null!==t?t.clone():null}))}(t),s=new Map,o=t.getRootElement(),l=t._editorState,c=t._blockCursorElement;let a=!1,u=\"\";for(let n=0;n<e.length;n++){const f=e[n],d=f.type,h=f.target;let g=Ce(h,l);if(!(null===g&&h!==o||ms(g)))if(\"characterData\"===d)r&&oi(g)&&qt(i,h,g)&&Ht(h,g,t);else if(\"childList\"===d){a=!0;const e=f.addedNodes;for(let n=0;n<e.length;n++){const r=e[n],i=Te(r),s=r.parentNode;if(null!=s&&r!==c&&null===i&&(\"BR\"!==r.nodeName||!jt(r,s,t))){if(Q){const t=r.innerText||r.nodeValue;t&&(u+=t)}s.removeChild(r)}}const n=f.removedNodes,r=n.length;if(r>0){let e=0;for(let i=0;i<r;i++){const r=n[i];(\"BR\"===r.nodeName&&jt(r,h,t)||c===r)&&(h.appendChild(r),e++)}r!==e&&(h===o&&(g=Ne(l)),s.set(h,g))}}}if(s.size>0)for(const[e,n]of s)if(_s(n)){const r=n.getChildrenKeys();let i=e.firstChild;for(let n=0;n<r.length;n++){const s=r[n],o=t.getElementByKey(s);null!==o&&(null==i?(e.appendChild(o),i=o):i!==o&&e.replaceChild(o,i),i=i.nextSibling)}}else oi(n)&&n.markDirty();const f=n.takeRecords();if(f.length>0){for(let e=0;e<f.length;e++){const n=f[e],r=n.addedNodes,i=n.target;for(let e=0;e<r.length;e++){const n=r[e],s=n.parentNode;null==s||\"BR\"!==n.nodeName||jt(n,i,t)||s.removeChild(n)}}n.takeRecords()}null!==i&&(a&&(i.dirty=!0,Ee(i)),Q&&Ye(t)&&i.insertRawText(u))}))}finally{Jt=!1}}function Xt(t){const e=t._observer;if(null!==e){Qt(t,e.takeRecords(),e)}}function Yt(t){!function(t){0===Ut&&on(t).addEventListener(\"textInput\",Vt,!0)}(t),t._observer=new MutationObserver(((e,n)=>{Qt(t,e,n)}))}function Zt(t,e){const n=t.__mode,r=t.__format,i=t.__style,s=e.__mode,o=e.__format,l=e.__style;return!(null!==n&&n!==s||null!==r&&r!==o||null!==i&&i!==l)}function Gt(t,e){const n=t.mergeWithSibling(e),r=ts()._normalizedNodes;return r.add(t.__key),r.add(e.__key),n}function te(t){let e,n,r=t;if(\"\"!==r.__text||!r.isSimpleText()||r.isUnmergeable()){for(;null!==(e=r.getPreviousSibling())&&oi(e)&&e.isSimpleText()&&!e.isUnmergeable();){if(\"\"!==e.__text){if(Zt(e,r)){r=Gt(e,r);break}break}e.remove()}for(;null!==(n=r.getNextSibling())&&oi(n)&&n.isSimpleText()&&!n.isUnmergeable();){if(\"\"!==n.__text){if(Zt(r,n)){r=Gt(r,n);break}break}n.remove()}}else r.remove()}function ee(t){return ne(t.anchor),ne(t.focus),t}function ne(t){for(;\"element\"===t.type;){const e=t.getNode(),n=t.offset;let r,i;if(n===e.getChildrenSize()?(r=e.getChildAtIndex(n-1),i=!0):(r=e.getChildAtIndex(n),i=!1),oi(r)){t.set(r.__key,i?r.getTextContentSize():0,\"text\");break}if(!_s(r))break;t.set(r.__key,i?r.getChildrenSize():0,\"element\")}}let re=1;function ie(){re=1}const se=\"function\"==typeof queueMicrotask?queueMicrotask:t=>{Promise.resolve().then(t)};function oe(t){const e=document.activeElement;if(null===e)return!1;const n=e.nodeName;return ms(Ce(t))&&(\"INPUT\"===n||\"TEXTAREA\"===n||\"true\"===e.contentEditable&&null==ue(e))}function le(t,e,n){const r=t.getRootElement();try{return null!==r&&r.contains(e)&&r.contains(n)&&null!==e&&!oe(e)&&ae(e)===t}catch(t){return!1}}function ce(t){return t instanceof Ms}function ae(t){let e=t;for(;null!=e;){const t=ue(e);if(ce(t))return t;e=en(e)}return null}function ue(t){return t?t.__lexicalEditor:null}function fe(t){return t.isToken()||t.isSegmented()}function de(t){return t.nodeType===it}function he(t){let e=t;for(;null!=e;){if(de(e))return e;e=e.firstChild}return null}function ge(t,e,n){const r=Ot[e];if(null!==n&&(t&r)==(n&r))return t;let i=t^r;return\"subscript\"===e?i&=~Ot.superscript:\"superscript\"===e&&(i&=~Ot.subscript),i}function _e(t){return oi(t)||$r(t)||ms(t)}function pe(t,e){if(null!=e)return void(t.__key=e);Yi(),Zi();const n=ts(),r=Gi(),i=\"\"+re++;r._nodeMap.set(i,t),_s(t)?n._dirtyElements.set(i,!0):n._dirtyLeaves.add(i),n._cloneNotNeeded.add(i),n._dirtyType=ot,t.__key=i}function ye(t){const e=t.getParent();if(null!==e){const n=t.getWritable(),r=e.getWritable(),i=t.getPreviousSibling(),s=t.getNextSibling();if(null===i)if(null!==s){const t=s.getWritable();r.__first=s.__key,t.__prev=null}else r.__first=null;else{const t=i.getWritable();if(null!==s){const e=s.getWritable();e.__prev=t.__key,t.__next=e.__key}else t.__next=null;n.__prev=null}if(null===s)if(null!==i){const t=i.getWritable();r.__last=i.__key,t.__next=null}else r.__last=null;else{const t=s.getWritable();if(null!==i){const e=i.getWritable();e.__next=t.__key,t.__prev=e.__key}else t.__prev=null;n.__next=null}r.__size--,n.__parent=null}}function me(t){Zi();const e=t.getLatest(),n=e.__parent,r=Gi(),i=ts(),s=r._nodeMap,o=i._dirtyElements;null!==n&&function(t,e,n){let r=t;for(;null!==r;){if(n.has(r))return;const t=e.get(r);if(void 0===t)break;n.set(r,!1),r=t.__parent}}(n,s,o);const l=e.__key;i._dirtyType=ot,_s(t)?o.set(l,!0):i._dirtyLeaves.add(l)}function xe(t){Yi();const e=ts(),n=e._compositionKey;if(t!==n){if(e._compositionKey=t,null!==n){const t=Se(n);null!==t&&t.getWritable()}if(null!==t){const e=Se(t);null!==e&&e.getWritable()}}}function ve(){if(Xi())return null;return ts()._compositionKey}function Se(t,e){const n=(e||Gi())._nodeMap.get(t);return void 0===n?null:n}function Te(t,e){const n=t[`__lexicalKey_${ts()._key}`];return void 0!==n?Se(n,e):null}function Ce(t,e){let n=t;for(;null!=n;){const t=Te(n,e);if(null!==t)return t;n=en(n)}return null}function ke(t){const e=t._decorators,n=Object.assign({},e);return t._pendingDecorators=n,n}function be(t){return t.read((()=>we().getTextContent()))}function we(){return Ne(Gi())}function Ne(t){return t._nodeMap.get(\"root\")}function Ee(t){Yi();const e=Gi();null!==t&&(t.dirty=!0,t.setCachedNodes(null)),e._selection=t}function Pe(t){const e=ts(),n=function(t,e){let n=t;for(;null!=n;){const t=n[`__lexicalKey_${e._key}`];if(void 0!==t)return t;n=en(n)}return null}(t,e);if(null===n){return t===e.getRootElement()?Se(\"root\"):null}return Se(n)}function Fe(t,e){return e?t.getTextContentSize():0}function De(t){return/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(t)}function Le(t){const e=[];let n=t;for(;null!==n;)e.push(n),n=n._parentEditor;return e}function Oe(){return Math.random().toString(36).replace(/[^a-z]+/g,\"\").substr(0,5)}function Ie(t){return t.nodeType===it?t.nodeValue:null}function Ae(t,e,n){const r=yn(e._window);if(null===r)return;const i=r.anchorNode;let{anchorOffset:s,focusOffset:o}=r;if(null!==i){let e=Ie(i);const r=Ce(i);if(null!==e&&oi(r)){if(e===wt&&n){const t=n.length;e=n,s=t,o=t}null!==e&&Me(r,e,s,o,t)}}}function Me(t,e,n,r,i){let s=t;if(s.isAttached()&&(i||!s.isDirty())){const o=s.isComposing();let l=e;(o||i)&&e[e.length-1]===wt&&(l=e.slice(0,-1));const c=s.getTextContent();if(i||l!==c){if(\"\"===l){if(xe(null),Y||Z||nt)s.remove();else{const t=ts();setTimeout((()=>{t.update((()=>{s.isAttached()&&s.remove()}))}),20)}return}const e=s.getParent(),i=Ii(),c=s.getTextContentSize(),a=ve(),u=s.getKey();if(s.isToken()||null!==a&&u===a&&!o||yi(i)&&(null!==e&&!e.canInsertTextBefore()&&0===i.anchor.offset||i.anchor.key===t.__key&&0===i.anchor.offset&&!s.canInsertTextBefore()&&!o||i.focus.key===t.__key&&i.focus.offset===c&&!s.canInsertTextAfter()&&!o))return void s.markDirty();const f=Oi();if(!yi(f)||null===n||null===r)return void s.setTextContent(l);if(f.setTextNodeRange(s,n,s,r),s.isSegmented()){const t=si(s.getTextContent());s.replace(t),s=t}s.setTextContent(l)}}}function We(t,e){if(e.isSegmented())return!0;if(!t.isCollapsed())return!1;const n=t.anchor.offset,r=e.getParentOrThrow(),i=e.isToken();return 0===n?!e.canInsertTextBefore()||!r.canInsertTextBefore()&&!e.isComposing()||i||function(t){const e=t.getPreviousSibling();return(oi(e)||_s(e)&&e.isInline())&&!e.canInsertTextAfter()}(e):n===e.getTextContentSize()&&(!e.canInsertTextAfter()||!r.canInsertTextAfter()&&!e.isComposing()||i)}function ze(t){return\"ArrowLeft\"===t}function Be(t){return\"ArrowRight\"===t}function Re(t,e){return q?t:e}function Ke(t){return\"Enter\"===t}function $e(t){return\"Backspace\"===t}function Je(t){return\"Delete\"===t}function Ue(t,e,n){return\"a\"===t.toLowerCase()&&Re(e,n)}function Ve(){const t=we();Ee(ee(t.select(0,t.getChildrenSize())))}function je(t,e){void 0===t.__lexicalClassNameCache&&(t.__lexicalClassNameCache={});const n=t.__lexicalClassNameCache,r=n[e];if(void 0!==r)return r;const i=t[e];if(\"string\"==typeof i){const t=Kt(i);return n[e]=t,t}return i}function He(t,e,n,r,i){if(0===n.size)return;const s=r.__type,o=r.__key,l=e.get(s);void 0===l&&Rt(33,s);const c=l.klass;let a=t.get(c);void 0===a&&(a=new Map,t.set(c,a));const u=a.get(o),f=\"destroyed\"===u&&\"created\"===i;(void 0===u||f)&&a.set(o,f?\"updated\":i)}function qe(t){const e=t.getType(),n=Gi();if(n._readOnly){const t=En(n).get(e);return t?Array.from(t.values()):[]}const r=n._nodeMap,i=[];for(const[,n]of r)n instanceof t&&n.__type===e&&n.isAttached()&&i.push(n);return i}function Qe(t,e,n){const r=t.getParent();let i=n,s=t;return null!==r&&(e&&0===n?(i=s.getIndexWithinParent(),s=r):e||n!==s.getChildrenSize()||(i=s.getIndexWithinParent()+1,s=r)),s.getChildAtIndex(e?i-1:i)}function Xe(t,e){const n=t.offset;if(\"element\"===t.type){return Qe(t.getNode(),e,n)}{const r=t.getNode();if(e&&0===n||!e&&n===r.getTextContentSize()){const t=e?r.getPreviousSibling():r.getNextSibling();return null===t?Qe(r.getParentOrThrow(),e,r.getIndexWithinParent()+(e?0:1)):t}}return null}function Ye(t){const e=on(t).event,n=e&&e.inputType;return\"insertFromPaste\"===n||\"insertFromPasteAsQuotation\"===n}function Ze(t,e,n){return us(t,e,n)}function Ge(t){return!vs(t)&&!t.isLastChild()&&!t.isInline()}function tn(t,e){const n=t._keyToDOMMap.get(e);return void 0===n&&Rt(75,e),n}function en(t){const e=t.assignedSlot||t.parentElement;return null!==e&&11===e.nodeType?e.host:e}function nn(t){return ts()._updateTags.has(t)}function rn(t){Yi();ts()._updateTags.add(t)}function sn(t,e){let n=t.getParent();for(;null!==n;){if(n.is(e))return!0;n=n.getParent()}return!1}function on(t){const e=t._window;return null===e&&Rt(78),e}function ln(t){return _s(t)&&t.isInline()||ms(t)&&t.isInline()}function cn(t){let e=t.getParentOrThrow();for(;null!==e;){if(an(e))return e;e=e.getParentOrThrow()}return e}function an(t){return vs(t)||_s(t)&&t.isShadowRoot()}function un(t){const e=t.constructor.clone(t);return pe(e,null),e}function fn(t){const e=ts(),n=t.constructor.getType(),r=e._nodes.get(n);void 0===r&&Rt(97);const i=r.replace;if(null!==i){const e=i(t);return e instanceof t.constructor||Rt(98),e}return t}function dn(t,e){!vs(t.getParent())||_s(e)||ms(e)||Rt(99)}function hn(t){const e=Se(t);return null===e&&Rt(63,t),e}function gn(t){return(ms(t)||_s(t)&&!t.canBeEmpty())&&!t.isInline()}function _n(t,e,n){n.style.removeProperty(\"caret-color\"),e._blockCursorElement=null;const r=t.parentElement;null!==r&&r.removeChild(t)}function pn(t,e,n){let r=t._blockCursorElement;if(yi(n)&&n.isCollapsed()&&\"element\"===n.anchor.type&&e.contains(document.activeElement)){const i=n.anchor,s=i.getNode(),o=i.offset;let l=!1,c=null;if(o===s.getChildrenSize()){gn(s.getChildAtIndex(o-1))&&(l=!0)}else{const e=s.getChildAtIndex(o);if(gn(e)){const n=e.getPreviousSibling();(null===n||gn(n))&&(l=!0,c=t.getElementByKey(e.__key))}}if(l){const n=t.getElementByKey(s.__key);return null===r&&(t._blockCursorElement=r=function(t){const e=t.theme,n=document.createElement(\"div\");n.contentEditable=\"false\",n.setAttribute(\"data-lexical-cursor\",\"true\");let r=e.blockCursor;if(void 0!==r){if(\"string\"==typeof r){const t=Kt(r);r=e.blockCursor=t}void 0!==r&&n.classList.add(...r)}return n}(t._config)),e.style.caretColor=\"transparent\",void(null===c?n.appendChild(r):n.insertBefore(r,c))}}null!==r&&_n(r,t,e)}function yn(t){return j?(t||window).getSelection():null}function mn(t,e){let n=t.getChildAtIndex(e);null==n&&(n=t),an(t)&&Rt(102);const r=t=>{const e=t.getParentOrThrow(),i=an(e),s=t!==n||i?un(t):t;if(i)return _s(t)&&_s(s)||Rt(133),t.insertAfter(s),[t,s,s];{const[n,i,o]=r(e),l=t.getNextSiblings();return o.append(s,...l),[n,i,s]}},[i,s]=r(n);return[i,s]}function xn(t){return vn(t)&&\"A\"===t.tagName}function vn(t){return 1===t.nodeType}function Sn(t){const e=new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/,\"i\");return null!==t.nodeName.match(e)}function Tn(t){const e=new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/,\"i\");return null!==t.nodeName.match(e)}function Cn(t){if(vs(t)||ms(t)&&!t.isInline())return!0;if(!_s(t)||an(t))return!1;const e=t.getFirstChild(),n=null===e||$r(e)||oi(e)||e.isInline();return!t.isInline()&&!1!==t.canBeEmpty()&&n}function kn(t,e){let n=t;for(;null!==n&&null!==n.getParent()&&!e(n);)n=n.getParentOrThrow();return e(n)?n:null}function bn(){return ts()}const wn=new WeakMap,Nn=new Map;function En(t){if(!t._readOnly&&t.isEmpty())return Nn;t._readOnly||Rt(192);let e=wn.get(t);if(!e){e=new Map,wn.set(t,e);for(const[n,r]of t._nodeMap){const t=r.__type;let i=e.get(t);i||(i=new Map,e.set(t,i)),i.set(n,r)}}return e}function Pn(t){const e=t.constructor.clone(t);return e.afterCloneFrom(t),e}function Fn(t,e,n,r,i,s){let o=t.getFirstChild();for(;null!==o;){const t=o.__key;o.__parent===e&&(_s(o)&&Fn(o,t,n,r,i,s),n.has(t)||s.delete(t),i.push(t)),o=o.getNextSibling()}}let Dn,Ln,On,In,An,Mn,Wn,zn,Bn,Rn,Kn=\"\",$n=\"\",Jn=null,Un=\"\",Vn=\"\",jn=!1,Hn=!1,qn=null;function Qn(t,e){const n=Wn.get(t);if(null!==e){const n=dr(t);n.parentNode===e&&e.removeChild(n)}if(zn.has(t)||Ln._keyToDOMMap.delete(t),_s(n)){const t=lr(n,Wn);Xn(t,0,t.length-1,null)}void 0!==n&&He(Rn,On,In,n,\"destroyed\")}function Xn(t,e,n,r){let i=e;for(;i<=n;++i){const e=t[i];void 0!==e&&Qn(e,r)}}function Yn(t,e){t.setProperty(\"text-align\",e)}const Zn=\"40px\";function Gn(t,e){const n=Dn.theme.indent;if(\"string\"==typeof n){const r=t.classList.contains(n);e>0&&!r?t.classList.add(n):e<1&&r&&t.classList.remove(n)}const r=getComputedStyle(t).getPropertyValue(\"--lexical-indent-base-value\")||Zn;t.style.setProperty(\"padding-inline-start\",0===e?\"\":`calc(${e} * ${r})`)}function tr(t,e){const n=t.style;0===e?Yn(n,\"\"):e===vt?Yn(n,\"left\"):e===St?Yn(n,\"center\"):e===Tt?Yn(n,\"right\"):e===Ct?Yn(n,\"justify\"):e===kt?Yn(n,\"start\"):e===bt&&Yn(n,\"end\")}function er(t,e,n){const r=zn.get(t);void 0===r&&Rt(60);const i=r.createDOM(Dn,Ln);if(function(t,e,n){const r=n._keyToDOMMap;e[\"__lexicalKey_\"+n._key]=t,r.set(t,e)}(t,i,Ln),oi(r)?i.setAttribute(\"data-lexical-text\",\"true\"):ms(r)&&i.setAttribute(\"data-lexical-decorator\",\"true\"),_s(r)){const t=r.__indent,e=r.__size;if(0!==t&&Gn(i,t),0!==e){const t=e-1;!function(t,e,n,r){const i=$n;$n=\"\",nr(t,n,0,e,r,null),sr(n,r),$n=i}(lr(r,zn),t,r,i)}const n=r.__format;0!==n&&tr(i,n),r.isInline()||ir(null,r,i),Ge(r)&&(Kn+=Nt,Vn+=Nt)}else{const e=r.getTextContent();if(ms(r)){const e=r.decorate(Ln,Dn);null!==e&&ar(t,e),i.contentEditable=\"false\"}else oi(r)&&(r.isDirectionless()||($n+=e));Kn+=e,Vn+=e}if(null!==e)if(null!=n)e.insertBefore(i,n);else{const t=e.__lexicalLineBreak;null!=t?e.insertBefore(i,t):e.appendChild(i)}return He(Rn,On,In,r,\"created\"),i}function nr(t,e,n,r,i,s){const o=Kn;Kn=\"\";let l=n;for(;l<=r;++l){er(t[l],i,s);const e=zn.get(t[l]);null!==e&&oi(e)&&(null===Jn&&(Jn=e.getFormat()),\"\"===Un&&(Un=e.getStyle()))}Ge(e)&&(Kn+=Nt),i.__lexicalTextContent=Kn,Kn=o+Kn}function rr(t,e){const n=e.get(t);return $r(n)||ms(n)&&n.isInline()}function ir(t,e,n){const r=null!==t&&(0===t.__size||rr(t.__last,Wn)),i=0===e.__size||rr(e.__last,zn);if(r){if(!i){const t=n.__lexicalLineBreak;if(null!=t)try{n.removeChild(t)}catch(e){if(\"object\"==typeof e&&null!=e){const r=`${e.toString()} Parent: ${n.tagName}, child: ${t.tagName}.`;throw new Error(r)}throw e}n.__lexicalLineBreak=null}}else if(i){const t=document.createElement(\"br\");n.__lexicalLineBreak=t,n.appendChild(t)}}function sr(t,e){const n=e.__lexicalDirTextContent,r=e.__lexicalDir;if(n!==$n||r!==qn){const n=\"\"===$n,s=n?qn:(i=$n,Dt.test(i)?\"rtl\":Lt.test(i)?\"ltr\":null);if(s!==r){const i=e.classList,o=Dn.theme;let l=null!==r?o[r]:void 0,c=null!==s?o[s]:void 0;if(void 0!==l){if(\"string\"==typeof l){const t=Kt(l);l=o[r]=t}i.remove(...l)}if(null===s||n&&\"ltr\"===s)e.removeAttribute(\"dir\");else{if(void 0!==c){if(\"string\"==typeof c){const t=Kt(c);c=o[s]=t}void 0!==c&&i.add(...c)}e.dir=s}if(!Hn){t.getWritable().__dir=s}}qn=s,e.__lexicalDirTextContent=$n,e.__lexicalDir=s}var i}function or(t,e,n){const r=$n;var i;$n=\"\",Jn=null,Un=\"\",function(t,e,n){const r=Kn,i=t.__size,s=e.__size;if(Kn=\"\",1===i&&1===s){const r=t.__first,i=e.__first;if(r===i)cr(r,n);else{const t=dr(r),e=er(i,null,null);try{n.replaceChild(e,t)}catch(s){if(\"object\"==typeof s&&null!=s){const o=`${s.toString()} Parent: ${n.tagName}, new child: {tag: ${e.tagName} key: ${i}}, old child: {tag: ${t.tagName}, key: ${r}}.`;throw new Error(o)}throw s}Qn(r,null)}const s=zn.get(i);oi(s)&&(null===Jn&&(Jn=s.getFormat()),\"\"===Un&&(Un=s.getStyle()))}else{const r=lr(t,Wn),o=lr(e,zn);if(0===i)0!==s&&nr(o,e,0,s-1,n,null);else if(0===s){if(0!==i){const t=null==n.__lexicalLineBreak;Xn(r,0,i-1,t?null:n),t&&(n.textContent=\"\")}}else!function(t,e,n,r,i,s){const o=r-1,l=i-1;let c,a,u=(h=s,h.firstChild),f=0,d=0;var h;for(;f<=o&&d<=l;){const t=e[f],r=n[d];if(t===r)u=ur(cr(r,s)),f++,d++;else{void 0===c&&(c=new Set(e)),void 0===a&&(a=new Set(n));const i=a.has(t),o=c.has(r);if(i)if(o){const t=tn(Ln,r);t===u?u=ur(cr(r,s)):(null!=u?s.insertBefore(t,u):s.appendChild(t),cr(r,s)),f++,d++}else er(r,s,u),d++;else u=ur(dr(t)),Qn(t,s),f++}const i=zn.get(r);null!==i&&oi(i)&&(null===Jn&&(Jn=i.getFormat()),\"\"===Un&&(Un=i.getStyle()))}const g=f>o,_=d>l;if(g&&!_){const e=n[l+1];nr(n,t,d,l,s,void 0===e?null:Ln.getElementByKey(e))}else _&&!g&&Xn(e,f,o,s)}(e,r,o,i,s,n)}Ge(e)&&(Kn+=Nt);n.__lexicalTextContent=Kn,Kn=r+Kn}(t,e,n),sr(e,n),Es(i=e)&&null!=Jn&&Jn!==i.__textFormat&&!Hn&&(i.setTextFormat(Jn),i.setTextStyle(Un)),function(t){Es(t)&&\"\"!==Un&&Un!==t.__textStyle&&!Hn&&t.setTextStyle(Un)}(e),$n=r}function lr(t,e){const n=[];let r=t.__first;for(;null!==r;){const t=e.get(r);void 0===t&&Rt(101),n.push(r),r=t.__next}return n}function cr(t,e){const n=Wn.get(t);let r=zn.get(t);void 0!==n&&void 0!==r||Rt(61);const i=jn||Mn.has(t)||An.has(t),s=tn(Ln,t);if(n===r&&!i){if(_s(n)){const t=s.__lexicalTextContent;void 0!==t&&(Kn+=t,Vn+=t);const e=s.__lexicalDirTextContent;void 0!==e&&($n+=e)}else{const t=n.getTextContent();oi(n)&&!n.isDirectionless()&&($n+=t),Vn+=t,Kn+=t}return s}if(n!==r&&i&&He(Rn,On,In,r,\"updated\"),r.updateDOM(n,s,Dn)){const n=er(t,null,null);return null===e&&Rt(62),e.replaceChild(n,s),Qn(t,null),n}if(_s(n)&&_s(r)){const t=r.__indent;t!==n.__indent&&Gn(s,t);const e=r.__format;e!==n.__format&&tr(s,e),i&&(or(n,r,s),vs(r)||r.isInline()||ir(n,r,s)),Ge(r)&&(Kn+=Nt,Vn+=Nt)}else{const e=r.getTextContent();if(ms(r)){const e=r.decorate(Ln,Dn);null!==e&&ar(t,e)}else oi(r)&&!r.isDirectionless()&&($n+=e);Kn+=e,Vn+=e}if(!Hn&&vs(r)&&r.__cachedText!==Vn){const t=r.getWritable();t.__cachedText=Vn,r=t}return s}function ar(t,e){let n=Ln._pendingDecorators;const r=Ln._decorators;if(null===n){if(r[t]===e)return;n=ke(Ln)}n[t]=e}function ur(t){let e=t.nextSibling;return null!==e&&e===Ln._blockCursorElement&&(e=e.nextSibling),e}function fr(t,e,n,r,i,s){Kn=\"\",Vn=\"\",$n=\"\",jn=r===lt,qn=null,Ln=n,Dn=n._config,On=n._nodes,In=Ln._listeners.mutation,An=i,Mn=s,Wn=t._nodeMap,zn=e._nodeMap,Hn=e._readOnly,Bn=new Map(n._keyToDOMMap);const o=new Map;return Rn=o,cr(\"root\",null),Ln=void 0,On=void 0,An=void 0,Mn=void 0,Wn=void 0,zn=void 0,Dn=void 0,Bn=void 0,Rn=void 0,o}function dr(t){const e=Bn.get(t);return void 0===e&&Rt(75,t),e}const hr=Object.freeze({}),gr=30,_r=[[\"keydown\",function(t,e){if(pr=t.timeStamp,yr=t.key,e.isComposing())return;const{key:n,shiftKey:r,ctrlKey:o,metaKey:l,altKey:c}=t;if(Ze(e,_,t))return;if(null==n)return;if(function(t,e,n,r){return Be(t)&&!e&&!r&&!n}(n,o,c,l))Ze(e,p,t);else if(function(t,e,n,r,i){return Be(t)&&!r&&!n&&(e||i)}(n,o,r,c,l))Ze(e,y,t);else if(function(t,e,n,r){return ze(t)&&!e&&!r&&!n}(n,o,c,l))Ze(e,m,t);else if(function(t,e,n,r,i){return ze(t)&&!r&&!n&&(e||i)}(n,o,r,c,l))Ze(e,x,t);else if(function(t,e,n){return function(t){return\"ArrowUp\"===t}(t)&&!e&&!n}(n,o,l))Ze(e,v,t);else if(function(t,e,n){return function(t){return\"ArrowDown\"===t}(t)&&!e&&!n}(n,o,l))Ze(e,S,t);else if(function(t,e){return Ke(t)&&e}(n,r))Cr=!0,Ze(e,T,t);else if(function(t){return\" \"===t}(n))Ze(e,C,t);else if(function(t,e){return q&&e&&\"o\"===t.toLowerCase()}(n,o))t.preventDefault(),Cr=!0,Ze(e,s,!0);else if(function(t,e){return Ke(t)&&!e}(n,r))Cr=!1,Ze(e,T,t);else if(function(t,e,n,r){return q?!e&&!n&&($e(t)||\"h\"===t.toLowerCase()&&r):!(r||e||n)&&$e(t)}(n,c,l,o))$e(n)?Ze(e,k,t):(t.preventDefault(),Ze(e,i,!0));else if(function(t){return\"Escape\"===t}(n))Ze(e,b,t);else if(function(t,e,n,r,i){return q?!(n||r||i)&&(Je(t)||\"d\"===t.toLowerCase()&&e):!(e||r||i)&&Je(t)}(n,o,r,c,l))Je(n)?Ze(e,w,t):(t.preventDefault(),Ze(e,i,!1));else if(function(t,e,n){return $e(t)&&(q?e:n)}(n,c,o))t.preventDefault(),Ze(e,u,!0);else if(function(t,e,n){return Je(t)&&(q?e:n)}(n,c,o))t.preventDefault(),Ze(e,u,!1);else if(function(t,e){return q&&e&&$e(t)}(n,l))t.preventDefault(),Ze(e,f,!0);else if(function(t,e){return q&&e&&Je(t)}(n,l))t.preventDefault(),Ze(e,f,!1);else if(function(t,e,n,r){return\"b\"===t.toLowerCase()&&!e&&Re(n,r)}(n,c,l,o))t.preventDefault(),Ze(e,d,\"bold\");else if(function(t,e,n,r){return\"u\"===t.toLowerCase()&&!e&&Re(n,r)}(n,c,l,o))t.preventDefault(),Ze(e,d,\"underline\");else if(function(t,e,n,r){return\"i\"===t.toLowerCase()&&!e&&Re(n,r)}(n,c,l,o))t.preventDefault(),Ze(e,d,\"italic\");else if(function(t,e,n,r){return\"Tab\"===t&&!e&&!n&&!r}(n,c,o,l))Ze(e,N,t);else if(function(t,e,n,r){return\"z\"===t.toLowerCase()&&!e&&Re(n,r)}(n,r,l,o))t.preventDefault(),Ze(e,h,void 0);else if(function(t,e,n,r){return q?\"z\"===t.toLowerCase()&&n&&e:\"y\"===t.toLowerCase()&&r||\"z\"===t.toLowerCase()&&r&&e}(n,r,l,o))t.preventDefault(),Ze(e,g,void 0);else{xi(e._editorState._selection)?!function(t,e,n,r){return!e&&\"c\"===t.toLowerCase()&&(q?n:r)}(n,r,l,o)?!function(t,e,n,r){return!e&&\"x\"===t.toLowerCase()&&(q?n:r)}(n,r,l,o)?Ue(n,l,o)&&(t.preventDefault(),Ze(e,z,t)):(t.preventDefault(),Ze(e,W,t)):(t.preventDefault(),Ze(e,M,t)):!Q&&Ue(n,l,o)&&(t.preventDefault(),Ze(e,z,t))}(function(t,e,n,r){return t||e||n||r})(o,r,c,l)&&Ze(e,V,t)}],[\"pointerdown\",function(t,e){const n=t.target,r=t.pointerType;n instanceof Node&&\"touch\"!==r&&hs(e,(()=>{ms(Ce(n))||(Tr=!0)}))}],[\"compositionstart\",function(t,e){hs(e,(()=>{const n=Oi();if(yi(n)&&!e.isComposing()){const r=n.anchor,i=n.anchor.getNode();xe(r.key),(t.timeStamp<pr+gr||\"element\"===r.type||!n.isCollapsed()||i.getFormat()!==n.format||oi(i)&&i.getStyle()!==n.style)&&Ze(e,l,Et)}}))}],[\"compositionend\",function(t,e){Q?kr=!0:hs(e,(()=>{Fr(e,t.data)}))}],[\"input\",function(t,e){t.stopPropagation(),hs(e,(()=>{const n=Oi(),r=t.data,i=Pr(t);if(null!=r&&yi(n)&&wr(n,i,r,t.timeStamp,!1)){kr&&(Fr(e,r),kr=!1);const i=n.anchor.getNode(),s=yn(e._window);if(null===s)return;const o=n.isBackward(),c=o?n.anchor.offset:n.focus.offset,a=o?n.focus.offset:n.anchor.offset;X&&!n.isCollapsed()&&oi(i)&&null!==s.anchorNode&&i.getTextContent().slice(0,c)+r+i.getTextContent().slice(c+a)===Ie(s.anchorNode)||Ze(e,l,r);const u=r.length;Q&&u>1&&\"insertCompositionText\"===t.inputType&&!e.isComposing()&&(n.anchor.offset-=u),Y||Z||nt||!e.isComposing()||(pr=0,xe(null))}else{Ae(!1,e,null!==r?r:void 0),kr&&(Fr(e,r||void 0),kr=!1)}Yi(),Xt(ts())})),xr=null}],[\"click\",function(t,e){hs(e,(()=>{const n=Oi(),i=yn(e._window),s=Ii();if(i)if(yi(n)){const e=n.anchor,r=e.getNode();if(\"element\"===e.type&&0===e.offset&&n.isCollapsed()&&!vs(r)&&1===we().getChildrenSize()&&r.getTopLevelElementOrThrow().isEmpty()&&null!==s&&n.is(s))i.removeAllRanges(),n.dirty=!0;else if(3===t.detail&&!n.isCollapsed()){r!==n.focus.getNode()&&(_s(r)?r.select(0):r.getParentOrThrow().select(0))}}else if(\"touch\"===t.pointerType){const n=i.anchorNode;if(null!==n){const r=n.nodeType;if(r===rt||r===it){Ee(Li(s,i,e,t))}}}Ze(e,r,t)}))}],[\"cut\",hr],[\"copy\",hr],[\"dragstart\",hr],[\"dragover\",hr],[\"dragend\",hr],[\"paste\",hr],[\"focus\",hr],[\"blur\",hr],[\"drop\",hr]];X&&_r.push([\"beforeinput\",(t,e)=>function(t,e){const n=t.inputType,r=Pr(t);if(\"deleteCompositionText\"===n||Q&&Ye(e))return;if(\"insertCompositionText\"===n)return;hs(e,(()=>{const _=Oi();if(\"deleteContentBackward\"===n){if(null===_){const t=Ii();if(!yi(t))return;Ee(t.clone())}if(yi(_)){const n=_.anchor.key===_.focus.key;if(p=t.timeStamp,\"MediaLast\"===yr&&p<pr+gr&&e.isComposing()&&n){if(xe(null),pr=0,setTimeout((()=>{hs(e,(()=>{xe(null)}))}),gr),yi(_)){const t=_.anchor.getNode();t.markDirty(),_.format=t.getFormat(),oi(t)||Rt(142),_.style=t.getStyle()}}else{xe(null),t.preventDefault();const r=_.anchor.getNode().getTextContent(),s=0===_.anchor.offset&&_.focus.offset===r.length;et&&n&&!s||Ze(e,i,!0)}return}}var p;if(!yi(_))return;const y=t.data;null!==xr&&Ae(!1,e,xr),_.dirty&&null===xr||!_.isCollapsed()||vs(_.anchor.getNode())||null===r||_.applyDOMRange(r),xr=null;const m=_.anchor,x=_.focus,v=m.getNode(),S=x.getNode();if(\"insertText\"!==n&&\"insertTranspose\"!==n)switch(t.preventDefault(),n){case\"insertFromYank\":case\"insertFromDrop\":case\"insertReplacementText\":Ze(e,l,t);break;case\"insertFromComposition\":xe(null),Ze(e,l,t);break;case\"insertLineBreak\":xe(null),Ze(e,s,!1);break;case\"insertParagraph\":xe(null),Cr&&!Z?(Cr=!1,Ze(e,s,!1)):Ze(e,o,void 0);break;case\"insertFromPaste\":case\"insertFromPasteAsQuotation\":Ze(e,c,t);break;case\"deleteByComposition\":(function(t,e){return t!==e||_s(t)||_s(e)||!t.isToken()||!e.isToken()})(v,S)&&Ze(e,a,t);break;case\"deleteByDrag\":case\"deleteByCut\":Ze(e,a,t);break;case\"deleteContent\":Ze(e,i,!1);break;case\"deleteWordBackward\":Ze(e,u,!0);break;case\"deleteWordForward\":Ze(e,u,!1);break;case\"deleteHardLineBackward\":case\"deleteSoftLineBackward\":Ze(e,f,!0);break;case\"deleteContentForward\":case\"deleteHardLineForward\":case\"deleteSoftLineForward\":Ze(e,f,!1);break;case\"formatStrikeThrough\":Ze(e,d,\"strikethrough\");break;case\"formatBold\":Ze(e,d,\"bold\");break;case\"formatItalic\":Ze(e,d,\"italic\");break;case\"formatUnderline\":Ze(e,d,\"underline\");break;case\"historyUndo\":Ze(e,h,void 0);break;case\"historyRedo\":Ze(e,g,void 0)}else{if(\"\\n\"===y)t.preventDefault(),Ze(e,s,!1);else if(y===Nt)t.preventDefault(),Ze(e,o,void 0);else if(null==y&&t.dataTransfer){const e=t.dataTransfer.getData(\"text/plain\");t.preventDefault(),_.insertRawText(e)}else null!=y&&wr(_,r,y,t.timeStamp,!0)?(t.preventDefault(),Ze(e,l,y)):xr=y;mr=t.timeStamp}}))}(t,e)]);let pr=0,yr=null,mr=0,xr=null;const vr=new WeakMap;let Sr=!1,Tr=!1,Cr=!1,kr=!1,br=[0,\"\",0,\"root\",0];function wr(t,e,n,r,i){const s=t.anchor,o=t.focus,l=s.getNode(),c=ts(),a=yn(c._window),u=null!==a?a.anchorNode:null,f=s.key,d=c.getElementByKey(f),h=n.length;return f!==o.key||!oi(l)||(!i&&(!X||mr<r+50)||l.isDirty()&&h<2||De(n))&&s.offset!==o.offset&&!l.isComposing()||fe(l)||l.isDirty()&&h>1||(i||!X)&&null!==d&&!l.isComposing()&&u!==he(d)||null!==a&&null!==e&&(!e.collapsed||e.startContainer!==a.anchorNode||e.startOffset!==a.anchorOffset)||l.getFormat()!==t.format||l.getStyle()!==t.style||We(t,l)}function Nr(t,e){return null!==t&&null!==t.nodeValue&&t.nodeType===it&&0!==e&&e!==t.nodeValue.length}function Er(t,n,r){const{anchorNode:i,anchorOffset:s,focusNode:o,focusOffset:l}=t;Sr&&(Sr=!1,Nr(i,s)&&Nr(o,l))||hs(n,(()=>{if(!r)return void Ee(null);if(!le(n,i,o))return;const c=Oi();if(yi(c)){const e=c.anchor,r=e.getNode();if(c.isCollapsed()){\"Range\"===t.type&&t.anchorNode===t.focusNode&&(c.dirty=!0);const i=on(n).event,s=i?i.timeStamp:performance.now(),[o,l,a,u,f]=br,d=we(),h=!1===n.isComposing()&&\"\"===d.getTextContent();if(s<f+200&&e.offset===a&&e.key===u)c.format=o,c.style=l;else if(\"text\"===e.type)oi(r)||Rt(141),c.format=r.getFormat(),c.style=r.getStyle();else if(\"element\"===e.type&&!h){const t=e.getNode();c.style=\"\",t instanceof bs&&0===t.getChildrenSize()?(c.format=t.getTextFormat(),c.style=t.getTextStyle()):c.format=0}}else{const t=e.key,n=c.focus.key,r=c.getNodes(),i=r.length,o=c.isBackward(),a=o?l:s,u=o?s:l,f=o?n:t,d=o?t:n;let h=xt,g=!1;for(let t=0;t<i;t++){const e=r[t],n=e.getTextContentSize();if(oi(e)&&0!==n&&!(0===t&&e.__key===f&&a===n||t===i-1&&e.__key===d&&0===u)&&(g=!0,h&=e.getFormat(),0===h))break}c.format=g?h:0}}Ze(n,e,void 0)}))}function Pr(t){if(!t.getTargetRanges)return null;const e=t.getTargetRanges();return 0===e.length?null:e[0]}function Fr(t,e){const n=t._compositionKey;if(xe(null),null!==n&&null!=e){if(\"\"===e){const e=Se(n),r=he(t.getElementByKey(n));return void(null!==r&&null!==r.nodeValue&&oi(e)&&Me(e,r.nodeValue,null,null,!0))}if(\"\\n\"===e[e.length-1]){const e=Oi();if(yi(e)){const n=e.focus;return e.anchor.set(n.key,n.offset,n.type),void Ze(t,T,null)}}}Ae(!0,t,e)}function Dr(t){let e=t.__lexicalEventHandles;return void 0===e&&(e=[],t.__lexicalEventHandles=e),e}const Lr=new Map;function Or(t){const e=t.target,n=yn(null==e?null:9===e.nodeType?e.defaultView:e.ownerDocument.defaultView);if(null===n)return;const r=ae(n.anchorNode);if(null===r)return;Tr&&(Tr=!1,hs(r,(()=>{const e=Ii(),i=n.anchorNode;if(null===i)return;const s=i.nodeType;if(s!==rt&&s!==it)return;Ee(Li(e,n,r,t))})));const i=Le(r),s=i[i.length-1],o=s._key,l=Lr.get(o),c=l||s;c!==r&&Er(n,c,!1),Er(n,r,!0),r!==s?Lr.set(o,r):l&&Lr.delete(o)}function Ir(t){t._lexicalHandled=!0}function Ar(t){return!0===t._lexicalHandled}function Mr(t){const e=t.ownerDocument,n=vr.get(e);void 0===n&&Rt(162);const r=n-1;r>=0||Rt(164),vr.set(e,r),0===r&&e.removeEventListener(\"selectionchange\",Or);const i=ue(t);ce(i)?(!function(t){if(null!==t._parentEditor){const e=Le(t),n=e[e.length-1]._key;Lr.get(n)===t&&Lr.delete(n)}else Lr.delete(t._key)}(i),t.__lexicalEditor=null):i&&Rt(198);const s=Dr(t);for(let t=0;t<s.length;t++)s[t]();t.__lexicalEventHandles=[]}function Wr(t,e,n){Yi();const r=t.__key,i=t.getParent();if(null===i)return;const s=function(t){const e=Oi();if(!yi(e)||!_s(t))return e;const{anchor:n,focus:r}=e,i=n.getNode(),s=r.getNode();return sn(i,t)&&n.set(t.__key,0,\"element\"),sn(s,t)&&r.set(t.__key,0,\"element\"),e}(t);let o=!1;if(yi(s)&&e){const e=s.anchor,n=s.focus;e.key===r&&(Wi(e,t,i,t.getPreviousSibling(),t.getNextSibling()),o=!0),n.key===r&&(Wi(n,t,i,t.getPreviousSibling(),t.getNextSibling()),o=!0)}else xi(s)&&e&&t.isSelected()&&t.selectPrevious();if(yi(s)&&e&&!o){const e=t.getIndexWithinParent();ye(t),Ai(s,i,e,-1)}else ye(t);n||an(i)||i.canBeEmpty()||!i.isEmpty()||Wr(i,e),e&&vs(i)&&i.isEmpty()&&i.selectEnd()}class zr{static getType(){Rt(64,this.name)}static clone(t){Rt(65,this.name)}afterCloneFrom(t){this.__parent=t.__parent,this.__next=t.__next,this.__prev=t.__prev}constructor(t){this.__type=this.constructor.getType(),this.__parent=null,this.__prev=null,this.__next=null,pe(this,t)}getType(){return this.__type}isInline(){Rt(137,this.constructor.name)}isAttached(){let t=this.__key;for(;null!==t;){if(\"root\"===t)return!0;const e=Se(t);if(null===e)break;t=e.__parent}return!1}isSelected(t){const e=t||Oi();if(null==e)return!1;const n=e.getNodes().some((t=>t.__key===this.__key));if(oi(this))return n;if(yi(e)&&\"element\"===e.anchor.type&&\"element\"===e.focus.type){if(e.isCollapsed())return!1;const t=this.getParent();if(ms(this)&&this.isInline()&&t){const n=e.isBackward()?e.focus:e.anchor,r=n.getNode();if(n.offset===r.getChildrenSize()&&r.is(t)&&r.getLastChildOrThrow().is(this))return!1}}return n}getKey(){return this.__key}getIndexWithinParent(){const t=this.getParent();if(null===t)return-1;let e=t.getFirstChild(),n=0;for(;null!==e;){if(this.is(e))return n;n++,e=e.getNextSibling()}return-1}getParent(){const t=this.getLatest().__parent;return null===t?null:Se(t)}getParentOrThrow(){const t=this.getParent();return null===t&&Rt(66,this.__key),t}getTopLevelElement(){let t=this;for(;null!==t;){const e=t.getParent();if(an(e))return _s(t)||t===this&&ms(t)||Rt(194),t;t=e}return null}getTopLevelElementOrThrow(){const t=this.getTopLevelElement();return null===t&&Rt(67,this.__key),t}getParents(){const t=[];let e=this.getParent();for(;null!==e;)t.push(e),e=e.getParent();return t}getParentKeys(){const t=[];let e=this.getParent();for(;null!==e;)t.push(e.__key),e=e.getParent();return t}getPreviousSibling(){const t=this.getLatest().__prev;return null===t?null:Se(t)}getPreviousSiblings(){const t=[],e=this.getParent();if(null===e)return t;let n=e.getFirstChild();for(;null!==n&&!n.is(this);)t.push(n),n=n.getNextSibling();return t}getNextSibling(){const t=this.getLatest().__next;return null===t?null:Se(t)}getNextSiblings(){const t=[];let e=this.getNextSibling();for(;null!==e;)t.push(e),e=e.getNextSibling();return t}getCommonAncestor(t){const e=this.getParents(),n=t.getParents();_s(this)&&e.unshift(this),_s(t)&&n.unshift(t);const r=e.length,i=n.length;if(0===r||0===i||e[r-1]!==n[i-1])return null;const s=new Set(n);for(let t=0;t<r;t++){const n=e[t];if(s.has(n))return n}return null}is(t){return null!=t&&this.__key===t.__key}isBefore(t){if(this===t)return!1;if(t.isParentOf(this))return!0;if(this.isParentOf(t))return!1;const e=this.getCommonAncestor(t);let n=0,r=0,i=this;for(;;){const t=i.getParentOrThrow();if(t===e){n=i.getIndexWithinParent();break}i=t}for(i=t;;){const t=i.getParentOrThrow();if(t===e){r=i.getIndexWithinParent();break}i=t}return n<r}isParentOf(t){const e=this.__key;if(e===t.__key)return!1;let n=t;for(;null!==n;){if(n.__key===e)return!0;n=n.getParent()}return!1}getNodesBetween(t){const e=this.isBefore(t),n=[],r=new Set;let i=this;for(;null!==i;){const s=i.__key;if(r.has(s)||(r.add(s),n.push(i)),i===t)break;const o=_s(i)?e?i.getFirstChild():i.getLastChild():null;if(null!==o){i=o;continue}const l=e?i.getNextSibling():i.getPreviousSibling();if(null!==l){i=l;continue}const c=i.getParentOrThrow();if(r.has(c.__key)||n.push(c),c===t)break;let a=null,u=c;do{if(null===u&&Rt(68),a=e?u.getNextSibling():u.getPreviousSibling(),u=u.getParent(),null===u)break;null!==a||r.has(u.__key)||n.push(u)}while(null===a);i=a}return e||n.reverse(),n}isDirty(){const t=ts()._dirtyLeaves;return null!==t&&t.has(this.__key)}getLatest(){const t=Se(this.__key);return null===t&&Rt(113),t}getWritable(){Yi();const t=Gi(),e=ts(),n=t._nodeMap,r=this.__key,i=this.getLatest(),s=e._cloneNotNeeded,o=Oi();if(null!==o&&o.setCachedNodes(null),s.has(r))return me(i),i;const l=Pn(i);return s.add(r),me(l),n.set(r,l),l}getTextContent(){return\"\"}getTextContentSize(){return this.getTextContent().length}createDOM(t,e){Rt(70)}updateDOM(t,e,n){Rt(71)}exportDOM(t){return{element:this.createDOM(t._config,t)}}exportJSON(){Rt(72)}static importJSON(t){Rt(18,this.name)}static transform(){return null}remove(t){Wr(this,!0,t)}replace(t,e){Yi();let n=Oi();null!==n&&(n=n.clone()),dn(this,t);const r=this.getLatest(),i=this.__key,s=t.__key,o=t.getWritable(),l=this.getParentOrThrow().getWritable(),c=l.__size;ye(o);const a=r.getPreviousSibling(),u=r.getNextSibling(),f=r.__prev,d=r.__next,h=r.__parent;if(Wr(r,!1,!0),null===a)l.__first=s;else{a.getWritable().__next=s}if(o.__prev=f,null===u)l.__last=s;else{u.getWritable().__prev=s}if(o.__next=d,o.__parent=h,l.__size=c,e&&(_s(this)&&_s(o)||Rt(139),this.getChildren().forEach((t=>{o.append(t)}))),yi(n)){Ee(n);const t=n.anchor,e=n.focus;t.key===i&&gi(t,o),e.key===i&&gi(e,o)}return ve()===i&&xe(s),o}insertAfter(t,e=!0){Yi(),dn(this,t);const n=this.getWritable(),r=t.getWritable(),i=r.getParent(),s=Oi();let o=!1,l=!1;if(null!==i){const e=t.getIndexWithinParent();if(ye(r),yi(s)){const t=i.__key,n=s.anchor,r=s.focus;o=\"element\"===n.type&&n.key===t&&n.offset===e+1,l=\"element\"===r.type&&r.key===t&&r.offset===e+1}}const c=this.getNextSibling(),a=this.getParentOrThrow().getWritable(),u=r.__key,f=n.__next;if(null===c)a.__last=u;else{c.getWritable().__prev=u}if(a.__size++,n.__next=u,r.__next=f,r.__prev=n.__key,r.__parent=n.__parent,e&&yi(s)){const t=this.getIndexWithinParent();Ai(s,a,t+1);const e=a.__key;o&&s.anchor.set(e,t+2,\"element\"),l&&s.focus.set(e,t+2,\"element\")}return t}insertBefore(t,e=!0){Yi(),dn(this,t);const n=this.getWritable(),r=t.getWritable(),i=r.__key;ye(r);const s=this.getPreviousSibling(),o=this.getParentOrThrow().getWritable(),l=n.__prev,c=this.getIndexWithinParent();if(null===s)o.__first=i;else{s.getWritable().__next=i}o.__size++,n.__prev=i,r.__prev=l,r.__next=n.__key,r.__parent=n.__parent;const a=Oi();if(e&&yi(a)){Ai(a,this.getParentOrThrow(),c)}return t}isParentRequired(){return!1}createParentElementNode(){return Ns()}selectStart(){return this.selectPrevious()}selectEnd(){return this.selectNext(0,0)}selectPrevious(t,e){Yi();const n=this.getPreviousSibling(),r=this.getParentOrThrow();if(null===n)return r.select(0,0);if(_s(n))return n.select();if(!oi(n)){const t=n.getIndexWithinParent()+1;return r.select(t,t)}return n.select(t,e)}selectNext(t,e){Yi();const n=this.getNextSibling(),r=this.getParentOrThrow();if(null===n)return r.select();if(_s(n))return n.select(0,0);if(!oi(n)){const t=n.getIndexWithinParent();return r.select(t,t)}return n.select(t,e)}markDirty(){this.getWritable()}}class Br extends zr{static getType(){return\"linebreak\"}static clone(t){return new Br(t.__key)}constructor(t){super(t)}getTextContent(){return\"\\n\"}createDOM(){return document.createElement(\"br\")}updateDOM(){return!1}static importDOM(){return{br:t=>function(t){const e=t.parentElement;if(null!==e&&Tn(e)){const n=e.firstChild;if(n===t||n.nextSibling===t&&Jr(n)){const n=e.lastChild;if(n===t||n.previousSibling===t&&Jr(n))return!0}}return!1}(t)||function(t){const e=t.parentElement;if(null!==e&&Tn(e)){const n=e.firstChild;if(n===t||n.nextSibling===t&&Jr(n))return!1;const r=e.lastChild;if(r===t||r.previousSibling===t&&Jr(r))return!0}return!1}(t)?null:{conversion:Rr,priority:0}}}static importJSON(t){return Kr()}exportJSON(){return{type:\"linebreak\",version:1}}}function Rr(t){return{node:Kr()}}function Kr(){return fn(new Br)}function $r(t){return t instanceof Br}function Jr(t){return t.nodeType===it&&/^( |\\t|\\r?\\n)+$/.test(t.textContent||\"\")}function Ur(t,e){return 16&e?\"code\":e&mt?\"mark\":32&e?\"sub\":64&e?\"sup\":null}function Vr(t,e){return 1&e?\"strong\":2&e?\"em\":\"span\"}function jr(t,e,n,r,i){const s=r.classList;let o=je(i,\"base\");void 0!==o&&s.add(...o),o=je(i,\"underlineStrikethrough\");let l=!1;const c=e&gt&&e&ht;void 0!==o&&(n&gt&&n&ht?(l=!0,c||s.add(...o)):c&&s.remove(...o));for(const t in Ot){const r=Ot[t];if(o=je(i,t),void 0!==o)if(n&r){if(l&&(\"underline\"===t||\"strikethrough\"===t)){e&r&&s.remove(...o);continue}e&r&&(!c||\"underline\"!==t)&&\"strikethrough\"!==t||s.add(...o)}else e&r&&s.remove(...o)}}function Hr(t,e,n){const r=e.firstChild,i=n.isComposing(),s=t+(i?wt:\"\");if(null==r)e.textContent=s;else{const t=r.nodeValue;if(t!==s)if(i||Q){const[e,n,i]=function(t,e){const n=t.length,r=e.length;let i=0,s=0;for(;i<n&&i<r&&t[i]===e[i];)i++;for(;s+i<n&&s+i<r&&t[n-s-1]===e[r-s-1];)s++;return[i,n-i-s,e.slice(i,r-s)]}(t,s);0!==n&&r.deleteData(e,n),r.insertData(e,i)}else r.nodeValue=s}}function qr(t,e,n,r,i,s){Hr(i,t,e);const o=s.theme.text;void 0!==o&&jr(0,0,r,t,o)}function Qr(t,e){const n=document.createElement(e);return n.appendChild(t),n}class Xr extends zr{static getType(){return\"text\"}static clone(t){return new Xr(t.__text,t.__key)}afterCloneFrom(t){super.afterCloneFrom(t),this.__format=t.__format,this.__style=t.__style,this.__mode=t.__mode,this.__detail=t.__detail}constructor(t,e){super(e),this.__text=t,this.__format=0,this.__style=\"\",this.__mode=0,this.__detail=0}getFormat(){return this.getLatest().__format}getDetail(){return this.getLatest().__detail}getMode(){const t=this.getLatest();return zt[t.__mode]}getStyle(){return this.getLatest().__style}isToken(){return 1===this.getLatest().__mode}isComposing(){return this.__key===ve()}isSegmented(){return 2===this.getLatest().__mode}isDirectionless(){return!!(1&this.getLatest().__detail)}isUnmergeable(){return!!(2&this.getLatest().__detail)}hasFormat(t){const e=Ot[t];return!!(this.getFormat()&e)}isSimpleText(){return\"text\"===this.__type&&0===this.__mode}getTextContent(){return this.getLatest().__text}getFormatFlags(t,e){return ge(this.getLatest().__format,t,e)}canHaveFormat(){return!0}createDOM(t,e){const n=this.__format,r=Ur(0,n),i=Vr(0,n),s=null===r?i:r,o=document.createElement(s);let l=o;this.hasFormat(\"code\")&&o.setAttribute(\"spellcheck\",\"false\"),null!==r&&(l=document.createElement(i),o.appendChild(l));qr(l,this,0,n,this.__text,t);const c=this.__style;return\"\"!==c&&(o.style.cssText=c),o}updateDOM(t,e,n){const r=this.__text,i=t.__format,s=this.__format,o=Ur(0,i),l=Ur(0,s),c=Vr(0,i),a=Vr(0,s);if((null===o?c:o)!==(null===l?a:l))return!0;if(o===l&&c!==a){const t=e.firstChild;null==t&&Rt(48);const i=document.createElement(a);return qr(i,this,0,s,r,n),e.replaceChild(i,t),!1}let u=e;null!==l&&null!==o&&(u=e.firstChild,null==u&&Rt(49)),Hr(r,u,this);const f=n.theme.text;void 0!==f&&i!==s&&jr(0,i,s,u,f);const d=t.__style,h=this.__style;return d!==h&&(e.style.cssText=h),!1}static importDOM(){return{\"#text\":()=>({conversion:ei,priority:0}),b:()=>({conversion:Zr,priority:0}),code:()=>({conversion:ii,priority:0}),em:()=>({conversion:ii,priority:0}),i:()=>({conversion:ii,priority:0}),s:()=>({conversion:ii,priority:0}),span:()=>({conversion:Yr,priority:0}),strong:()=>({conversion:ii,priority:0}),sub:()=>({conversion:ii,priority:0}),sup:()=>({conversion:ii,priority:0}),u:()=>({conversion:ii,priority:0})}}static importJSON(t){const e=si(t.text);return e.setFormat(t.format),e.setDetail(t.detail),e.setMode(t.mode),e.setStyle(t.style),e}exportDOM(t){let{element:e}=super.exportDOM(t);return null!==e&&vn(e)||Rt(132),e.style.whiteSpace=\"pre-wrap\",this.hasFormat(\"bold\")&&(e=Qr(e,\"b\")),this.hasFormat(\"italic\")&&(e=Qr(e,\"i\")),this.hasFormat(\"strikethrough\")&&(e=Qr(e,\"s\")),this.hasFormat(\"underline\")&&(e=Qr(e,\"u\")),{element:e}}exportJSON(){return{detail:this.getDetail(),format:this.getFormat(),mode:this.getMode(),style:this.getStyle(),text:this.getTextContent(),type:\"text\",version:1}}selectionTransform(t,e){}setFormat(t){const e=this.getWritable();return e.__format=\"string\"==typeof t?Ot[t]:t,e}setDetail(t){const e=this.getWritable();return e.__detail=\"string\"==typeof t?It[t]:t,e}setStyle(t){const e=this.getWritable();return e.__style=t,e}toggleFormat(t){const e=ge(this.getFormat(),t,null);return this.setFormat(e)}toggleDirectionless(){const t=this.getWritable();return t.__detail^=1,t}toggleUnmergeable(){const t=this.getWritable();return t.__detail^=2,t}setMode(t){const e=Wt[t];if(this.__mode===e)return this;const n=this.getWritable();return n.__mode=e,n}setTextContent(t){if(this.__text===t)return this;const e=this.getWritable();return e.__text=t,e}select(t,e){Yi();let n=t,r=e;const i=Oi(),s=this.getTextContent(),o=this.__key;if(\"string\"==typeof s){const t=s.length;void 0===n&&(n=t),void 0===r&&(r=t)}else n=0,r=0;if(!yi(i))return Ei(o,n,o,r,\"text\",\"text\");{const t=ve();t!==i.anchor.key&&t!==i.focus.key||xe(o),i.setTextNodeRange(this,n,this,r)}return i}selectStart(){return this.select(0,0)}selectEnd(){const t=this.getTextContentSize();return this.select(t,t)}spliceText(t,e,n,r){const i=this.getWritable(),s=i.__text,o=n.length;let l=t;l<0&&(l=o+l,l<0&&(l=0));const c=Oi();if(r&&yi(c)){const e=t+o;c.setTextNodeRange(i,e,i,e)}const a=s.slice(0,l)+n+s.slice(l+e);return i.__text=a,i}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}splitText(...t){Yi();const e=this.getLatest(),n=e.getTextContent(),r=e.__key,i=ve(),s=new Set(t),o=[],l=n.length;let c=\"\";for(let t=0;t<l;t++)\"\"!==c&&s.has(t)&&(o.push(c),c=\"\"),c+=n[t];\"\"!==c&&o.push(c);const a=o.length;if(0===a)return[];if(o[0]===n)return[e];const u=o[0],f=e.getParent();let d;const h=e.getFormat(),g=e.getStyle(),_=e.__detail;let p=!1;e.isSegmented()?(d=si(u),d.__format=h,d.__style=g,d.__detail=_,p=!0):(d=e.getWritable(),d.__text=u);const y=Oi(),m=[d];let x=u.length;for(let t=1;t<a;t++){const e=o[t],n=e.length,s=si(e).getWritable();s.__format=h,s.__style=g,s.__detail=_;const l=s.__key,c=x+n;if(yi(y)){const t=y.anchor,e=y.focus;t.key===r&&\"text\"===t.type&&t.offset>x&&t.offset<=c&&(t.key=l,t.offset-=x,y.dirty=!0),e.key===r&&\"text\"===e.type&&e.offset>x&&e.offset<=c&&(e.key=l,e.offset-=x,y.dirty=!0)}i===r&&xe(l),x=c,m.push(s)}if(null!==f){!function(t){const e=t.getPreviousSibling(),n=t.getNextSibling();null!==e&&me(e),null!==n&&me(n)}(this);const t=f.getWritable(),e=this.getIndexWithinParent();p?(t.splice(e,0,m),this.remove()):t.splice(e,1,m),yi(y)&&Ai(y,f,e,a-1)}return m}mergeWithSibling(t){const e=t===this.getPreviousSibling();e||t===this.getNextSibling()||Rt(50);const n=this.__key,r=t.__key,i=this.__text,s=i.length;ve()===r&&xe(n);const o=Oi();if(yi(o)){const i=o.anchor,l=o.focus;null!==i&&i.key===r&&(zi(i,e,n,t,s),o.dirty=!0),null!==l&&l.key===r&&(zi(l,e,n,t,s),o.dirty=!0)}const l=t.__text,c=e?l+i:i+l;this.setTextContent(c);const a=this.getWritable();return t.remove(),a}isTextEntity(){return!1}}function Yr(t){return{forChild:li(t.style),node:null}}function Zr(t){const e=t,n=\"normal\"===e.style.fontWeight;return{forChild:li(e.style,n?void 0:\"bold\"),node:null}}const Gr=new WeakMap;function ti(t){return\"PRE\"===t.nodeName||t.nodeType===rt&&void 0!==t.style&&void 0!==t.style.whiteSpace&&t.style.whiteSpace.startsWith(\"pre\")}function ei(t){const e=t;null===t.parentElement&&Rt(129);let n=e.textContent||\"\";if(null!==function(t){let e,n=t.parentNode;const r=[t];for(;null!==n&&void 0===(e=Gr.get(n))&&!ti(n);)r.push(n),n=n.parentNode;const i=void 0===e?n:e;for(let t=0;t<r.length;t++)Gr.set(r[t],i);return i}(e)){const t=n.split(/(\\r?\\n|\\t)/),e=[],r=t.length;for(let n=0;n<r;n++){const r=t[n];\"\\n\"===r||\"\\r\\n\"===r?e.push(Kr()):\"\\t\"===r?e.push(ai()):\"\"!==r&&e.push(si(r))}return{node:e}}if(n=n.replace(/\\r/g,\"\").replace(/[ \\t\\n]+/g,\" \"),\"\"===n)return{node:null};if(\" \"===n[0]){let t=e,r=!0;for(;null!==t&&null!==(t=ni(t,!1));){const e=t.textContent||\"\";if(e.length>0){/[ \\t\\n]$/.test(e)&&(n=n.slice(1)),r=!1;break}}r&&(n=n.slice(1))}if(\" \"===n[n.length-1]){let t=e,r=!0;for(;null!==t&&null!==(t=ni(t,!0));){if((t.textContent||\"\").replace(/^( |\\t|\\r?\\n)+/,\"\").length>0){r=!1;break}}r&&(n=n.slice(0,n.length-1))}return\"\"===n?{node:null}:{node:si(n)}}function ni(t,e){let n=t;for(;;){let t;for(;null===(t=e?n.nextSibling:n.previousSibling);){const t=n.parentElement;if(null===t)return null;n=t}if(n=t,n.nodeType===rt){const t=n.style.display;if(\"\"===t&&!Sn(n)||\"\"!==t&&!t.startsWith(\"inline\"))return null}let r=n;for(;null!==(r=e?n.firstChild:n.lastChild);)n=r;if(n.nodeType===it)return n;if(\"BR\"===n.nodeName)return null}}const ri={code:\"code\",em:\"italic\",i:\"italic\",s:\"strikethrough\",strong:\"bold\",sub:\"subscript\",sup:\"superscript\",u:\"underline\"};function ii(t){const e=ri[t.nodeName.toLowerCase()];return void 0===e?{node:null}:{forChild:li(t.style,e),node:null}}function si(t=\"\"){return fn(new Xr(t))}function oi(t){return t instanceof Xr}function li(t,e){const n=t.fontWeight,r=t.textDecoration.split(\" \"),i=\"700\"===n||\"bold\"===n,s=r.includes(\"line-through\"),o=\"italic\"===t.fontStyle,l=r.includes(\"underline\"),c=t.verticalAlign;return t=>oi(t)?(i&&!t.hasFormat(\"bold\")&&t.toggleFormat(\"bold\"),s&&!t.hasFormat(\"strikethrough\")&&t.toggleFormat(\"strikethrough\"),o&&!t.hasFormat(\"italic\")&&t.toggleFormat(\"italic\"),l&&!t.hasFormat(\"underline\")&&t.toggleFormat(\"underline\"),\"sub\"!==c||t.hasFormat(\"subscript\")||t.toggleFormat(\"subscript\"),\"super\"!==c||t.hasFormat(\"superscript\")||t.toggleFormat(\"superscript\"),e&&!t.hasFormat(e)&&t.toggleFormat(e),t):t}class ci extends Xr{static getType(){return\"tab\"}static clone(t){return new ci(t.__key)}afterCloneFrom(t){super.afterCloneFrom(t),this.__text=t.__text}constructor(t){super(\"\\t\",t),this.__detail=2}static importDOM(){return null}static importJSON(t){const e=ai();return e.setFormat(t.format),e.setStyle(t.style),e}exportJSON(){return{...super.exportJSON(),type:\"tab\",version:1}}setTextContent(t){Rt(126)}setDetail(t){Rt(127)}setMode(t){Rt(128)}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}}function ai(){return fn(new ci)}function ui(t){return t instanceof ci}class fi{constructor(t,e,n){this._selection=null,this.key=t,this.offset=e,this.type=n}is(t){return this.key===t.key&&this.offset===t.offset&&this.type===t.type}isBefore(t){let e=this.getNode(),n=t.getNode();const r=this.offset,i=t.offset;if(_s(e)){const t=e.getDescendantByIndex(r);e=null!=t?t:e}if(_s(n)){const t=n.getDescendantByIndex(i);n=null!=t?t:n}return e===n?r<i:e.isBefore(n)}getNode(){const t=Se(this.key);return null===t&&Rt(20),t}set(t,e,n){const r=this._selection,i=this.key;this.key=t,this.offset=e,this.type=n,Xi()||(ve()===i&&xe(t),null!==r&&(r.setCachedNodes(null),r.dirty=!0))}}function di(t,e,n){return new fi(t,e,n)}function hi(t,e){let n=e.__key,r=t.offset,i=\"element\";if(oi(e)){i=\"text\";const t=e.getTextContentSize();r>t&&(r=t)}else if(!_s(e)){const t=e.getNextSibling();if(oi(t))n=t.__key,r=0,i=\"text\";else{const t=e.getParent();t&&(n=t.__key,r=e.getIndexWithinParent()+1)}}t.set(n,r,i)}function gi(t,e){if(_s(e)){const n=e.getLastDescendant();_s(n)||oi(n)?hi(t,n):hi(t,e)}else hi(t,e)}function _i(t,e,n,r){t.key=e,t.offset=n,t.type=r}class pi{constructor(t){this._cachedNodes=null,this._nodes=t,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(t){this._cachedNodes=t}is(t){if(!xi(t))return!1;const e=this._nodes,n=t._nodes;return e.size===n.size&&Array.from(e).every((t=>n.has(t)))}isCollapsed(){return!1}isBackward(){return!1}getStartEndPoints(){return null}add(t){this.dirty=!0,this._nodes.add(t),this._cachedNodes=null}delete(t){this.dirty=!0,this._nodes.delete(t),this._cachedNodes=null}clear(){this.dirty=!0,this._nodes.clear(),this._cachedNodes=null}has(t){return this._nodes.has(t)}clone(){return new pi(new Set(this._nodes))}extract(){return this.getNodes()}insertRawText(t){}insertText(){}insertNodes(t){const e=this.getNodes(),n=e.length,r=e[n-1];let i;if(oi(r))i=r.select();else{const t=r.getIndexWithinParent()+1;i=r.getParentOrThrow().select(t,t)}i.insertNodes(t);for(let t=0;t<n;t++)e[t].remove()}getNodes(){const t=this._cachedNodes;if(null!==t)return t;const e=this._nodes,n=[];for(const t of e){const e=Se(t);null!==e&&n.push(e)}return Xi()||(this._cachedNodes=n),n}getTextContent(){const t=this.getNodes();let e=\"\";for(let n=0;n<t.length;n++)e+=t[n].getTextContent();return e}}function yi(t){return t instanceof mi}class mi{constructor(t,e,n,r){this.anchor=t,this.focus=e,t._selection=this,e._selection=this,this._cachedNodes=null,this.format=n,this.style=r,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(t){this._cachedNodes=t}is(t){return!!yi(t)&&(this.anchor.is(t.anchor)&&this.focus.is(t.focus)&&this.format===t.format&&this.style===t.style)}isCollapsed(){return this.anchor.is(this.focus)}getNodes(){const t=this._cachedNodes;if(null!==t)return t;const e=this.anchor,n=this.focus,r=e.isBefore(n),i=r?e:n,s=r?n:e;let o=i.getNode(),l=s.getNode();const c=i.offset,a=s.offset;if(_s(o)){const t=o.getDescendantByIndex(c);o=null!=t?t:o}if(_s(l)){let t=l.getDescendantByIndex(a);null!==t&&t!==o&&l.getChildAtIndex(a)===t&&(t=t.getPreviousSibling()),l=null!=t?t:l}let u;return u=o.is(l)?_s(o)&&o.getChildrenSize()>0?[]:[o]:o.getNodesBetween(l),Xi()||(this._cachedNodes=u),u}setTextNodeRange(t,e,n,r){_i(this.anchor,t.__key,e,\"text\"),_i(this.focus,n.__key,r,\"text\"),this._cachedNodes=null,this.dirty=!0}getTextContent(){const t=this.getNodes();if(0===t.length)return\"\";const e=t[0],n=t[t.length-1],r=this.anchor,i=this.focus,s=r.isBefore(i),[o,l]=Si(this);let c=\"\",a=!0;for(let u=0;u<t.length;u++){const f=t[u];if(_s(f)&&!f.isInline())a||(c+=\"\\n\"),a=!f.isEmpty();else if(a=!1,oi(f)){let t=f.getTextContent();f===e?f===n?\"element\"===r.type&&\"element\"===i.type&&i.offset!==r.offset||(t=o<l?t.slice(o,l):t.slice(l,o)):t=s?t.slice(o):t.slice(l):f===n&&(t=s?t.slice(0,l):t.slice(0,o)),c+=t}else!ms(f)&&!$r(f)||f===n&&this.isCollapsed()||(c+=f.getTextContent())}return c}applyDOMRange(t){const e=ts(),n=e.getEditorState()._selection,r=wi(t.startContainer,t.startOffset,t.endContainer,t.endOffset,e,n);if(null===r)return;const[i,s]=r;_i(this.anchor,i.key,i.offset,i.type),_i(this.focus,s.key,s.offset,s.type),this._cachedNodes=null}clone(){const t=this.anchor,e=this.focus;return new mi(di(t.key,t.offset,t.type),di(e.key,e.offset,e.type),this.format,this.style)}toggleFormat(t){this.format=ge(this.format,t,null),this.dirty=!0}setStyle(t){this.style=t,this.dirty=!0}hasFormat(t){const e=Ot[t];return!!(this.format&e)}insertRawText(t){const e=t.split(/(\\r?\\n|\\t)/),n=[],r=e.length;for(let t=0;t<r;t++){const r=e[t];\"\\n\"===r||\"\\r\\n\"===r?n.push(Kr()):\"\\t\"===r?n.push(ai()):n.push(si(r))}this.insertNodes(n)}insertText(t){const e=this.anchor,n=this.focus,r=this.format,i=this.style;let s=e,o=n;!this.isCollapsed()&&n.isBefore(e)&&(s=n,o=e),\"element\"===s.type&&function(t,e,n,r){const i=t.getNode(),s=i.getChildAtIndex(t.offset),o=si(),l=vs(i)?Ns().append(o):o;o.setFormat(n),o.setStyle(r),null===s?i.append(l):s.insertBefore(l),t.is(e)&&e.set(o.__key,0,\"text\"),t.set(o.__key,0,\"text\")}(s,o,r,i);const l=s.offset;let c=o.offset;const a=this.getNodes(),u=a.length;let f=a[0];oi(f)||Rt(26);const d=f.getTextContent().length,h=f.getParentOrThrow();let g=a[u-1];if(1===u&&\"element\"===o.type&&(c=d,o.set(s.key,c,\"text\")),this.isCollapsed()&&l===d&&(f.isSegmented()||f.isToken()||!f.canInsertTextAfter()||!h.canInsertTextAfter()&&null===f.getNextSibling())){let e=f.getNextSibling();if(oi(e)&&e.canInsertTextBefore()&&!fe(e)||(e=si(),e.setFormat(r),e.setStyle(i),h.canInsertTextAfter()?f.insertAfter(e):h.insertAfter(e)),e.select(0,0),f=e,\"\"!==t)return void this.insertText(t)}else if(this.isCollapsed()&&0===l&&(f.isSegmented()||f.isToken()||!f.canInsertTextBefore()||!h.canInsertTextBefore()&&null===f.getPreviousSibling())){let e=f.getPreviousSibling();if(oi(e)&&!fe(e)||(e=si(),e.setFormat(r),h.canInsertTextBefore()?f.insertBefore(e):h.insertBefore(e)),e.select(),f=e,\"\"!==t)return void this.insertText(t)}else if(f.isSegmented()&&l!==d){const t=si(f.getTextContent());t.setFormat(r),f.replace(t),f=t}else if(!this.isCollapsed()&&\"\"!==t){const e=g.getParent();if(!h.canInsertTextBefore()||!h.canInsertTextAfter()||_s(e)&&(!e.canInsertTextBefore()||!e.canInsertTextAfter()))return this.insertText(\"\"),bi(this.anchor,this.focus,null),void this.insertText(t)}if(1===u){if(f.isToken()){const e=si(t);return e.select(),void f.replace(e)}const e=f.getFormat(),n=f.getStyle();if(l!==c||e===r&&n===i){if(ui(f)){const e=si(t);return e.setFormat(r),e.setStyle(i),e.select(),void f.replace(e)}}else{if(\"\"!==f.getTextContent()){const e=si(t);if(e.setFormat(r),e.setStyle(i),e.select(),0===l)f.insertBefore(e,!1);else{const[t]=f.splitText(l);t.insertAfter(e,!1)}return void(e.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=t.length))}f.setFormat(r),f.setStyle(i)}const s=c-l;f=f.spliceText(l,s,t,!0),\"\"===f.getTextContent()?f.remove():\"text\"===this.anchor.type&&(f.isComposing()?this.anchor.offset-=t.length:(this.format=e,this.style=n))}else{const e=new Set([...f.getParentKeys(),...g.getParentKeys()]),n=_s(f)?f:f.getParentOrThrow();let r=_s(g)?g:g.getParentOrThrow(),i=g;if(!n.is(r)&&r.isInline())do{i=r,r=r.getParentOrThrow()}while(r.isInline());if(\"text\"===o.type&&(0!==c||\"\"===g.getTextContent())||\"element\"===o.type&&g.getIndexWithinParent()<c)if(oi(g)&&!g.isToken()&&c!==g.getTextContentSize()){if(g.isSegmented()){const t=si(g.getTextContent());g.replace(t),g=t}vs(o.getNode())||\"text\"!==o.type||(g=g.spliceText(0,c,\"\")),e.add(g.__key)}else{const t=g.getParentOrThrow();t.canBeEmpty()||1!==t.getChildrenSize()?g.remove():t.remove()}else e.add(g.__key);const s=r.getChildren(),h=new Set(a),_=n.is(r),p=n.isInline()&&null===f.getNextSibling()?n:f;for(let t=s.length-1;t>=0;t--){const e=s[t];if(e.is(f)||_s(e)&&e.isParentOf(f))break;e.isAttached()&&(!h.has(e)||e.is(i)?_||p.insertAfter(e,!1):e.remove())}if(!_){let t=r,n=null;for(;null!==t;){const r=t.getChildren(),i=r.length;(0===i||r[i-1].is(n))&&(e.delete(t.__key),n=t),t=t.getParent()}}if(f.isToken())if(l===d)f.select();else{const e=si(t);e.select(),f.replace(e)}else f=f.spliceText(l,d-l,t,!0),\"\"===f.getTextContent()?f.remove():f.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=t.length);for(let t=1;t<u;t++){const n=a[t],r=n.__key;e.has(r)||n.remove()}}}removeText(){this.insertText(\"\")}formatText(t){if(this.isCollapsed())return this.toggleFormat(t),void xe(null);const e=this.getNodes(),n=[];for(const t of e)oi(t)&&n.push(t);const r=n.length;if(0===r)return this.toggleFormat(t),void xe(null);const i=this.anchor,s=this.focus,o=this.isBackward(),l=o?s:i,c=o?i:s;let a=0,u=n[0],f=\"element\"===l.type?0:l.offset;if(\"text\"===l.type&&f===u.getTextContentSize()&&(a=1,u=n[1],f=0),null==u)return;const d=u.getFormatFlags(t,null),h=r-1;let g=n[h];const _=\"text\"===c.type?c.offset:g.getTextContentSize();if(u.is(g)){if(f===_)return;if(fe(u)||0===f&&_===u.getTextContentSize())u.setFormat(d);else{const t=u.splitText(f,_),e=0===f?t[0]:t[1];e.setFormat(d),\"text\"===l.type&&l.set(e.__key,0,\"text\"),\"text\"===c.type&&c.set(e.__key,_-f,\"text\")}return void(this.format=d)}0===f||fe(u)||([,u]=u.splitText(f),f=0),u.setFormat(d);const p=g.getFormatFlags(t,d);_>0&&(_===g.getTextContentSize()||fe(g)||([g]=g.splitText(_)),g.setFormat(p));for(let e=a+1;e<h;e++){const r=n[e],i=r.getFormatFlags(t,p);r.setFormat(i)}\"text\"===l.type&&l.set(u.__key,f,\"text\"),\"text\"===c.type&&c.set(g.__key,_,\"text\"),this.format=d|p}insertNodes(t){if(0===t.length)return;if(\"root\"===this.anchor.key){this.insertParagraph();const e=Oi();return yi(e)||Rt(134),e.insertNodes(t)}const e=kn((this.isBackward()?this.focus:this.anchor).getNode(),Cn),n=t[t.length-1];if(\"__language\"in e&&_s(e)){if(\"__language\"in t[0])this.insertText(t[0].getTextContent());else{const r=$i(this);e.splice(r,0,t),n.selectEnd()}return}if(!t.some((t=>(_s(t)||ms(t))&&!t.isInline()))){_s(e)||Rt(135);const r=$i(this);return e.splice(r,0,t),void n.selectEnd()}const r=function(t){const e=Ns();let n=null;for(let r=0;r<t.length;r++){const i=t[r],s=$r(i);if(s||ms(i)&&i.isInline()||_s(i)&&i.isInline()||oi(i)||i.isParentRequired()){if(null===n&&(n=i.createParentElementNode(),e.append(n),s))continue;null!==n&&n.append(i)}else e.append(i),n=null}return e}(t),i=r.getLastDescendant(),s=r.getChildren(),o=!_s(e)||!e.isEmpty()?this.insertParagraph():null,l=s[s.length-1];let c=s[0];var a;_s(a=c)&&Cn(a)&&!a.isEmpty()&&_s(e)&&(!e.isEmpty()||e.canMergeWhenEmpty())&&(_s(e)||Rt(135),e.append(...c.getChildren()),c=s[1]),c&&function(t,e,n){const r=e.getParentOrThrow().getLastChild();let i=e;const s=[e];for(;i!==r;)i.getNextSibling()||Rt(140),i=i.getNextSibling(),s.push(i);let o=t;for(const t of s)o=o.insertAfter(t)}(e,c);const u=kn(i,Cn);o&&_s(u)&&(o.canMergeWhenEmpty()||Cn(l))&&(u.append(...o.getChildren()),o.remove()),_s(e)&&e.isEmpty()&&e.remove(),i.selectEnd();const f=_s(e)?e.getLastChild():null;$r(f)&&u!==e&&f.remove()}insertParagraph(){if(\"root\"===this.anchor.key){const t=Ns();return we().splice(this.anchor.offset,0,[t]),t.select(),t}const t=$i(this),e=kn(this.anchor.getNode(),Cn);_s(e)||Rt(136);const n=e.getChildAtIndex(t),r=n?[n,...n.getNextSiblings()]:[],i=e.insertNewAfter(this,!1);return i?(i.append(...r),i.selectStart(),i):null}insertLineBreak(t){const e=Kr();if(this.insertNodes([e]),t){const t=e.getParentOrThrow(),n=e.getIndexWithinParent();t.select(n,n)}}extract(){const t=this.getNodes(),e=t.length,n=e-1,r=this.anchor,i=this.focus;let s=t[0],o=t[n];const[l,c]=Si(this);if(0===e)return[];if(1===e){if(oi(s)&&!this.isCollapsed()){const t=l>c?c:l,e=l>c?l:c,n=s.splitText(t,e),r=0===t?n[0]:n[1];return null!=r?[r]:[]}return[s]}const a=r.isBefore(i);if(oi(s)){const e=a?l:c;e===s.getTextContentSize()?t.shift():0!==e&&([,s]=s.splitText(e),t[0]=s)}if(oi(o)){const e=o.getTextContent().length,r=a?c:l;0===r?t.pop():r!==e&&([o]=o.splitText(r),t[n]=o)}return t}modify(t,e,n){const r=this.focus,i=this.anchor,s=\"move\"===t,o=Xe(r,e);if(ms(o)&&!o.isIsolated()){if(s&&o.isKeyboardSelectable()){const t=Fi();return t.add(o.__key),void Ee(t)}const t=e?o.getPreviousSibling():o.getNextSibling();if(oi(t)){const n=t.__key,o=e?t.getTextContent().length:0;return r.set(n,o,\"text\"),void(s&&i.set(n,o,\"text\"))}{const n=o.getParentOrThrow();let l,c;return _s(t)?(c=t.__key,l=e?t.getChildrenSize():0):(l=o.getIndexWithinParent(),c=n.__key,e||l++),r.set(c,l,\"element\"),void(s&&i.set(c,l,\"element\"))}}const l=ts(),c=yn(l._window);if(!c)return;const a=l._blockCursorElement,u=l._rootElement;if(null===u||null===a||!_s(o)||o.isInline()||o.canBeEmpty()||_n(a,l,u),function(t,e,n,r){t.modify(e,n,r)}(c,t,e?\"backward\":\"forward\",n),c.rangeCount>0){const t=c.getRangeAt(0),n=this.anchor.getNode(),r=vs(n)?n:cn(n);if(this.applyDOMRange(t),this.dirty=!0,!s){const n=this.getNodes(),i=[];let s=!1;for(let t=0;t<n.length;t++){const e=n[t];sn(e,r)?i.push(e):s=!0}if(s&&i.length>0)if(e){const t=i[0];_s(t)?t.selectStart():t.getParentOrThrow().selectStart()}else{const t=i[i.length-1];_s(t)?t.selectEnd():t.getParentOrThrow().selectEnd()}c.anchorNode===t.startContainer&&c.anchorOffset===t.startOffset||function(t){const e=t.focus,n=t.anchor,r=n.key,i=n.offset,s=n.type;_i(n,e.key,e.offset,e.type),_i(e,r,i,s),t._cachedNodes=null}(this)}}}forwardDeletion(t,e,n){if(!n&&(\"element\"===t.type&&_s(e)&&t.offset===e.getChildrenSize()||\"text\"===t.type&&t.offset===e.getTextContentSize())){const t=e.getParent(),n=e.getNextSibling()||(null===t?null:t.getNextSibling());if(_s(n)&&n.isShadowRoot())return!0}return!1}deleteCharacter(t){const n=this.isCollapsed();if(this.isCollapsed()){const n=this.anchor;let r=n.getNode();if(this.forwardDeletion(n,r,t))return;const i=this.focus,s=Xe(i,t);if(ms(s)&&!s.isIsolated()){if(s.isKeyboardSelectable()&&_s(r)&&0===r.getChildrenSize()){r.remove();const t=Fi();t.add(s.__key),Ee(t)}else{s.remove();ts().dispatchCommand(e,void 0)}return}if(!t&&_s(s)&&_s(r)&&r.isEmpty())return r.remove(),void s.selectStart();if(this.modify(\"extend\",t,\"character\"),this.isCollapsed()){if(t&&0===n.offset){if((\"element\"===n.type?n.getNode():n.getNode().getParentOrThrow()).collapseAtStart(this))return}}else{const e=\"text\"===i.type?i.getNode():null;if(r=\"text\"===n.type?n.getNode():null,null!==e&&e.isSegmented()){const n=i.offset,s=e.getTextContentSize();if(e.is(r)||t&&n!==s||!t&&0!==n)return void Ti(e,t,n)}else if(null!==r&&r.isSegmented()){const i=n.offset,s=r.getTextContentSize();if(r.is(e)||t&&0!==i||!t&&i!==s)return void Ti(r,t,i)}!function(t,e){const n=t.anchor,r=t.focus,i=n.getNode(),s=r.getNode();if(i===s&&\"text\"===n.type&&\"text\"===r.type){const t=n.offset,s=r.offset,o=t<s,l=o?t:s,c=o?s:t,a=c-1;if(l!==a){De(i.getTextContent().slice(l,c))||(e?r.offset=a:n.offset=a)}}}(this,t)}}if(this.removeText(),t&&!n&&this.isCollapsed()&&\"element\"===this.anchor.type&&0===this.anchor.offset){const t=this.anchor.getNode();t.isEmpty()&&vs(t.getParent())&&0===t.getIndexWithinParent()&&t.collapseAtStart(this)}}deleteLine(t){if(this.isCollapsed()){const e=\"element\"===this.anchor.type;e&&this.insertText(\" \"),this.modify(\"extend\",t,\"lineboundary\");if(0===(t?this.focus:this.anchor).offset&&this.modify(\"extend\",t,\"character\"),e){const e=t?this.anchor:this.focus;e.set(e.key,e.offset+1,e.type)}}this.removeText()}deleteWord(t){if(this.isCollapsed()){const e=this.anchor,n=e.getNode();if(this.forwardDeletion(e,n,t))return;this.modify(\"extend\",t,\"word\")}this.removeText()}isBackward(){return this.focus.isBefore(this.anchor)}getStartEndPoints(){return[this.anchor,this.focus]}}function xi(t){return t instanceof pi}function vi(t){const e=t.offset;if(\"text\"===t.type)return e;const n=t.getNode();return e===n.getChildrenSize()?n.getTextContent().length:0}function Si(t){const e=t.getStartEndPoints();if(null===e)return[0,0];const[n,r]=e;return\"element\"===n.type&&\"element\"===r.type&&n.key===r.key&&n.offset===r.offset?[0,0]:[vi(n),vi(r)]}function Ti(t,e,n){const r=t,i=r.getTextContent().split(/(?=\\s)/g),s=i.length;let o=0,l=0;for(let t=0;t<s;t++){const r=t===s-1;if(l=o,o+=i[t].length,e&&o===n||o>n||r){i.splice(t,1),r&&(l=void 0);break}}const c=i.join(\"\").trim();\"\"===c?r.remove():(r.setTextContent(c),r.select(l,l))}function Ci(t,e,n,r){let i,s=e;if(t.nodeType===rt){let o=!1;const l=t.childNodes,c=l.length,a=r._blockCursorElement;s===c&&(o=!0,s=c-1);let u=l[s],f=!1;if(u===a)u=l[s+1],f=!0;else if(null!==a){const n=a.parentNode;if(t===n){e>Array.prototype.indexOf.call(n.children,a)&&s--}}if(i=Pe(u),oi(i))s=Fe(i,o);else{let r=Pe(t);if(null===r)return null;if(_s(r)){s=Math.min(r.getChildrenSize(),s);let t=r.getChildAtIndex(s);if(_s(t)&&function(t,e,n){const r=t.getParent();return null===n||null===r||!r.canBeEmpty()||r!==n.getNode()}(t,0,n)){const e=o?t.getLastDescendant():t.getFirstDescendant();null===e?r=t:(t=e,r=_s(t)?t:t.getParentOrThrow()),s=0}oi(t)?(i=t,r=null,s=Fe(t,o)):t!==r&&o&&!f&&s++}else{const n=r.getIndexWithinParent();s=0===e&&ms(r)&&Pe(t)===r?n:n+1,r=r.getParentOrThrow()}if(_s(r))return di(r.__key,s,\"element\")}}else i=Pe(t);return oi(i)?di(i.__key,s,\"text\"):null}function ki(t,e,n){const r=t.offset,i=t.getNode();if(0===r){const r=i.getPreviousSibling(),s=i.getParent();if(e){if((n||!e)&&null===r&&_s(s)&&s.isInline()){const e=s.getPreviousSibling();oi(e)&&(t.key=e.__key,t.offset=e.getTextContent().length)}}else _s(r)&&!n&&r.isInline()?(t.key=r.__key,t.offset=r.getChildrenSize(),t.type=\"element\"):oi(r)&&(t.key=r.__key,t.offset=r.getTextContent().length)}else if(r===i.getTextContent().length){const r=i.getNextSibling(),s=i.getParent();if(e&&_s(r)&&r.isInline())t.key=r.__key,t.offset=0,t.type=\"element\";else if((n||e)&&null===r&&_s(s)&&s.isInline()&&!s.canInsertTextAfter()){const e=s.getNextSibling();oi(e)&&(t.key=e.__key,t.offset=0)}}}function bi(t,e,n){if(\"text\"===t.type&&\"text\"===e.type){const r=t.isBefore(e),i=t.is(e);ki(t,r,i),ki(e,!r,i),i&&(e.key=t.key,e.offset=t.offset,e.type=t.type);const s=ts();if(s.isComposing()&&s._compositionKey!==t.key&&yi(n)){const r=n.anchor,i=n.focus;_i(t,r.key,r.offset,r.type),_i(e,i.key,i.offset,i.type)}}}function wi(t,e,n,r,i,s){if(null===t||null===n||!le(i,t,n))return null;const o=Ci(t,e,yi(s)?s.anchor:null,i);if(null===o)return null;const l=Ci(n,r,yi(s)?s.focus:null,i);if(null===l)return null;if(\"element\"===o.type&&\"element\"===l.type){const e=Pe(t),r=Pe(n);if(ms(e)&&ms(r))return null}return bi(o,l,s),[o,l]}function Ni(t){return _s(t)&&!t.isInline()}function Ei(t,e,n,r,i,s){const o=Gi(),l=new mi(di(t,e,i),di(n,r,s),0,\"\");return l.dirty=!0,o._selection=l,l}function Pi(){const t=di(\"root\",0,\"element\"),e=di(\"root\",0,\"element\");return new mi(t,e,0,\"\")}function Fi(){return new pi(new Set)}function Di(t,e){return Li(null,t,e,null)}function Li(t,e,n,r){const i=n._window;if(null===i)return null;const s=r||i.event,o=s?s.type:void 0,l=\"selectionchange\"===o,c=!Jt&&(l||\"beforeinput\"===o||\"compositionstart\"===o||\"compositionend\"===o||\"click\"===o&&s&&3===s.detail||\"drop\"===o||void 0===o);let a,u,f,d;if(yi(t)&&!c)return t.clone();if(null===e)return null;if(a=e.anchorNode,u=e.focusNode,f=e.anchorOffset,d=e.focusOffset,l&&yi(t)&&!le(n,a,u))return t.clone();const h=wi(a,f,u,d,n,t);if(null===h)return null;const[g,_]=h;return new mi(g,_,yi(t)?t.format:0,yi(t)?t.style:\"\")}function Oi(){return Gi()._selection}function Ii(){return ts()._editorState._selection}function Ai(t,e,n,r=1){const i=t.anchor,s=t.focus,o=i.getNode(),l=s.getNode();if(!e.is(o)&&!e.is(l))return;const c=e.__key;if(t.isCollapsed()){const e=i.offset;if(n<=e&&r>0||n<e&&r<0){const n=Math.max(0,e+r);i.set(c,n,\"element\"),s.set(c,n,\"element\"),Mi(t)}}else{const o=t.isBackward(),l=o?s:i,a=l.getNode(),u=o?i:s,f=u.getNode();if(e.is(a)){const t=l.offset;(n<=t&&r>0||n<t&&r<0)&&l.set(c,Math.max(0,t+r),\"element\")}if(e.is(f)){const t=u.offset;(n<=t&&r>0||n<t&&r<0)&&u.set(c,Math.max(0,t+r),\"element\")}}Mi(t)}function Mi(t){const e=t.anchor,n=e.offset,r=t.focus,i=r.offset,s=e.getNode(),o=r.getNode();if(t.isCollapsed()){if(!_s(s))return;const t=s.getChildrenSize(),i=n>=t,o=i?s.getChildAtIndex(t-1):s.getChildAtIndex(n);if(oi(o)){let t=0;i&&(t=o.getTextContentSize()),e.set(o.__key,t,\"text\"),r.set(o.__key,t,\"text\")}}else{if(_s(s)){const t=s.getChildrenSize(),r=n>=t,i=r?s.getChildAtIndex(t-1):s.getChildAtIndex(n);if(oi(i)){let t=0;r&&(t=i.getTextContentSize()),e.set(i.__key,t,\"text\")}}if(_s(o)){const t=o.getChildrenSize(),e=i>=t,n=e?o.getChildAtIndex(t-1):o.getChildAtIndex(i);if(oi(n)){let t=0;e&&(t=n.getTextContentSize()),r.set(n.__key,t,\"text\")}}}}function Wi(t,e,n,r,i){let s=null,o=0,l=null;null!==r?(s=r.__key,oi(r)?(o=r.getTextContentSize(),l=\"text\"):_s(r)&&(o=r.getChildrenSize(),l=\"element\")):null!==i&&(s=i.__key,oi(i)?l=\"text\":_s(i)&&(l=\"element\")),null!==s&&null!==l?t.set(s,o,l):(o=e.getIndexWithinParent(),-1===o&&(o=n.getChildrenSize()),t.set(n.__key,o,\"element\"))}function zi(t,e,n,r,i){\"text\"===t.type?(t.key=n,e||(t.offset+=i)):t.offset>r.getIndexWithinParent()&&(t.offset-=1)}function Bi(t,e,n,r,i,s,o){const l=r.anchorNode,c=r.focusNode,a=r.anchorOffset,u=r.focusOffset,f=document.activeElement;if(i.has(\"collaboration\")&&f!==s||null!==f&&oe(f))return;if(!yi(e))return void(null!==t&&le(n,l,c)&&r.removeAllRanges());const d=e.anchor,h=e.focus,g=d.key,_=h.key,p=tn(n,g),y=tn(n,_),m=d.offset,x=h.offset,v=e.format,S=e.style,T=e.isCollapsed();let C=p,k=y,b=!1;if(\"text\"===d.type){C=he(p);const t=d.getNode();b=t.getFormat()!==v||t.getStyle()!==S}else yi(t)&&\"text\"===t.anchor.type&&(b=!0);var w,N,E,P,F;if((\"text\"===h.type&&(k=he(y)),null!==C&&null!==k)&&(T&&(null===t||b||yi(t)&&(t.format!==v||t.style!==S))&&(w=v,N=S,E=m,P=g,F=performance.now(),br=[w,N,E,P,F]),a!==m||u!==x||l!==C||c!==k||\"Range\"===r.type&&T||(null!==f&&s.contains(f)||s.focus({preventScroll:!0}),\"element\"===d.type))){try{r.setBaseAndExtent(C,m,k,x)}catch(t){}if(!i.has(\"skip-scroll-into-view\")&&e.isCollapsed()&&null!==s&&s===document.activeElement){const t=e instanceof mi&&\"element\"===e.anchor.type?C.childNodes[m]||null:r.rangeCount>0?r.getRangeAt(0):null;if(null!==t){let e;if(t instanceof Text){const n=document.createRange();n.selectNode(t),e=n.getBoundingClientRect()}else e=t.getBoundingClientRect();!function(t,e,n){const r=n.ownerDocument,i=r.defaultView;if(null===i)return;let{top:s,bottom:o}=e,l=0,c=0,a=n;for(;null!==a;){const e=a===r.body;if(e)l=0,c=on(t).innerHeight;else{const t=a.getBoundingClientRect();l=t.top,c=t.bottom}let n=0;if(s<l?n=-(l-s):o>c&&(n=o-c),0!==n)if(e)i.scrollBy(0,n);else{const t=a.scrollTop;a.scrollTop+=n;const e=a.scrollTop-t;s-=e,o-=e}if(e)break;a=en(a)}}(n,e,s)}}Sr=!0}}function Ri(t){let e=Oi()||Ii();null===e&&(e=we().selectEnd()),e.insertNodes(t)}function Ki(){const t=Oi();return null===t?\"\":t.getTextContent()}function $i(t){let e=t;t.isCollapsed()||e.removeText();const n=Oi();yi(n)&&(e=n),yi(e)||Rt(161);const r=e.anchor;let i=r.getNode(),s=r.offset;for(;!Cn(i);)[i,s]=Ji(i,s);return s}function Ji(t,e){const n=t.getParent();if(!n){const t=Ns();return we().append(t),t.select(),[we(),0]}if(oi(t)){const r=t.splitText(e);if(0===r.length)return[n,t.getIndexWithinParent()];const i=0===e?0:1;return[n,r[0].getIndexWithinParent()+i]}if(!_s(t)||0===e)return[n,t.getIndexWithinParent()];const r=t.getChildAtIndex(e);if(r){const n=new mi(di(t.__key,e,\"element\"),di(t.__key,e,\"element\"),0,\"\"),i=t.insertNewAfter(n);i&&i.append(r,...r.getNextSiblings())}return[n,t.getIndexWithinParent()+1]}let Ui=null,Vi=null,ji=!1,Hi=!1,qi=0;const Qi={characterData:!0,childList:!0,subtree:!0};function Xi(){return ji||null!==Ui&&Ui._readOnly}function Yi(){ji&&Rt(13)}function Zi(){qi>99&&Rt(14)}function Gi(){return null===Ui&&Rt(195,es()),Ui}function ts(){return null===Vi&&Rt(196,es()),Vi}function es(){let t=0;const e=new Set,n=Ms.version;if(\"undefined\"!=typeof window)for(const r of document.querySelectorAll(\"[contenteditable]\")){const i=ue(r);if(ce(i))t++;else if(i){let t=String(i.constructor.version||\"<0.17.1\");t===n&&(t+=\" (separately built, likely a bundler configuration issue)\"),e.add(t)}}let r=` Detected on the page: ${t} compatible editor(s) with version ${n}`;return e.size&&(r+=` and incompatible editors with versions ${Array.from(e).join(\", \")}`),r}function ns(){return Vi}function rs(t,e,n){const r=e.__type,i=function(t,e){const n=t._nodes.get(e);return void 0===n&&Rt(30,e),n}(t,r);let s=n.get(r);void 0===s&&(s=Array.from(i.transforms),n.set(r,s));const o=s.length;for(let t=0;t<o&&(s[t](e),e.isAttached());t++);}function is(t,e){return void 0!==t&&t.__key!==e&&t.isAttached()}function ss(t){return os(t,ts()._nodes)}function os(t,e){const n=t.type,r=e.get(n);void 0===r&&Rt(17,n);const i=r.klass;t.type!==i.getType()&&Rt(18,i.name);const s=i.importJSON(t),o=t.children;if(_s(s)&&Array.isArray(o))for(let t=0;t<o.length;t++){const n=os(o[t],e);s.append(n)}return s}function ls(t,e,n){const r=Ui,i=ji,s=Vi;Ui=e,ji=!0,Vi=t;try{return n()}finally{Ui=r,ji=i,Vi=s}}function cs(t,n){const r=t._pendingEditorState,i=t._rootElement,s=t._headless||null===i;if(null===r)return;const o=t._editorState,l=o._selection,c=r._selection,a=t._dirtyType!==st,u=Ui,f=ji,d=Vi,h=t._updating,g=t._observer;let _=null;if(t._pendingEditorState=null,t._editorState=r,!s&&a&&null!==g){Vi=t,Ui=r,ji=!1,t._updating=!0;try{const e=t._dirtyType,n=t._dirtyElements,i=t._dirtyLeaves;g.disconnect(),_=fr(o,r,t,e,n,i)}catch(e){if(e instanceof Error&&t._onError(e),Hi)throw e;return Is(t,null,i,r),Yt(t),t._dirtyType=lt,Hi=!0,cs(t,o),void(Hi=!1)}finally{g.observe(i,Qi),t._updating=h,Ui=u,ji=f,Vi=d}}r._readOnly||(r._readOnly=!0);const p=t._dirtyLeaves,y=t._dirtyElements,m=t._normalizedNodes,x=t._updateTags,v=t._deferred;a&&(t._dirtyType=st,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements=new Map,t._normalizedNodes=new Set,t._updateTags=new Set),function(t,e){const n=t._decorators;let r=t._pendingDecorators||n;const i=e._nodeMap;let s;for(s in r)i.has(s)||(r===n&&(r=ke(t)),delete r[s])}(t,r);const S=s?null:yn(t._window);if(t._editable&&null!==S&&(a||null===c||c.dirty)){Vi=t,Ui=r;try{if(null!==g&&g.disconnect(),a||null===c||c.dirty){const e=t._blockCursorElement;null!==e&&_n(e,t,i),Bi(l,c,t,S,x,i)}pn(t,i,c),null!==g&&g.observe(i,Qi)}finally{Vi=d,Ui=u}}null!==_&&function(t,e,n,r,i){const s=Array.from(t._listeners.mutation),o=s.length;for(let t=0;t<o;t++){const[o,l]=s[t],c=e.get(l);void 0!==c&&o(c,{dirtyLeaves:r,prevEditorState:i,updateTags:n})}}(t,_,x,p,o),yi(c)||null===c||null!==l&&l.is(c)||t.dispatchCommand(e,void 0);const T=t._pendingDecorators;null!==T&&(t._decorators=T,t._pendingDecorators=null,as(\"decorator\",t,!0,T)),function(t,e,n){const r=be(e),i=be(n);r!==i&&as(\"textcontent\",t,!0,i)}(t,n||o,r),as(\"update\",t,!0,{dirtyElements:y,dirtyLeaves:p,editorState:r,normalizedNodes:m,prevEditorState:n||o,tags:x}),function(t,e){if(t._deferred=[],0!==e.length){const n=t._updating;t._updating=!0;try{for(let t=0;t<e.length;t++)e[t]()}finally{t._updating=n}}}(t,v),function(t){const e=t._updates;if(0!==e.length){const n=e.shift();if(n){const[e,r]=n;ds(t,e,r)}}}(t)}function as(t,e,n,...r){const i=e._updating;e._updating=n;try{const n=Array.from(e._listeners[t]);for(let t=0;t<n.length;t++)n[t].apply(null,r)}finally{e._updating=i}}function us(t,e,n){if(!1===t._updating||Vi!==t){let r=!1;return t.update((()=>{r=us(t,e,n)})),r}const r=Le(t);for(let i=4;i>=0;i--)for(let s=0;s<r.length;s++){const o=r[s]._commands.get(e);if(void 0!==o){const e=o[i];if(void 0!==e){const r=Array.from(e),i=r.length;for(let e=0;e<i;e++)if(!0===r[e](n,t))return!0}}}return!1}function fs(t,e){const n=t._updates;let r=e||!1;for(;0!==n.length;){const e=n.shift();if(e){const[n,i]=e;let s,o;if(void 0!==i){if(s=i.onUpdate,o=i.tag,i.skipTransforms&&(r=!0),i.discrete){const e=t._pendingEditorState;null===e&&Rt(191),e._flushSync=!0}s&&t._deferred.push(s),o&&t._updateTags.add(o)}n()}}return r}function ds(t,e,n){const r=t._updateTags;let i,s,o=!1,l=!1;void 0!==n&&(i=n.onUpdate,s=n.tag,null!=s&&r.add(s),o=n.skipTransforms||!1,l=n.discrete||!1),i&&t._deferred.push(i);const c=t._editorState;let a=t._pendingEditorState,u=!1;(null===a||a._readOnly)&&(a=t._pendingEditorState=new Cs(new Map((a||c)._nodeMap)),u=!0),a._flushSync=l;const f=Ui,d=ji,h=Vi,g=t._updating;Ui=a,ji=!1,t._updating=!0,Vi=t;try{u&&(t._headless?null!==c._selection&&(a._selection=c._selection.clone()):a._selection=function(t){const e=t.getEditorState()._selection,n=yn(t._window);return yi(e)||null==e?Li(e,n,t,null):e.clone()}(t));const n=t._compositionKey;e(),o=fs(t,o),function(t,e){const n=e.getEditorState()._selection,r=t._selection;if(yi(r)){const t=r.anchor,e=r.focus;let i;if(\"text\"===t.type&&(i=t.getNode(),i.selectionTransform(n,r)),\"text\"===e.type){const t=e.getNode();i!==t&&t.selectionTransform(n,r)}}}(a,t),t._dirtyType!==st&&(o?function(t,e){const n=e._dirtyLeaves,r=t._nodeMap;for(const t of n){const e=r.get(t);oi(e)&&e.isAttached()&&e.isSimpleText()&&!e.isUnmergeable()&&te(e)}}(a,t):function(t,e){const n=e._dirtyLeaves,r=e._dirtyElements,i=t._nodeMap,s=ve(),o=new Map;let l=n,c=l.size,a=r,u=a.size;for(;c>0||u>0;){if(c>0){e._dirtyLeaves=new Set;for(const t of l){const r=i.get(t);oi(r)&&r.isAttached()&&r.isSimpleText()&&!r.isUnmergeable()&&te(r),void 0!==r&&is(r,s)&&rs(e,r,o),n.add(t)}if(l=e._dirtyLeaves,c=l.size,c>0){qi++;continue}}e._dirtyLeaves=new Set,e._dirtyElements=new Map;for(const t of a){const n=t[0],l=t[1];if(\"root\"!==n&&!l)continue;const c=i.get(n);void 0!==c&&is(c,s)&&rs(e,c,o),r.set(n,l)}l=e._dirtyLeaves,c=l.size,a=e._dirtyElements,u=a.size,qi++}e._dirtyLeaves=n,e._dirtyElements=r}(a,t),fs(t),function(t,e,n,r){const i=t._nodeMap,s=e._nodeMap,o=[];for(const[t]of r){const e=s.get(t);void 0!==e&&(e.isAttached()||(_s(e)&&Fn(e,t,i,s,o,r),i.has(t)||r.delete(t),o.push(t)))}for(const t of o)s.delete(t);for(const t of n){const e=s.get(t);void 0===e||e.isAttached()||(i.has(t)||n.delete(t),s.delete(t))}}(c,a,t._dirtyLeaves,t._dirtyElements));n!==t._compositionKey&&(a._flushSync=!0);const r=a._selection;if(yi(r)){const t=a._nodeMap,e=r.anchor.key,n=r.focus.key;void 0!==t.get(e)&&void 0!==t.get(n)||Rt(19)}else xi(r)&&0===r._nodes.size&&(a._selection=null)}catch(e){return e instanceof Error&&t._onError(e),t._pendingEditorState=c,t._dirtyType=lt,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements.clear(),void cs(t)}finally{Ui=f,ji=d,Vi=h,t._updating=g,qi=0}const _=t._dirtyType!==st||function(t,e){const n=e.getEditorState()._selection,r=t._selection;if(null!==r){if(r.dirty||!r.is(n))return!0}else if(null!==n)return!0;return!1}(a,t);_?a._flushSync?(a._flushSync=!1,cs(t)):u&&se((()=>{cs(t)})):(a._flushSync=!1,u&&(r.clear(),t._deferred=[],t._pendingEditorState=null))}function hs(t,e,n){t._updating?t._updates.push([e,n]):ds(t,e,n)}class gs extends zr{constructor(t){super(t),this.__first=null,this.__last=null,this.__size=0,this.__format=0,this.__style=\"\",this.__indent=0,this.__dir=null}afterCloneFrom(t){super.afterCloneFrom(t),this.__first=t.__first,this.__last=t.__last,this.__size=t.__size,this.__indent=t.__indent,this.__format=t.__format,this.__style=t.__style,this.__dir=t.__dir}getFormat(){return this.getLatest().__format}getFormatType(){const t=this.getFormat();return Mt[t]||\"\"}getStyle(){return this.getLatest().__style}getIndent(){return this.getLatest().__indent}getChildren(){const t=[];let e=this.getFirstChild();for(;null!==e;)t.push(e),e=e.getNextSibling();return t}getChildrenKeys(){const t=[];let e=this.getFirstChild();for(;null!==e;)t.push(e.__key),e=e.getNextSibling();return t}getChildrenSize(){return this.getLatest().__size}isEmpty(){return 0===this.getChildrenSize()}isDirty(){const t=ts()._dirtyElements;return null!==t&&t.has(this.__key)}isLastChild(){const t=this.getLatest(),e=this.getParentOrThrow().getLastChild();return null!==e&&e.is(t)}getAllTextNodes(){const t=[];let e=this.getFirstChild();for(;null!==e;){if(oi(e)&&t.push(e),_s(e)){const n=e.getAllTextNodes();t.push(...n)}e=e.getNextSibling()}return t}getFirstDescendant(){let t=this.getFirstChild();for(;_s(t);){const e=t.getFirstChild();if(null===e)break;t=e}return t}getLastDescendant(){let t=this.getLastChild();for(;_s(t);){const e=t.getLastChild();if(null===e)break;t=e}return t}getDescendantByIndex(t){const e=this.getChildren(),n=e.length;if(t>=n){const t=e[n-1];return _s(t)&&t.getLastDescendant()||t||null}const r=e[t];return _s(r)&&r.getFirstDescendant()||r||null}getFirstChild(){const t=this.getLatest().__first;return null===t?null:Se(t)}getFirstChildOrThrow(){const t=this.getFirstChild();return null===t&&Rt(45,this.__key),t}getLastChild(){const t=this.getLatest().__last;return null===t?null:Se(t)}getLastChildOrThrow(){const t=this.getLastChild();return null===t&&Rt(96,this.__key),t}getChildAtIndex(t){const e=this.getChildrenSize();let n,r;if(t<e/2){for(n=this.getFirstChild(),r=0;null!==n&&r<=t;){if(r===t)return n;n=n.getNextSibling(),r++}return null}for(n=this.getLastChild(),r=e-1;null!==n&&r>=t;){if(r===t)return n;n=n.getPreviousSibling(),r--}return null}getTextContent(){let t=\"\";const e=this.getChildren(),n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=i.getTextContent(),_s(i)&&r!==n-1&&!i.isInline()&&(t+=Nt)}return t}getTextContentSize(){let t=0;const e=this.getChildren(),n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=i.getTextContentSize(),_s(i)&&r!==n-1&&!i.isInline()&&(t+=Nt.length)}return t}getDirection(){return this.getLatest().__dir}hasFormat(t){if(\"\"!==t){const e=At[t];return!!(this.getFormat()&e)}return!1}select(t,e){Yi();const n=Oi();let r=t,i=e;const s=this.getChildrenSize();if(!this.canBeEmpty())if(0===t&&0===e){const t=this.getFirstChild();if(oi(t)||_s(t))return t.select(0,0)}else if(!(void 0!==t&&t!==s||void 0!==e&&e!==s)){const t=this.getLastChild();if(oi(t)||_s(t))return t.select()}void 0===r&&(r=s),void 0===i&&(i=s);const o=this.__key;return yi(n)?(n.anchor.set(o,r,\"element\"),n.focus.set(o,i,\"element\"),n.dirty=!0,n):Ei(o,r,o,i,\"element\",\"element\")}selectStart(){const t=this.getFirstDescendant();return t?t.selectStart():this.select()}selectEnd(){const t=this.getLastDescendant();return t?t.selectEnd():this.select()}clear(){const t=this.getWritable();return this.getChildren().forEach((t=>t.remove())),t}append(...t){return this.splice(this.getChildrenSize(),0,t)}setDirection(t){const e=this.getWritable();return e.__dir=t,e}setFormat(t){return this.getWritable().__format=\"\"!==t?At[t]:0,this}setStyle(t){return this.getWritable().__style=t||\"\",this}setIndent(t){return this.getWritable().__indent=t,this}splice(t,e,n){const r=n.length,i=this.getChildrenSize(),s=this.getWritable(),o=s.__key,l=[],c=[],a=this.getChildAtIndex(t+e);let u=null,f=i-e+r;if(0!==t)if(t===i)u=this.getLastChild();else{const e=this.getChildAtIndex(t);null!==e&&(u=e.getPreviousSibling())}if(e>0){let t=null===u?this.getFirstChild():u.getNextSibling();for(let n=0;n<e;n++){null===t&&Rt(100);const e=t.getNextSibling(),n=t.__key;ye(t.getWritable()),c.push(n),t=e}}let d=u;for(let t=0;t<r;t++){const e=n[t];null!==d&&e.is(d)&&(u=d=d.getPreviousSibling());const r=e.getWritable();r.__parent===o&&f--,ye(r);const i=e.__key;if(null===d)s.__first=i,r.__prev=null;else{const t=d.getWritable();t.__next=i,r.__prev=t.__key}e.__key===o&&Rt(76),r.__parent=o,l.push(i),d=e}if(t+e===i){if(null!==d){d.getWritable().__next=null,s.__last=d.__key}}else if(null!==a){const t=a.getWritable();if(null!==d){const e=d.getWritable();t.__prev=d.__key,e.__next=a.__key}else t.__prev=null}if(s.__size=f,c.length){const t=Oi();if(yi(t)){const e=new Set(c),n=new Set(l),{anchor:r,focus:i}=t;ps(r,e,n)&&Wi(r,r.getNode(),this,u,a),ps(i,e,n)&&Wi(i,i.getNode(),this,u,a),0!==f||this.canBeEmpty()||an(this)||this.remove()}}return s}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"element\",version:1}}insertNewAfter(t,e){return null}canIndent(){return!0}collapseAtStart(t){return!1}excludeFromCopy(t){return!1}canReplaceWith(t){return!0}canInsertAfter(t){return!0}canBeEmpty(){return!0}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}isInline(){return!1}isShadowRoot(){return!1}canMergeWith(t){return!1}extractWithChild(t,e,n){return!1}canMergeWhenEmpty(){return!1}}function _s(t){return t instanceof gs}function ps(t,e,n){let r=t.getNode();for(;r;){const t=r.__key;if(e.has(t)&&!n.has(t))return!0;r=r.getParent()}return!1}class ys extends zr{constructor(t){super(t)}decorate(t,e){Rt(47)}isIsolated(){return!1}isInline(){return!0}isKeyboardSelectable(){return!0}}function ms(t){return t instanceof ys}class xs extends gs{static getType(){return\"root\"}static clone(){return new xs}constructor(){super(\"root\"),this.__cachedText=null}getTopLevelElementOrThrow(){Rt(51)}getTextContent(){const t=this.__cachedText;return!Xi()&&ts()._dirtyType!==st||null===t?super.getTextContent():t}remove(){Rt(52)}replace(t){Rt(53)}insertBefore(t){Rt(54)}insertAfter(t){Rt(55)}updateDOM(t,e){return!1}append(...t){for(let e=0;e<t.length;e++){const n=t[e];_s(n)||ms(n)||Rt(56)}return super.append(...t)}static importJSON(t){const e=we();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"root\",version:1}}collapseAtStart(){return!0}}function vs(t){return t instanceof xs}function Ss(){return new Cs(new Map([[\"root\",new xs]]))}function Ts(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&Rt(130,n.name),_s(t)){const r=e.children;Array.isArray(r)||Rt(59,n.name);const i=t.getChildren();for(let t=0;t<i.length;t++){const e=Ts(i[t]);r.push(e)}}return e}class Cs{constructor(t,e){this._nodeMap=t,this._selection=e||null,this._flushSync=!1,this._readOnly=!1}isEmpty(){return 1===this._nodeMap.size&&null===this._selection}read(t,e){return ls(e&&e.editor||null,this,t)}clone(t){const e=new Cs(this._nodeMap,void 0===t?this._selection:t);return e._readOnly=!0,e}toJSON(){return ls(null,this,(()=>({root:Ts(we())})))}}class ks extends gs{static getType(){return\"artificial\"}createDOM(t){return document.createElement(\"div\")}}class bs extends gs{constructor(t){super(t),this.__textFormat=0,this.__textStyle=\"\"}static getType(){return\"paragraph\"}getTextFormat(){return this.getLatest().__textFormat}setTextFormat(t){const e=this.getWritable();return e.__textFormat=t,e}hasTextFormat(t){const e=Ot[t];return!!(this.getTextFormat()&e)}getTextStyle(){return this.getLatest().__textStyle}setTextStyle(t){const e=this.getWritable();return e.__textStyle=t,e}static clone(t){return new bs(t.__key)}afterCloneFrom(t){super.afterCloneFrom(t),this.__textFormat=t.__textFormat,this.__textStyle=t.__textStyle}createDOM(t){const e=document.createElement(\"p\"),n=je(t.theme,\"paragraph\");if(void 0!==n){e.classList.add(...n)}return e}updateDOM(t,e,n){return!1}static importDOM(){return{p:t=>({conversion:ws,priority:0})}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&vn(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n);const r=this.getIndent();r>0&&(e.style.textIndent=20*r+\"px\")}return{element:e}}static importJSON(t){const e=Ns();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e.setTextFormat(t.textFormat),e}exportJSON(){return{...super.exportJSON(),textFormat:this.getTextFormat(),textStyle:this.getTextStyle(),type:\"paragraph\",version:1}}insertNewAfter(t,e){const n=Ns();n.setTextFormat(t.format),n.setTextStyle(t.style);const r=this.getDirection();return n.setDirection(r),n.setFormat(this.getFormatType()),n.setStyle(this.getTextStyle()),this.insertAfter(n,e),n}collapseAtStart(){const t=this.getChildren();if(0===t.length||oi(t[0])&&\"\"===t[0].getTextContent().trim()){if(null!==this.getNextSibling())return this.selectNext(),this.remove(),!0;if(null!==this.getPreviousSibling())return this.selectPrevious(),this.remove(),!0}return!1}}function ws(t){const e=Ns();if(t.style){e.setFormat(t.style.textAlign);const n=parseInt(t.style.textIndent,10)/20;n>0&&e.setIndent(n)}return{node:e}}function Ns(){return fn(new bs)}function Es(t){return t instanceof bs}const Ps=0,Fs=1,Ds=2,Ls=3,Os=4;function Is(t,e,n,r){const i=t._keyToDOMMap;i.clear(),t._editorState=Ss(),t._pendingEditorState=r,t._compositionKey=null,t._dirtyType=st,t._cloneNotNeeded.clear(),t._dirtyLeaves=new Set,t._dirtyElements.clear(),t._normalizedNodes=new Set,t._updateTags=new Set,t._updates=[],t._blockCursorElement=null;const s=t._observer;null!==s&&(s.disconnect(),t._observer=null),null!==e&&(e.textContent=\"\"),null!==n&&(n.textContent=\"\",i.set(\"root\",n))}function As(t){const e=t||{},n=ns(),r=e.theme||{},i=void 0===t?n:e.parentEditor||null,s=e.disableEvents||!1,o=Ss(),l=e.namespace||(null!==i?i._config.namespace:Oe()),c=e.editorState,a=[xs,Xr,Br,ci,bs,ks,...e.nodes||[]],{onError:u,html:f}=e,d=void 0===e.editable||e.editable;let h;if(void 0===t&&null!==n)h=n._nodes;else{h=new Map;for(let t=0;t<a.length;t++){let e=a[t],n=null,r=null;if(\"function\"!=typeof e){const t=e;e=t.replace,n=t.with,r=t.withKlass||null}const i=e.getType(),s=e.transform(),o=new Set;null!==s&&o.add(s),h.set(i,{exportDOM:f&&f.export?f.export.get(e):void 0,klass:e,replace:n,replaceWithKlass:r,transforms:o})}}const g=new Ms(o,i,h,{disableEvents:s,namespace:l,theme:r},u||console.error,function(t,e){const n=new Map,r=new Set,i=t=>{Object.keys(t).forEach((e=>{let r=n.get(e);void 0===r&&(r=[],n.set(e,r)),r.push(t[e])}))};return t.forEach((t=>{const e=t.klass.importDOM;if(null==e||r.has(e))return;r.add(e);const n=e.call(t.klass);null!==n&&i(n)})),e&&i(e),n}(h,f?f.import:void 0),d);return void 0!==c&&(g._pendingEditorState=c,g._dirtyType=lt),g}class Ms{constructor(t,e,n,r,i,s,o){this._parentEditor=e,this._rootElement=null,this._editorState=t,this._pendingEditorState=null,this._compositionKey=null,this._deferred=[],this._keyToDOMMap=new Map,this._updates=[],this._updating=!1,this._listeners={decorator:new Set,editable:new Set,mutation:new Map,root:new Set,textcontent:new Set,update:new Set},this._commands=new Map,this._config=r,this._nodes=n,this._decorators={},this._pendingDecorators=null,this._dirtyType=st,this._cloneNotNeeded=new Set,this._dirtyLeaves=new Set,this._dirtyElements=new Map,this._normalizedNodes=new Set,this._updateTags=new Set,this._observer=null,this._key=Oe(),this._onError=i,this._htmlConversions=s,this._editable=o,this._headless=null!==e&&e._headless,this._window=null,this._blockCursorElement=null}isComposing(){return null!=this._compositionKey}registerUpdateListener(t){const e=this._listeners.update;return e.add(t),()=>{e.delete(t)}}registerEditableListener(t){const e=this._listeners.editable;return e.add(t),()=>{e.delete(t)}}registerDecoratorListener(t){const e=this._listeners.decorator;return e.add(t),()=>{e.delete(t)}}registerTextContentListener(t){const e=this._listeners.textcontent;return e.add(t),()=>{e.delete(t)}}registerRootListener(t){const e=this._listeners.root;return t(this._rootElement,null),e.add(t),()=>{t(null,this._rootElement),e.delete(t)}}registerCommand(t,e,n){void 0===n&&Rt(35);const r=this._commands;r.has(t)||r.set(t,[new Set,new Set,new Set,new Set,new Set]);const i=r.get(t);void 0===i&&Rt(36,String(t));const s=i[n];return s.add(e),()=>{s.delete(e),i.every((t=>0===t.size))&&r.delete(t)}}registerMutationListener(t,e,n){const r=this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t)).klass,i=this._listeners.mutation;i.set(e,r);const s=n&&n.skipInitialization;return void 0===s||s||this.initializeMutationListener(e,r),()=>{i.delete(e)}}getRegisteredNode(t){const e=this._nodes.get(t.getType());return void 0===e&&Rt(37,t.name),e}resolveRegisteredNodeAfterReplacements(t){for(;t.replaceWithKlass;)t=this.getRegisteredNode(t.replaceWithKlass);return t}initializeMutationListener(t,e){const n=this._editorState,r=En(n).get(e.getType());if(!r)return;const i=new Map;for(const t of r.keys())i.set(t,\"created\");i.size>0&&t(i,{dirtyLeaves:new Set,prevEditorState:n,updateTags:new Set([\"registerMutationListener\"])})}registerNodeTransformToKlass(t,e){const n=this.getRegisteredNode(t);return n.transforms.add(e),n}registerNodeTransform(t,e){const n=this.registerNodeTransformToKlass(t,e),r=[n],i=n.replaceWithKlass;if(null!=i){const t=this.registerNodeTransformToKlass(i,e);r.push(t)}var s,o;return s=this,o=t.getType(),hs(s,(()=>{const t=Gi();if(t.isEmpty())return;if(\"root\"===o)return void we().markDirty();const e=t._nodeMap;for(const[,t]of e)t.markDirty()}),null===s._pendingEditorState?{tag:\"history-merge\"}:void 0),()=>{r.forEach((t=>t.transforms.delete(e)))}}hasNode(t){return this._nodes.has(t.getType())}hasNodes(t){return t.every(this.hasNode.bind(this))}dispatchCommand(t,e){return Ze(this,t,e)}getDecorators(){return this._decorators}getRootElement(){return this._rootElement}getKey(){return this._key}setRootElement(t){const e=this._rootElement;if(t!==e){const n=je(this._config.theme,\"root\"),r=this._pendingEditorState||this._editorState;if(this._rootElement=t,Is(this,e,t,r),null!==e&&(this._config.disableEvents||Mr(e),null!=n&&e.classList.remove(...n)),null!==t){const e=function(t){const e=t.ownerDocument;return e&&e.defaultView||null}(t),r=t.style;r.userSelect=\"text\",r.whiteSpace=\"pre-wrap\",r.wordBreak=\"break-word\",t.setAttribute(\"data-lexical-editor\",\"true\"),this._window=e,this._dirtyType=lt,Yt(this),this._updateTags.add(\"history-merge\"),cs(this),this._config.disableEvents||function(t,e){const n=t.ownerDocument,r=vr.get(n);(void 0===r||r<1)&&n.addEventListener(\"selectionchange\",Or),vr.set(n,(r||0)+1),t.__lexicalEditor=e;const i=Dr(t);for(let n=0;n<_r.length;n++){const[r,s]=_r[n],o=\"function\"==typeof s?t=>{Ar(t)||(Ir(t),(e.isEditable()||\"click\"===r)&&s(t,e))}:t=>{if(Ar(t))return;Ir(t);const n=e.isEditable();switch(r){case\"cut\":return n&&Ze(e,W,t);case\"copy\":return Ze(e,M,t);case\"paste\":return n&&Ze(e,c,t);case\"dragstart\":return n&&Ze(e,O,t);case\"dragover\":return n&&Ze(e,I,t);case\"dragend\":return n&&Ze(e,A,t);case\"focus\":return n&&Ze(e,J,t);case\"blur\":return n&&Ze(e,U,t);case\"drop\":return n&&Ze(e,D,t)}};t.addEventListener(r,o),i.push((()=>{t.removeEventListener(r,o)}))}}(t,this),null!=n&&t.classList.add(...n)}else this._editorState=r,this._pendingEditorState=null,this._window=null;as(\"root\",this,!1,t,e)}}getElementByKey(t){return this._keyToDOMMap.get(t)||null}getEditorState(){return this._editorState}setEditorState(t,e){t.isEmpty()&&Rt(38),Xt(this);const n=this._pendingEditorState,r=this._updateTags,i=void 0!==e?e.tag:null;null===n||n.isEmpty()||(null!=i&&r.add(i),cs(this)),this._pendingEditorState=t,this._dirtyType=lt,this._dirtyElements.set(\"root\",!1),this._compositionKey=null,null!=i&&r.add(i),cs(this)}parseEditorState(t,e){return function(t,e,n){const r=Ss(),i=Ui,s=ji,o=Vi,l=e._dirtyElements,c=e._dirtyLeaves,a=e._cloneNotNeeded,u=e._dirtyType;e._dirtyElements=new Map,e._dirtyLeaves=new Set,e._cloneNotNeeded=new Set,e._dirtyType=0,Ui=r,ji=!1,Vi=e;try{const i=e._nodes;os(t.root,i),n&&n(),r._readOnly=!0}catch(t){t instanceof Error&&e._onError(t)}finally{e._dirtyElements=l,e._dirtyLeaves=c,e._cloneNotNeeded=a,e._dirtyType=u,Ui=i,ji=s,Vi=o}return r}(\"string\"==typeof t?JSON.parse(t):t,this,e)}read(t){return cs(this),this.getEditorState().read(t,{editor:this})}update(t,e){hs(this,t,e)}focus(t,e={}){const n=this._rootElement;null!==n&&(n.setAttribute(\"autocapitalize\",\"off\"),hs(this,(()=>{const t=Oi(),n=we();null!==t?t.dirty=!0:0!==n.getChildrenSize()&&(\"rootStart\"===e.defaultSelection?n.selectStart():n.selectEnd())}),{onUpdate:()=>{n.removeAttribute(\"autocapitalize\"),t&&t()},tag:\"focus\"}),null===this._pendingEditorState&&n.removeAttribute(\"autocapitalize\"))}blur(){const t=this._rootElement;null!==t&&t.blur();const e=yn(this._window);null!==e&&e.removeAllRanges()}isEditable(){return this._editable}setEditable(t){this._editable!==t&&(this._editable=t,as(\"editable\",this,!0,t))}toJSON(){return{editorState:this._editorState.toJSON()}}}Ms.version=\"0.17.1+prod.esm\";export{rn as $addUpdateTag,fn as $applyNodeReplacement,Pn as $cloneWithProperties,un as $copyNode,Kr as $createLineBreakNode,Fi as $createNodeSelection,Ns as $createParagraphNode,di as $createPoint,Pi as $createRangeSelection,Di as $createRangeSelectionFromDom,ai as $createTabNode,si as $createTextNode,Xe as $getAdjacentNode,Si as $getCharacterOffsets,bn as $getEditor,Ce as $getNearestNodeFromDOMNode,cn as $getNearestRootOrShadowRoot,Se as $getNodeByKey,hn as $getNodeByKeyOrThrow,Ii as $getPreviousSelection,we as $getRoot,Oi as $getSelection,Ki as $getTextContent,sn as $hasAncestor,nn as $hasUpdateTag,Ri as $insertNodes,Ni as $isBlockElementNode,ms as $isDecoratorNode,_s as $isElementNode,ln as $isInlineElementOrDecoratorNode,_e as $isLeafNode,$r as $isLineBreakNode,xi as $isNodeSelection,Es as $isParagraphNode,yi as $isRangeSelection,vs as $isRootNode,an as $isRootOrShadowRoot,ui as $isTabNode,oi as $isTextNode,fe as $isTokenOrSegmented,qe as $nodesOfType,ee as $normalizeSelection__EXPERIMENTAL,ss as $parseSerializedNode,Ve as $selectAll,xe as $setCompositionKey,Ee as $setSelection,mn as $splitNode,ks as ArtificialNode__DO_NOT_USE,U as BLUR_COMMAND,K as CAN_REDO_COMMAND,$ as CAN_UNDO_COMMAND,B as CLEAR_EDITOR_COMMAND,R as CLEAR_HISTORY_COMMAND,r as CLICK_COMMAND,Os as COMMAND_PRIORITY_CRITICAL,Ps as COMMAND_PRIORITY_EDITOR,Ls as COMMAND_PRIORITY_HIGH,Fs as COMMAND_PRIORITY_LOW,Ds as COMMAND_PRIORITY_NORMAL,l as CONTROLLED_TEXT_INSERTION_COMMAND,M as COPY_COMMAND,W as CUT_COMMAND,i as DELETE_CHARACTER_COMMAND,f as DELETE_LINE_COMMAND,u as DELETE_WORD_COMMAND,A as DRAGEND_COMMAND,I as DRAGOVER_COMMAND,O as DRAGSTART_COMMAND,D as DROP_COMMAND,ys as DecoratorNode,gs as ElementNode,J as FOCUS_COMMAND,L as FORMAT_ELEMENT_COMMAND,d as FORMAT_TEXT_COMMAND,P as INDENT_CONTENT_COMMAND,s as INSERT_LINE_BREAK_COMMAND,o as INSERT_PARAGRAPH_COMMAND,E as INSERT_TAB_COMMAND,xt as IS_ALL_FORMATTING,ft as IS_BOLD,_t as IS_CODE,mt as IS_HIGHLIGHT,dt as IS_ITALIC,ht as IS_STRIKETHROUGH,pt as IS_SUBSCRIPT,yt as IS_SUPERSCRIPT,gt as IS_UNDERLINE,S as KEY_ARROW_DOWN_COMMAND,m as KEY_ARROW_LEFT_COMMAND,p as KEY_ARROW_RIGHT_COMMAND,v as KEY_ARROW_UP_COMMAND,k as KEY_BACKSPACE_COMMAND,w as KEY_DELETE_COMMAND,_ as KEY_DOWN_COMMAND,T as KEY_ENTER_COMMAND,b as KEY_ESCAPE_COMMAND,V as KEY_MODIFIER_COMMAND,C as KEY_SPACE_COMMAND,N as KEY_TAB_COMMAND,Br as LineBreakNode,y as MOVE_TO_END,x as MOVE_TO_START,F as OUTDENT_CONTENT_COMMAND,c as PASTE_COMMAND,bs as ParagraphNode,g as REDO_COMMAND,a as REMOVE_TEXT_COMMAND,xs as RootNode,e as SELECTION_CHANGE_COMMAND,n as SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,z as SELECT_ALL_COMMAND,Ot as TEXT_TYPE_TO_FORMAT,ci as TabNode,Xr as TextNode,h as UNDO_COMMAND,t as createCommand,As as createEditor,ue as getEditorPropertyFromDOMNode,ae as getNearestEditorFromDOMNode,Tn as isBlockDomNode,Xi as isCurrentlyReadOnlyMode,xn as isHTMLAnchorElement,vn as isHTMLElement,Sn as isInlineDomNode,ce as isLexicalEditor,oe as isSelectionCapturedInDecoratorInput,le as isSelectionWithinEditor,ie as resetRandomKey};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './Lexical.dev.mjs';\nimport * as modProd from './Lexical.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addUpdateTag = mod.$addUpdateTag;\nexport const $applyNodeReplacement = mod.$applyNodeReplacement;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $copyNode = mod.$copyNode;\nexport const $createLineBreakNode = mod.$createLineBreakNode;\nexport const $createNodeSelection = mod.$createNodeSelection;\nexport const $createParagraphNode = mod.$createParagraphNode;\nexport const $createPoint = mod.$createPoint;\nexport const $createRangeSelection = mod.$createRangeSelection;\nexport const $createRangeSelectionFromDom = mod.$createRangeSelectionFromDom;\nexport const $createTabNode = mod.$createTabNode;\nexport const $createTextNode = mod.$createTextNode;\nexport const $getAdjacentNode = mod.$getAdjacentNode;\nexport const $getCharacterOffsets = mod.$getCharacterOffsets;\nexport const $getEditor = mod.$getEditor;\nexport const $getNearestNodeFromDOMNode = mod.$getNearestNodeFromDOMNode;\nexport const $getNearestRootOrShadowRoot = mod.$getNearestRootOrShadowRoot;\nexport const $getNodeByKey = mod.$getNodeByKey;\nexport const $getNodeByKeyOrThrow = mod.$getNodeByKeyOrThrow;\nexport const $getPreviousSelection = mod.$getPreviousSelection;\nexport const $getRoot = mod.$getRoot;\nexport const $getSelection = mod.$getSelection;\nexport const $getTextContent = mod.$getTextContent;\nexport const $hasAncestor = mod.$hasAncestor;\nexport const $hasUpdateTag = mod.$hasUpdateTag;\nexport const $insertNodes = mod.$insertNodes;\nexport const $isBlockElementNode = mod.$isBlockElementNode;\nexport const $isDecoratorNode = mod.$isDecoratorNode;\nexport const $isElementNode = mod.$isElementNode;\nexport const $isInlineElementOrDecoratorNode = mod.$isInlineElementOrDecoratorNode;\nexport const $isLeafNode = mod.$isLeafNode;\nexport const $isLineBreakNode = mod.$isLineBreakNode;\nexport const $isNodeSelection = mod.$isNodeSelection;\nexport const $isParagraphNode = mod.$isParagraphNode;\nexport const $isRangeSelection = mod.$isRangeSelection;\nexport const $isRootNode = mod.$isRootNode;\nexport const $isRootOrShadowRoot = mod.$isRootOrShadowRoot;\nexport const $isTabNode = mod.$isTabNode;\nexport const $isTextNode = mod.$isTextNode;\nexport const $isTokenOrSegmented = mod.$isTokenOrSegmented;\nexport const $nodesOfType = mod.$nodesOfType;\nexport const $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;\nexport const $parseSerializedNode = mod.$parseSerializedNode;\nexport const $selectAll = mod.$selectAll;\nexport const $setCompositionKey = mod.$setCompositionKey;\nexport const $setSelection = mod.$setSelection;\nexport const $splitNode = mod.$splitNode;\nexport const ArtificialNode__DO_NOT_USE = mod.ArtificialNode__DO_NOT_USE;\nexport const BLUR_COMMAND = mod.BLUR_COMMAND;\nexport const CAN_REDO_COMMAND = mod.CAN_REDO_COMMAND;\nexport const CAN_UNDO_COMMAND = mod.CAN_UNDO_COMMAND;\nexport const CLEAR_EDITOR_COMMAND = mod.CLEAR_EDITOR_COMMAND;\nexport const CLEAR_HISTORY_COMMAND = mod.CLEAR_HISTORY_COMMAND;\nexport const CLICK_COMMAND = mod.CLICK_COMMAND;\nexport const COMMAND_PRIORITY_CRITICAL = mod.COMMAND_PRIORITY_CRITICAL;\nexport const COMMAND_PRIORITY_EDITOR = mod.COMMAND_PRIORITY_EDITOR;\nexport const COMMAND_PRIORITY_HIGH = mod.COMMAND_PRIORITY_HIGH;\nexport const COMMAND_PRIORITY_LOW = mod.COMMAND_PRIORITY_LOW;\nexport const COMMAND_PRIORITY_NORMAL = mod.COMMAND_PRIORITY_NORMAL;\nexport const CONTROLLED_TEXT_INSERTION_COMMAND = mod.CONTROLLED_TEXT_INSERTION_COMMAND;\nexport const COPY_COMMAND = mod.COPY_COMMAND;\nexport const CUT_COMMAND = mod.CUT_COMMAND;\nexport const DELETE_CHARACTER_COMMAND = mod.DELETE_CHARACTER_COMMAND;\nexport const DELETE_LINE_COMMAND = mod.DELETE_LINE_COMMAND;\nexport const DELETE_WORD_COMMAND = mod.DELETE_WORD_COMMAND;\nexport const DRAGEND_COMMAND = mod.DRAGEND_COMMAND;\nexport const DRAGOVER_COMMAND = mod.DRAGOVER_COMMAND;\nexport const DRAGSTART_COMMAND = mod.DRAGSTART_COMMAND;\nexport const DROP_COMMAND = mod.DROP_COMMAND;\nexport const DecoratorNode = mod.DecoratorNode;\nexport const ElementNode = mod.ElementNode;\nexport const FOCUS_COMMAND = mod.FOCUS_COMMAND;\nexport const FORMAT_ELEMENT_COMMAND = mod.FORMAT_ELEMENT_COMMAND;\nexport const FORMAT_TEXT_COMMAND = mod.FORMAT_TEXT_COMMAND;\nexport const INDENT_CONTENT_COMMAND = mod.INDENT_CONTENT_COMMAND;\nexport const INSERT_LINE_BREAK_COMMAND = mod.INSERT_LINE_BREAK_COMMAND;\nexport const INSERT_PARAGRAPH_COMMAND = mod.INSERT_PARAGRAPH_COMMAND;\nexport const INSERT_TAB_COMMAND = mod.INSERT_TAB_COMMAND;\nexport const IS_ALL_FORMATTING = mod.IS_ALL_FORMATTING;\nexport const IS_BOLD = mod.IS_BOLD;\nexport const IS_CODE = mod.IS_CODE;\nexport const IS_HIGHLIGHT = mod.IS_HIGHLIGHT;\nexport const IS_ITALIC = mod.IS_ITALIC;\nexport const IS_STRIKETHROUGH = mod.IS_STRIKETHROUGH;\nexport const IS_SUBSCRIPT = mod.IS_SUBSCRIPT;\nexport const IS_SUPERSCRIPT = mod.IS_SUPERSCRIPT;\nexport const IS_UNDERLINE = mod.IS_UNDERLINE;\nexport const KEY_ARROW_DOWN_COMMAND = mod.KEY_ARROW_DOWN_COMMAND;\nexport const KEY_ARROW_LEFT_COMMAND = mod.KEY_ARROW_LEFT_COMMAND;\nexport const KEY_ARROW_RIGHT_COMMAND = mod.KEY_ARROW_RIGHT_COMMAND;\nexport const KEY_ARROW_UP_COMMAND = mod.KEY_ARROW_UP_COMMAND;\nexport const KEY_BACKSPACE_COMMAND = mod.KEY_BACKSPACE_COMMAND;\nexport const KEY_DELETE_COMMAND = mod.KEY_DELETE_COMMAND;\nexport const KEY_DOWN_COMMAND = mod.KEY_DOWN_COMMAND;\nexport const KEY_ENTER_COMMAND = mod.KEY_ENTER_COMMAND;\nexport const KEY_ESCAPE_COMMAND = mod.KEY_ESCAPE_COMMAND;\nexport const KEY_MODIFIER_COMMAND = mod.KEY_MODIFIER_COMMAND;\nexport const KEY_SPACE_COMMAND = mod.KEY_SPACE_COMMAND;\nexport const KEY_TAB_COMMAND = mod.KEY_TAB_COMMAND;\nexport const LineBreakNode = mod.LineBreakNode;\nexport const MOVE_TO_END = mod.MOVE_TO_END;\nexport const MOVE_TO_START = mod.MOVE_TO_START;\nexport const OUTDENT_CONTENT_COMMAND = mod.OUTDENT_CONTENT_COMMAND;\nexport const PASTE_COMMAND = mod.PASTE_COMMAND;\nexport const ParagraphNode = mod.ParagraphNode;\nexport const REDO_COMMAND = mod.REDO_COMMAND;\nexport const REMOVE_TEXT_COMMAND = mod.REMOVE_TEXT_COMMAND;\nexport const RootNode = mod.RootNode;\nexport const SELECTION_CHANGE_COMMAND = mod.SELECTION_CHANGE_COMMAND;\nexport const SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;\nexport const SELECT_ALL_COMMAND = mod.SELECT_ALL_COMMAND;\nexport const TEXT_TYPE_TO_FORMAT = mod.TEXT_TYPE_TO_FORMAT;\nexport const TabNode = mod.TabNode;\nexport const TextNode = mod.TextNode;\nexport const UNDO_COMMAND = mod.UNDO_COMMAND;\nexport const createCommand = mod.createCommand;\nexport const createEditor = mod.createEditor;\nexport const getEditorPropertyFromDOMNode = mod.getEditorPropertyFromDOMNode;\nexport const getNearestEditorFromDOMNode = mod.getNearestEditorFromDOMNode;\nexport const isBlockDomNode = mod.isBlockDomNode;\nexport const isCurrentlyReadOnlyMode = mod.isCurrentlyReadOnlyMode;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isInlineDomNode = mod.isInlineDomNode;\nexport const isLexicalEditor = mod.isLexicalEditor;\nexport const isSelectionCapturedInDecoratorInput = mod.isSelectionCapturedInDecoratorInput;\nexport const isSelectionWithinEditor = mod.isSelectionWithinEditor;\nexport const resetRandomKey = mod.resetRandomKey;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $isTokenOrSegmented, $getRoot, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $setSelection, $getAdjacentNode, $isDecoratorNode, $isLineBreakNode } from 'lexical';\nexport { $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && $isRangeSelection(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ($isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ($isTextNode(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ($isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ($isTextNode(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ($isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = $getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!$isElementNode(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = $getAdjacentNode(selection.focus, isBackward);\n  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ($isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ($isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node)) {\n    return false;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $selectAll, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getStyleObjectFromCSS, trimTextContentFromAnchor };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$isTextNode as e,$getCharacterOffsets as t,$isElementNode as n,$isRootNode as l,$getNodeByKey as o,$getPreviousSelection as r,$createTextNode as s,$isRangeSelection as i,$isTokenOrSegmented as c,$getRoot as f,$isRootOrShadowRoot as u,$hasAncestor as g,$isLeafNode as a,$setSelection as d,$getAdjacentNode as p,$isDecoratorNode as h,$isLineBreakNode as y}from\"lexical\";export{$cloneWithProperties}from\"lexical\";function m(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var T=m((function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const x=new Map;function S(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function v(e){const t=e.parentNode;if(null==t)throw new Error(\"Should never happen\");return[t,Array.from(t.childNodes).indexOf(e)]}function C(t,n,l,o,r){const s=n.getKey(),i=o.getKey(),c=document.createRange();let f=t.getElementByKey(s),u=t.getElementByKey(i),g=l,a=r;if(e(n)&&(f=S(f)),e(o)&&(u=S(u)),void 0===n||void 0===o||null===f||null===u)return null;\"BR\"===f.nodeName&&([f,g]=v(f)),\"BR\"===u.nodeName&&([u,a]=v(u));const d=f.firstChild;f===u&&null!=d&&\"BR\"===d.nodeName&&0===g&&0===a&&(a=1);try{c.setStart(f,g),c.setEnd(u,a)}catch(e){return null}return!c.collapsed||g===a&&s===i||(c.setStart(u,a),c.setEnd(f,g)),c}function P(e,t){const n=e.getRootElement();if(null===n)return[];const l=n.getBoundingClientRect(),o=getComputedStyle(n),r=parseFloat(o.paddingLeft)+parseFloat(o.paddingRight),s=Array.from(t.getClientRects());let i,c=s.length;s.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=s[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,o=t.width+r===l.width;n||o?(s.splice(e--,1),c--):i=t}return s}function w(e){const t={},n=e.split(\";\");for(const e of n)if(\"\"!==e){const[n,l]=e.split(/:([^]+)/);n&&l&&(t[n.trim()]=l.trim())}return t}function N(e){let t=x.get(e);return void 0===t&&(t=w(e),x.set(e,t)),t}function E(e,n){const l=e.getStartEndPoints();if(n.isSelected(e)&&!n.isSegmented()&&!n.isToken()&&null!==l){const[o,r]=l,s=e.isBackward(),i=o.getNode(),c=r.getNode(),f=n.is(i),u=n.is(c);if(f||u){const[l,o]=t(e),r=i.is(c),f=n.is(s?c:i),u=n.is(s?i:c);let g,a=0;if(r)a=l>o?o:l,g=l>o?l:o;else if(f){a=s?o:l,g=void 0}else if(u){a=0,g=s?l:o}return n.__text=n.__text.slice(a,g),n}}return n}function F(e){if(\"text\"===e.type)return e.offset===e.getNode().getTextContentSize();const t=e.getNode();return n(t)||T(177),e.offset===t.getChildrenSize()}function K(t,c,f){let u=c.getNode(),g=f;if(n(u)){const e=u.getDescendantByIndex(c.offset);null!==e&&(u=e)}for(;g>0&&null!==u;){if(n(u)){const e=u.getLastDescendant();null!==e&&(u=e)}let f=u.getPreviousSibling(),a=0;if(null===f){let e=u.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){f=null;break}t=e.getPreviousSibling()}null!==e&&(a=e.isInline()?0:2,f=t)}let d=u.getTextContent();\"\"===d&&n(u)&&!u.isInline()&&(d=\"\\n\\n\");const p=d.length;if(!e(u)||g>=p){const e=u.getParent();u.remove(),null==e||0!==e.getChildrenSize()||l(e)||e.remove(),g-=p+a,u=f}else{const n=u.getKey(),l=t.getEditorState().read((()=>{const t=o(n);return e(t)&&t.isSimpleText()?t.getTextContent():null})),f=p-g,a=d.slice(0,f);if(null!==l&&l!==d){const e=r();let t=u;if(u.isSimpleText())u.setTextContent(l);else{const e=s(l);u.replace(e),t=e}if(i(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(u.isSimpleText()){const e=c.key===n;let t=c.offset;t<g&&(t=p);const l=e?t-g:0,o=e?t:f;if(e&&0===l){const[e]=u.splitText(l,o);e.remove()}else{const[,e]=u.splitText(l,o);e.remove()}}else{const e=s(a);u.replace(e)}g=0}}}function I(e){const t=e.getStyle(),n=w(t);x.set(t,n)}function O(e,t){const n=N(\"getStyle\"in e?e.getStyle():e.style),l=Object.entries(t).reduce(((t,[l,o])=>(\"function\"==typeof o?t[l]=o(n[l],e):null===o?delete t[l]:t[l]=o,t)),{...n}||{}),o=function(e){let t=\"\";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}(l);e.setStyle(o),x.set(o,l)}function B(t,n){const l=t.getNodes(),o=l.length,r=t.getStartEndPoints();if(null===r)return;const[s,f]=r,u=o-1;let g=l[0],a=l[u];if(t.isCollapsed()&&i(t))return void O(t,n);const d=g.getTextContent().length,p=f.offset;let h=s.offset;const y=s.isBefore(f);let m=y?h:p,T=y?p:h;const x=y?s.type:f.type,S=y?f.type:s.type,v=y?f.key:s.key;if(e(g)&&m===d){const t=g.getNextSibling();e(t)&&(h=0,m=0,g=t)}if(1===l.length){if(e(g)&&g.canHaveFormat()){if(m=\"element\"===x?0:h>p?p:h,T=\"element\"===S?d:h>p?h:p,m===T)return;if(c(g)||0===m&&T===d)O(g,n),g.select(m,T);else{const e=g.splitText(m,T),t=0===m?e[0]:e[1];O(t,n),t.select(0,T-m)}}}else{if(e(g)&&m<g.getTextContentSize()&&g.canHaveFormat()&&(0===m||c(g)||(g=g.splitText(m)[1],m=0,y?s.set(g.getKey(),m,\"text\"):f.set(g.getKey(),m,\"text\")),O(g,n)),e(a)&&a.canHaveFormat()){const e=a.getTextContent().length;a.__key!==v&&0!==T&&(T=e),T===e||c(a)||([a]=a.splitText(T)),0===T&&\"element\"!==S||O(a,n)}for(let t=1;t<u;t++){const o=l[t],r=o.getKey();e(o)&&o.canHaveFormat()&&r!==g.getKey()&&r!==a.getKey()&&!o.isToken()&&O(o,n)}}}function k(e,t){if(null===e)return;const l=e.getStartEndPoints(),o=l?l[0]:null;if(null!==o&&\"root\"===o.key){const e=t(),n=f(),l=n.getFirstChild();return void(l?l.replace(e,!0):n.append(e))}const r=e.getNodes(),s=null!==o&&function(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}(o.getNode(),U);s&&-1===r.indexOf(s)&&r.push(s);for(let e=0;e<r.length;e++){const l=r[e];if(!U(l))continue;n(l)||T(178);const o=t();o.setFormat(l.getFormatType()),o.setIndent(l.getIndent()),l.replace(o,!0)}}function b(e){return e.getNode().isAttached()}function R(e){let t=e;for(;null!==t&&!u(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function _(e,t,n=null){const l=e.getStartEndPoints(),o=l?l[0]:null,r=e.getNodes(),s=r.length;if(null!==o&&(0===s||1===s&&\"element\"===o.type&&0===o.getNode().getChildrenSize())){const e=\"text\"===o.type?o.getNode().getParentOrThrow():o.getNode(),l=e.getChildren();let r=t();return r.setFormat(e.getFormatType()),r.setIndent(e.getIndent()),l.forEach((e=>r.append(e))),n&&(r=n.append(r)),void e.replace(r)}let i=null,c=[];for(let l=0;l<s;l++){const o=r[l];u(o)?(z(e,c,c.length,t,n),c=[],i=o):null===i||null!==i&&g(o,i)?c.push(o):(z(e,c,c.length,t,n),c=[o])}z(e,c,c.length,t,n)}function z(e,t,l,o,s=null){if(0===t.length)return;const c=t[0],f=new Map,g=[];let p=n(c)?c:c.getParentOrThrow();p.isInline()&&(p=p.getParentOrThrow());let h=!1;for(;null!==p;){const e=p.getPreviousSibling();if(null!==e){p=e,h=!0;break}if(p=p.getParentOrThrow(),u(p))break}const y=new Set;for(let e=0;e<l;e++){const l=t[e];n(l)&&0===l.getChildrenSize()&&y.add(l.getKey())}const m=new Set;for(let e=0;e<l;e++){const l=t[e];let r=l.getParent();if(null!==r&&r.isInline()&&(r=r.getParent()),null!==r&&a(l)&&!m.has(l.getKey())){const e=r.getKey();if(void 0===f.get(e)){const t=o();t.setFormat(r.getFormatType()),t.setIndent(r.getIndent()),g.push(t),f.set(e,t),r.getChildren().forEach((e=>{t.append(e),m.add(e.getKey()),n(e)&&e.getChildrenKeys().forEach((e=>m.add(e)))})),R(r)}}else if(y.has(l.getKey())){n(l)||T(179);const e=o();e.setFormat(l.getFormatType()),e.setIndent(l.getIndent()),g.push(e),l.remove(!0)}}if(null!==s)for(let e=0;e<g.length;e++){const t=g[e];s.append(t)}let x=null;if(u(p))if(h)if(null!==s)p.insertAfter(s);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t)}else{const e=p.getFirstChild();if(n(e)&&(p=e),null===e)if(s)p.append(s);else for(let e=0;e<g.length;e++){const t=g[e];p.append(t),x=t}else if(null!==s)e.insertBefore(s);else for(let t=0;t<g.length;t++){const n=g[t];e.insertBefore(n),x=n}}else if(s)p.insertAfter(s);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t),x=t}const S=r();i(S)&&b(S.anchor)&&b(S.focus)?d(S.clone()):null!==x?x.selectEnd():e.dirty=!0}function A(e,t){const l=p(e.focus,t);return h(l)&&!l.isIsolated()||n(l)&&!l.isInline()&&!l.canBeEmpty()}function L(e,t,n,l){e.modify(t?\"extend\":\"move\",n,l)}function D(e){const t=e.anchor.getNode();return\"rtl\"===(l(t)?t:t.getParentOrThrow()).getDirection()}function M(e,t,n){const l=D(e);L(e,t,n?!l:l,\"character\")}function $(t){const l=t.anchor,o=t.focus,r=l.getNode().getTopLevelElementOrThrow().getParentOrThrow();let s=r.getFirstDescendant(),i=r.getLastDescendant(),c=\"element\",f=\"element\",u=0;e(s)?c=\"text\":n(s)||null===s||(s=s.getParentOrThrow()),e(i)?(f=\"text\",u=i.getTextContentSize()):n(i)||null===i||(i=i.getParentOrThrow()),s&&i&&(l.set(s.getKey(),0,c),o.set(i.getKey(),u,f))}function H(e,t,n){const l=N(e.getStyle());return null!==l&&l[t]||n}function j(t,n,l=\"\"){let o=null;const r=t.getNodes(),s=t.anchor,c=t.focus,f=t.isBackward(),u=f?c.offset:s.offset,g=f?c.getNode():s.getNode();if(i(t)&&t.isCollapsed()&&\"\"!==t.style){const e=N(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const s=r[t];if((0===t||0!==u||!s.is(g))&&e(s)){const e=H(s,n,l);if(null===o)o=e;else if(o!==e){o=\"\";break}}}return null===o?l:o}function U(t){if(h(t))return!1;if(!n(t)||u(t))return!1;const l=t.getFirstChild(),o=null===l||y(l)||e(l)||l.isInline();return!t.isInline()&&!1!==t.canBeEmpty()&&o}const W=K;export{I as $addNodeStyle,j as $getSelectionStyleValueForProperty,F as $isAtNodeEnd,D as $isParentElementRTL,L as $moveCaretSelection,M as $moveCharacter,B as $patchStyleText,$ as $selectAll,k as $setBlocksType,A as $shouldOverrideDefaultCharacterSelection,E as $sliceSelectedTextNodeContent,K as $trimTextContentFromAnchor,_ as $wrapNodes,C as createDOMRange,P as createRectsFromDOMRange,N as getStyleObjectFromCSS,W as trimTextContentFromAnchor};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalSelection.dev.mjs';\nimport * as modProd from './LexicalSelection.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addNodeStyle = mod.$addNodeStyle;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $getSelectionStyleValueForProperty = mod.$getSelectionStyleValueForProperty;\nexport const $isAtNodeEnd = mod.$isAtNodeEnd;\nexport const $isParentElementRTL = mod.$isParentElementRTL;\nexport const $moveCaretSelection = mod.$moveCaretSelection;\nexport const $moveCharacter = mod.$moveCharacter;\nexport const $patchStyleText = mod.$patchStyleText;\nexport const $selectAll = mod.$selectAll;\nexport const $setBlocksType = mod.$setBlocksType;\nexport const $shouldOverrideDefaultCharacterSelection = mod.$shouldOverrideDefaultCharacterSelection;\nexport const $sliceSelectedTextNodeContent = mod.$sliceSelectedTextNodeContent;\nexport const $trimTextContentFromAnchor = mod.$trimTextContentFromAnchor;\nexport const $wrapNodes = mod.$wrapNodes;\nexport const createDOMRange = mod.createDOMRange;\nexport const createRectsFromDOMRange = mod.createRectsFromDOMRange;\nexport const getStyleObjectFromCSS = mod.getStyleObjectFromCSS;\nexport const trimTextContentFromAnchor = mod.trimTextContentFromAnchor;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $cloneWithProperties, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $isTextNode, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$getSelection as e,$isRangeSelection as t,TextNode as n,$getRoot as o,$isElementNode as r,$cloneWithProperties as l,$setSelection as i,$getPreviousSelection as s,$isRootOrShadowRoot as u,$isTextNode as c,$splitNode as f,$createParagraphNode as a}from\"lexical\";export{$splitNode,isBlockDomNode,isHTMLAnchorElement,isHTMLElement,isInlineDomNode}from\"lexical\";import{createRectsFromDOMRange as d}from\"@lexical/selection\";function g(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var p=g((function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const h=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,m=h&&\"documentMode\"in document?document.documentMode:null,v=h&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),y=h&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),w=!(!h||!(\"InputEvent\"in window)||m)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),E=h&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),P=h&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,S=h&&/Android/.test(navigator.userAgent),x=h&&/^(?=.*Chrome).*/i.test(navigator.userAgent),N=h&&S&&x,A=h&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!x;function L(...e){const t=[];for(const n of e)if(n&&\"string\"==typeof n)for(const[e]of n.matchAll(/\\S+/g))t.push(e);return t}function b(...e){return()=>{for(let t=e.length-1;t>=0;t--)e[t]();e.length=0}}function T(e){return`${e}px`}const M={attributes:!0,characterData:!0,childList:!0,subtree:!0};function C(e,t,n){let o=null,r=null,l=null,i=[];const s=document.createElement(\"div\");function u(){null===o&&p(182),null===r&&p(183);const{left:l,top:u}=o.getBoundingClientRect(),c=r,f=d(e,t);s.isConnected||c.append(s);let a=!1;for(let e=0;e<f.length;e++){const t=f[e],n=i[e]||document.createElement(\"div\"),o=n.style;\"absolute\"!==o.position&&(o.position=\"absolute\",a=!0);const r=T(t.left-l);o.left!==r&&(o.left=r,a=!0);const c=T(t.top-u);o.top!==c&&(n.style.top=c,a=!0);const d=T(t.width);o.width!==d&&(n.style.width=d,a=!0);const g=T(t.height);o.height!==g&&(n.style.height=g,a=!0),n.parentNode!==s&&(s.append(n),a=!0),i[e]=n}for(;i.length>f.length;)i.pop();a&&n(i)}function c(){r=null,o=null,null!==l&&l.disconnect(),l=null,s.remove();for(const e of i)e.remove();i=[]}const f=e.registerRootListener((function t(){const n=e.getRootElement();if(null===n)return c();const i=n.parentElement;if(!(i instanceof HTMLElement))return c();c(),o=n,r=i,l=new MutationObserver((n=>{const l=e.getRootElement(),i=l&&l.parentElement;if(l!==o||i!==r)return t();for(const e of n)if(!s.contains(e.target))return u()})),l.observe(i,M),u()}));return()=>{f(),c()}}function B(o,r){let l=null,i=null,s=null,u=null,c=()=>{};function f(f){f.read((()=>{const f=e();if(!t(f))return l=null,i=null,s=null,u=null,c(),void(c=()=>{});const{anchor:a,focus:d}=f,g=a.getNode(),h=g.getKey(),m=a.offset,v=d.getNode(),y=v.getKey(),w=d.offset,E=o.getElementByKey(h),P=o.getElementByKey(y),S=null===l||null===E||m!==i||h!==l.getKey()||g!==l&&(!(l instanceof n)||g.updateDOM(l,E,o._config)),x=null===s||null===P||w!==u||y!==s.getKey()||v!==s&&(!(s instanceof n)||v.updateDOM(s,P,o._config));if(S||x){const e=o.getElementByKey(a.getNode().getKey()),t=o.getElementByKey(d.getNode().getKey());if(null!==e&&null!==t&&\"SPAN\"===e.tagName&&\"SPAN\"===t.tagName){const n=document.createRange();let l,i,s,u;d.isBefore(a)?(l=t,i=d.offset,s=e,u=a.offset):(l=e,i=a.offset,s=t,u=d.offset);const f=l.firstChild;null===f&&p(181);const g=s.firstChild;null===g&&p(181),n.setStart(f,i),n.setEnd(g,u),c(),c=C(o,n,(e=>{for(const t of e){const e=t.style;\"Highlight\"!==e.background&&(e.background=\"Highlight\"),\"HighlightText\"!==e.color&&(e.color=\"HighlightText\"),\"-1\"!==e.zIndex&&(e.zIndex=\"-1\"),\"none\"!==e.pointerEvents&&(e.pointerEvents=\"none\"),e.marginTop!==T(-1.5)&&(e.marginTop=T(-1.5)),e.paddingTop!==T(4)&&(e.paddingTop=T(4)),e.paddingBottom!==T(0)&&(e.paddingBottom=T(0))}void 0!==r&&r(e)}))}}l=g,i=m,s=v,u=w}))}return f(o.getEditorState()),b(o.registerUpdateListener((({editorState:e})=>f(e))),c,(()=>{c()}))}const _=w,K=h,O=S,R=N,I=v,D=A,H=x,z=y,k=P,F=E;function $(e,...t){const n=L(...t);n.length>0&&e.classList.add(...n)}function U(e,...t){const n=L(...t);n.length>0&&e.classList.remove(...n)}function W(e,t){for(const n of t)if(e.type.startsWith(n))return!0;return!1}function j(e,t){const n=e[Symbol.iterator]();return new Promise(((e,o)=>{const r=[],l=()=>{const{done:i,value:s}=n.next();if(i)return e(r);const u=new FileReader;u.addEventListener(\"error\",o),u.addEventListener(\"load\",(()=>{const e=u.result;\"string\"==typeof e&&r.push({file:s,result:e}),l()})),W(s,t)?u.readAsDataURL(s):l()};l()}))}function V(e,t){const n=[],l=(e||o()).getLatest(),i=t||r(l)&&l.getLastDescendant()||l;let s=l,u=function(e){let t=e,n=0;for(;null!==(t=t.getParent());)n++;return n}(s);for(;null!==s&&!s.is(i);)if(n.push({depth:u,node:s}),r(s)&&s.getChildrenSize()>0)s=s.getFirstChild(),u++;else{let e=null;for(;null===e&&null!==s;)e=s.getNextSibling(),null===e?(s=s.getParent(),u--):s=e}return null!==s&&s.is(i)&&n.push({depth:u,node:s}),n}function q(e){let t=e;if(r(t)&&t.getChildrenSize()>0)t=t.getLastChild();else{let e=null;for(;null===e&&null!==t;)e=t.getPreviousSibling(),t=null===e?t.getParent():e}return t}function G(e,t){let n=e;for(;null!=n;){if(n instanceof t)return n;n=n.getParent()}return null}function J(e){const t=Q(e,(e=>r(e)&&!e.isInline()));return r(t)||p(4,e.__key),t}const Q=(e,t)=>{let n=e;for(;n!==o()&&null!=n;){if(t(n))return n;n=n.getParent()}return null};function X(e,t,n,o){const r=e=>e instanceof t;return e.registerNodeTransform(t,(e=>{const t=(e=>{const t=e.getChildren();for(let e=0;e<t.length;e++){const n=t[e];if(r(n))return null}let n=e,o=e;for(;null!==n;)if(o=n,n=n.getParent(),r(n))return{child:o,parent:n};return null})(e);if(null!==t){const{child:r,parent:l}=t;if(r.is(e)){o(l,e);const t=r.getNextSiblings(),i=t.length;if(l.insertAfter(r),0!==i){const e=n(l);r.insertAfter(e);for(let n=0;n<i;n++)e.append(t[n])}l.canBeEmpty()||0!==l.getChildrenSize()||l.remove()}}}))}function Y(e,t){const n=new Map,o=e._pendingEditorState;for(const[e,o]of t._nodeMap)n.set(e,l(o));o&&(o._nodeMap=n),e._dirtyType=2;const r=t._selection;i(null===r?null:r.clone())}function Z(n){const r=e()||s();if(t(r)){const{focus:e}=r,t=e.getNode(),o=e.offset;if(u(t)){const e=t.getChildAtIndex(o);null==e?t.append(n):e.insertBefore(n),n.selectNext()}else{let e,r;c(t)?(e=t.getParentOrThrow(),r=t.getIndexWithinParent(),o>0&&(r+=1,t.splitText(o))):(e=t,r=o);const[,l]=f(e,r);l.insertBefore(n),l.selectStart()}}else{if(null!=r){const e=r.getNodes();e[e.length-1].getTopLevelElementOrThrow().insertAfter(n)}else{o().append(n)}const e=a();n.insertAfter(e),e.select()}return n.getLatest()}function ee(e,t){const n=t();return e.replace(n),n.append(e),n}function te(e,t){return null!==e&&Object.getPrototypeOf(e).constructor.name===t.name}function ne(e,t){const n=[];for(let o=0;o<e.length;o++){const r=t(e[o]);null!==r&&n.push(r)}return n}function oe(e,t){const n=e.getFirstChild();null!==n?n.insertBefore(t):e.append(t)}function re(e){if(z)return 1;let t=1;for(;e;)t*=Number(window.getComputedStyle(e).getPropertyValue(\"zoom\")),e=e.parentElement;return t}function le(e){return null!==e._parentEditor}export{V as $dfs,ne as $filter,Q as $findMatchingParent,J as $getNearestBlockElementAncestorOrThrow,G as $getNearestNodeOfType,q as $getNextRightPreorderNode,oe as $insertFirst,Z as $insertNodeToNearestRoot,le as $isEditorIsNestedEditor,Y as $restoreEditorState,ee as $wrapNodeInElement,_ as CAN_USE_BEFORE_INPUT,K as CAN_USE_DOM,O as IS_ANDROID,R as IS_ANDROID_CHROME,I as IS_APPLE,D as IS_APPLE_WEBKIT,H as IS_CHROME,z as IS_FIREFOX,k as IS_IOS,F as IS_SAFARI,$ as addClassNamesToElement,re as calculateZoomLevel,W as isMimeType,B as markSelection,j as mediaFileReader,b as mergeRegister,te as objectKlassEquals,C as positionNodeOnRange,X as registerNestedElementResolver,U as removeClassNamesFromElement};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalUtils.dev.mjs';\nimport * as modProd from './LexicalUtils.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $dfs = mod.$dfs;\nexport const $filter = mod.$filter;\nexport const $findMatchingParent = mod.$findMatchingParent;\nexport const $getNearestBlockElementAncestorOrThrow = mod.$getNearestBlockElementAncestorOrThrow;\nexport const $getNearestNodeOfType = mod.$getNearestNodeOfType;\nexport const $getNextRightPreorderNode = mod.$getNextRightPreorderNode;\nexport const $insertFirst = mod.$insertFirst;\nexport const $insertNodeToNearestRoot = mod.$insertNodeToNearestRoot;\nexport const $isEditorIsNestedEditor = mod.$isEditorIsNestedEditor;\nexport const $restoreEditorState = mod.$restoreEditorState;\nexport const $splitNode = mod.$splitNode;\nexport const $wrapNodeInElement = mod.$wrapNodeInElement;\nexport const CAN_USE_BEFORE_INPUT = mod.CAN_USE_BEFORE_INPUT;\nexport const CAN_USE_DOM = mod.CAN_USE_DOM;\nexport const IS_ANDROID = mod.IS_ANDROID;\nexport const IS_ANDROID_CHROME = mod.IS_ANDROID_CHROME;\nexport const IS_APPLE = mod.IS_APPLE;\nexport const IS_APPLE_WEBKIT = mod.IS_APPLE_WEBKIT;\nexport const IS_CHROME = mod.IS_CHROME;\nexport const IS_FIREFOX = mod.IS_FIREFOX;\nexport const IS_IOS = mod.IS_IOS;\nexport const IS_SAFARI = mod.IS_SAFARI;\nexport const addClassNamesToElement = mod.addClassNamesToElement;\nexport const calculateZoomLevel = mod.calculateZoomLevel;\nexport const isBlockDomNode = mod.isBlockDomNode;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isInlineDomNode = mod.isInlineDomNode;\nexport const isMimeType = mod.isMimeType;\nexport const markSelection = mod.markSelection;\nexport const mediaFileReader = mod.mediaFileReader;\nexport const mergeRegister = mod.mergeRegister;\nexport const objectKlassEquals = mod.objectKlassEquals;\nexport const positionNodeOnRange = mod.positionNodeOnRange;\nexport const registerNestedElementResolver = mod.registerNestedElementResolver;\nexport const removeClassNamesFromElement = mod.removeClassNamesFromElement;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$sliceSelectedTextNodeContent as e}from\"@lexical/selection\";import{isHTMLElement as n,isBlockDomNode as t}from\"@lexical/utils\";import{$getRoot as o,$isElementNode as l,$cloneWithProperties as r,$isTextNode as i,$isRootOrShadowRoot as s,$isBlockElementNode as c,$createLineBreakNode as u,ArtificialNode__DO_NOT_USE as f,isInlineDomNode as a,$createParagraphNode as d}from\"lexical\";function p(e,n){const t=n.body?n.body.childNodes:[];let o=[];const l=[];for(let n=0;n<t.length;n++){const r=t[n];if(!g.has(r.nodeName)){const n=x(r,e,l,!1);null!==n&&(o=o.concat(n))}}return function(e){for(const n of e)n.getNextSibling()instanceof f&&n.insertAfter(u());for(const n of e){const e=n.getChildren();for(const t of e)n.insertBefore(t);n.remove()}}(l),o}function h(e,n){if(\"undefined\"==typeof document||\"undefined\"==typeof window&&void 0===global.window)throw new Error(\"To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.\");const t=document.createElement(\"div\"),l=o().getChildren();for(let o=0;o<l.length;o++){m(e,l[o],t,n)}return t.innerHTML}function m(t,o,s,c=null){let u=null===c||o.isSelected(c);const f=l(o)&&o.excludeFromCopy(\"html\");let a=o;if(null!==c){let n=r(o);n=i(n)&&null!==c?e(c,n):n,a=n}const d=l(a)?a.getChildren():[],p=t._nodes.get(a.getType());let h;h=p&&void 0!==p.exportDOM?p.exportDOM(t,a):a.exportDOM(t);const{element:g,after:x}=h;if(!g)return!1;const y=document.createDocumentFragment();for(let e=0;e<d.length;e++){const n=d[e],r=m(t,n,y,c);!u&&l(o)&&r&&o.extractWithChild(n,c,\"html\")&&(u=!0)}if(u&&!f){if(n(g)&&g.append(y),s.append(g),x){const e=x.call(a,g);e&&g.replaceWith(e)}}else s.append(y);return u}const g=new Set([\"STYLE\",\"SCRIPT\"]);function x(e,n,o,r,i=new Map,p){let h=[];if(g.has(e.nodeName))return h;let m=null;const w=function(e,n){const{nodeName:t}=e,o=n._htmlConversions.get(t.toLowerCase());let l=null;if(void 0!==o)for(const n of o){const t=n(e);null!==t&&(null===l||(l.priority||0)<(t.priority||0))&&(l=t)}return null!==l?l.conversion:null}(e,n),b=w?w(e):null;let C=null;if(null!==b){C=b.after;const n=b.node;if(m=Array.isArray(n)?n[n.length-1]:n,null!==m){for(const[,e]of i)if(m=e(m,p),!m)break;m&&h.push(...Array.isArray(n)?n:[m])}null!=b.forChild&&i.set(e.nodeName,b.forChild)}const S=e.childNodes;let v=[];const N=(null==m||!s(m))&&(null!=m&&c(m)||r);for(let e=0;e<S.length;e++)v.push(...x(S[e],n,o,N,new Map(i),m));return null!=C&&(v=C(v)),t(e)&&(v=y(e,v,N?()=>{const e=new f;return o.push(e),e}:d)),null==m?v.length>0?h=h.concat(v):t(e)&&function(e){if(null==e.nextSibling||null==e.previousSibling)return!1;return a(e.nextSibling)&&a(e.previousSibling)}(e)&&(h=h.concat(u())):l(m)&&m.append(...v),h}function y(e,n,t){const o=e.style.textAlign,l=[];let r=[];for(let e=0;e<n.length;e++){const i=n[e];if(c(i))o&&!i.getFormat()&&i.setFormat(o),l.push(i);else if(r.push(i),e===n.length-1||e<n.length-1&&c(n[e+1])){const e=t();e.setFormat(o),e.append(...r),l.push(e),r=[]}}return l}export{h as $generateHtmlFromNodes,p as $generateNodesFromDOM};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalHtml.dev.mjs';\nimport * as modProd from './LexicalHtml.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateHtmlFromNodes = mod.$generateHtmlFromNodes;\nexport const $generateNodesFromDOM = mod.$generateNodesFromDOM;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, ElementNode, $applyNodeReplacement, $createTextNode, createCommand } from 'lexical';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, removeList };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$getSelection as e,$isRangeSelection as t,$isRootOrShadowRoot as n,$isElementNode as r,$isLeafNode as i,$createParagraphNode as s,$isParagraphNode as o,ElementNode as c,$applyNodeReplacement as l,$createTextNode as a,createCommand as h}from\"lexical\";import{$getNearestNodeOfType as u,removeClassNamesFromElement as g,addClassNamesToElement as f,isHTMLElement as d}from\"@lexical/utils\";function p(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var _=p((function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));function m(e){let t=1,n=e.getParent();for(;null!=n;){if(B(n)){const e=n.getParent();if($(e)){t++,n=e.getParent();continue}_(40)}return t}return t}function v(e){let t=e.getParent();$(t)||_(40);let n=t;for(;null!==n;)n=n.getParent(),$(n)&&(t=n);return t}function y(e){let t=[];const n=e.getChildren().filter(B);for(let e=0;e<n.length;e++){const r=n[e],i=r.getFirstChild();$(i)?t=t.concat(y(i)):t.push(r)}return t}function C(e){return B(e)&&$(e.getFirstChild())}function k(e){return R().append(e)}function T(e,t){return B(e)&&(0===t.length||1===t.length&&e.is(t[0])&&0===e.getChildrenSize())}function b(s,o){s.update((()=>{const s=e();if(null!==s){const e=s.getNodes();if(t(s)){const t=s.getStartEndPoints();null===t&&_(143);const[i]=t,c=i.getNode(),l=c.getParent();if(T(c,e)){const e=U(o);if(n(l)){c.replace(e);const t=R();r(c)&&(t.setFormat(c.getFormatType()),t.setIndent(c.getIndent())),e.append(t)}else if(B(c)){const t=c.getParentOrThrow();S(e,t.getChildren()),t.replace(e)}return}}const c=new Set;for(let t=0;t<e.length;t++){const s=e[t];if(!r(s)||!s.isEmpty()||B(s)||c.has(s.getKey())){if(i(s)){let e=s.getParent();for(;null!=e;){const t=e.getKey();if($(e)){if(!c.has(t)){const n=U(o);S(n,e.getChildren()),e.replace(n),c.add(t)}break}{const r=e.getParent();if(n(r)&&!c.has(t)){c.add(t),P(e,o);break}e=r}}}}else P(s,o)}}}))}function S(e,t){e.splice(e.getChildrenSize(),0,t)}function P(e,t){if($(e))return e;const n=e.getPreviousSibling(),r=e.getNextSibling(),i=R();if(i.setFormat(e.getFormatType()),i.setIndent(e.getIndent()),S(i,e.getChildren()),$(n)&&t===n.getListType())return n.append(i),e.remove(),$(r)&&t===r.getListType()&&(S(n,r.getChildren()),r.remove()),n;if($(r)&&t===r.getListType())return r.getFirstChildOrThrow().insertBefore(i),e.remove(),r;{const n=U(t);return n.append(i),e.replace(n),n}}function A(e,t){const n=e.getLastChild(),r=t.getFirstChild();n&&r&&C(n)&&C(r)&&(A(n.getFirstChild(),r.getFirstChild()),r.remove());const i=t.getChildren();i.length>0&&e.append(...i),t.remove()}function N(n){n.update((()=>{const n=e();if(t(n)){const e=new Set,t=n.getNodes(),r=n.anchor.getNode();if(T(r,t))e.add(v(r));else for(let n=0;n<t.length;n++){const r=t[n];if(i(r)){const t=u(r,M);null!=t&&e.add(v(t))}}for(const t of e){let e=t;const r=y(t);for(const t of r){const r=s();S(r,t.getChildren()),e.insertAfter(r),e=r,t.__key===n.anchor.key&&n.anchor.set(r.getKey(),0,\"element\"),t.__key===n.focus.key&&n.focus.set(r.getKey(),0,\"element\"),t.remove()}t.remove()}}}))}function x(e){const t=new Set;if(C(e)||t.has(e.getKey()))return;const n=e.getParent(),r=e.getNextSibling(),i=e.getPreviousSibling();if(C(r)&&C(i)){const n=i.getFirstChild();if($(n)){n.append(e);const i=r.getFirstChild();if($(i)){S(n,i.getChildren()),r.remove(),t.add(r.getKey())}}}else if(C(r)){const t=r.getFirstChild();if($(t)){const n=t.getFirstChild();null!==n&&n.insertBefore(e)}}else if(C(i)){const t=i.getFirstChild();$(t)&&t.append(e)}else if($(n)){const t=R(),s=U(n.getListType());t.append(s),s.append(e),i?i.insertAfter(t):r?r.insertBefore(t):n.append(t)}}function L(e){if(C(e))return;const t=e.getParent(),n=t?t.getParent():void 0;if($(n?n.getParent():void 0)&&B(n)&&$(t)){const r=t?t.getFirstChild():void 0,i=t?t.getLastChild():void 0;if(e.is(r))n.insertBefore(e),t.isEmpty()&&n.remove();else if(e.is(i))n.insertAfter(e),t.isEmpty()&&n.remove();else{const r=t.getListType(),i=R(),s=U(r);i.append(s),e.getPreviousSiblings().forEach((e=>s.append(e)));const o=R(),c=U(r);o.append(c),S(c,e.getNextSiblings()),n.insertBefore(i),n.insertAfter(o),n.replace(e)}}}function O(){const r=e();if(!t(r)||!r.isCollapsed())return!1;const i=r.anchor.getNode();if(!B(i)||0!==i.getChildrenSize())return!1;const c=v(i),l=i.getParent();$(l)||_(40);const a=l.getParent();let h;if(n(a))h=s(),c.insertAfter(h);else{if(!B(a))return!1;h=R(),a.insertAfter(h)}h.select();const u=i.getNextSiblings();if(u.length>0){const e=U(l.getListType());if(o(h))h.insertAfter(e);else{const t=R();t.append(e),h.insertAfter(t)}u.forEach((t=>{t.remove(),e.append(t)}))}return function(e){let t=e;for(;null==t.getNextSibling()&&null==t.getPreviousSibling();){const e=t.getParent();if(null==e||!B(t)&&!$(t))break;t=e}t.remove()}(i),!0}function E(...e){const t=[];for(const n of e)if(n&&\"string\"==typeof n)for(const[e]of n.matchAll(/\\S+/g))t.push(e);return t}class M extends c{static getType(){return\"listitem\"}static clone(e){return new M(e.__value,e.__checked,e.__key)}constructor(e,t,n){super(n),this.__value=void 0===e?1:e,this.__checked=t}createDOM(e){const t=document.createElement(\"li\"),n=this.getParent();return $(n)&&\"check\"===n.getListType()&&w(t,this,null),t.value=this.__value,F(t,e.theme,this),t}updateDOM(e,t,n){const r=this.getParent();return $(r)&&\"check\"===r.getListType()&&w(t,this,e),t.value=this.__value,F(t,n.theme,this),!1}static transform(){return e=>{if(B(e)||_(144),null==e.__checked)return;const t=e.getParent();$(t)&&\"check\"!==t.getListType()&&null!=e.getChecked()&&e.setChecked(void 0)}}static importDOM(){return{li:()=>({conversion:D,priority:0})}}static importJSON(e){const t=R();return t.setChecked(e.checked),t.setValue(e.value),t.setFormat(e.format),t.setDirection(e.direction),t}exportDOM(e){const t=this.createDOM(e._config);return t.style.textAlign=this.getFormatType(),{element:t}}exportJSON(){return{...super.exportJSON(),checked:this.getChecked(),type:\"listitem\",value:this.getValue(),version:1}}append(...e){for(let t=0;t<e.length;t++){const n=e[t];if(r(n)&&this.canMergeWith(n)){const e=n.getChildren();this.append(...e),n.remove()}else super.append(n)}return this}replace(e,t){if(B(e))return super.replace(e);this.setIndent(0);const n=this.getParentOrThrow();if(!$(n))return e;if(n.__first===this.getKey())n.insertBefore(e);else if(n.__last===this.getKey())n.insertAfter(e);else{const t=U(n.getListType());let r=this.getNextSibling();for(;r;){const e=r;r=r.getNextSibling(),t.append(e)}n.insertAfter(e),e.insertAfter(t)}return t&&(r(e)||_(139),this.getChildren().forEach((t=>{e.append(t)}))),this.remove(),0===n.getChildrenSize()&&n.remove(),e}insertAfter(e,t=!0){const n=this.getParentOrThrow();if($(n)||_(39),B(e))return super.insertAfter(e,t);const r=this.getNextSiblings();if(n.insertAfter(e,t),0!==r.length){const i=U(n.getListType());r.forEach((e=>i.append(e))),e.insertAfter(i,t)}return e}remove(e){const t=this.getPreviousSibling(),n=this.getNextSibling();super.remove(e),t&&n&&C(t)&&C(n)&&(A(t.getFirstChild(),n.getFirstChild()),n.remove())}insertNewAfter(e,t=!0){const n=R(null==this.__checked&&void 0);return this.insertAfter(n,t),n}collapseAtStart(e){const t=s();this.getChildren().forEach((e=>t.append(e)));const n=this.getParentOrThrow(),r=n.getParentOrThrow(),i=B(r);if(1===n.getChildrenSize())if(i)n.remove(),r.select();else{n.insertBefore(t),n.remove();const r=e.anchor,i=e.focus,s=t.getKey();\"element\"===r.type&&r.getNode().is(this)&&r.set(s,r.offset,\"element\"),\"element\"===i.type&&i.getNode().is(this)&&i.set(s,i.offset,\"element\")}else n.insertBefore(t),this.remove();return!0}getValue(){return this.getLatest().__value}setValue(e){this.getWritable().__value=e}getChecked(){const e=this.getLatest();let t;const n=this.getParent();return $(n)&&(t=n.getListType()),\"check\"===t?Boolean(e.__checked):void 0}setChecked(e){this.getWritable().__checked=e}toggleChecked(){this.setChecked(!this.__checked)}getIndent(){const e=this.getParent();if(null===e)return this.getLatest().__indent;let t=e.getParentOrThrow(),n=0;for(;B(t);)t=t.getParentOrThrow().getParentOrThrow(),n++;return n}setIndent(e){\"number\"!=typeof e&&_(117),(e=Math.floor(e))>=0||_(199);let t=this.getIndent();for(;t!==e;)t<e?(x(this),t++):(L(this),t--);return this}canInsertAfter(e){return B(e)}canReplaceWith(e){return B(e)}canMergeWith(e){return o(e)||B(e)}extractWithChild(e,n){if(!t(n))return!1;const r=n.anchor.getNode(),i=n.focus.getNode();return this.isParentOf(r)&&this.isParentOf(i)&&this.getTextContent().length===n.getTextContent().length}isParentRequired(){return!0}createParentElementNode(){return U(\"bullet\")}canMergeWhenEmpty(){return!0}}function F(e,t,n){const r=[],i=[],s=t.list,o=s?s.listitem:void 0;let c;if(s&&s.nested&&(c=s.nested.listitem),void 0!==o&&r.push(...E(o)),s){const e=n.getParent(),t=$(e)&&\"check\"===e.getListType(),o=n.getChecked();t&&!o||i.push(s.listitemUnchecked),t&&o||i.push(s.listitemChecked),t&&r.push(o?s.listitemChecked:s.listitemUnchecked)}if(void 0!==c){const e=E(c);n.getChildren().some((e=>$(e)))?r.push(...e):i.push(...e)}i.length>0&&g(e,...i),r.length>0&&f(e,...r)}function w(e,t,n,r){$(t.getFirstChild())?(e.removeAttribute(\"role\"),e.removeAttribute(\"tabIndex\"),e.removeAttribute(\"aria-checked\")):(e.setAttribute(\"role\",\"checkbox\"),e.setAttribute(\"tabIndex\",\"-1\"),n&&t.__checked===n.__checked||e.setAttribute(\"aria-checked\",t.getChecked()?\"true\":\"false\"))}function D(e){if(e.classList.contains(\"task-list-item\"))for(const t of e.children)if(\"INPUT\"===t.tagName)return I(t);const t=e.getAttribute(\"aria-checked\");return{node:R(\"true\"===t||\"false\"!==t&&void 0)}}function I(e){if(!(\"checkbox\"===e.getAttribute(\"type\")))return{node:null};return{node:R(e.hasAttribute(\"checked\"))}}function R(e){return l(new M(void 0,e))}function B(e){return e instanceof M}class K extends c{static getType(){return\"list\"}static clone(e){const t=e.__listType||z[e.__tag];return new K(t,e.__start,e.__key)}constructor(e,t,n){super(n);const r=z[e]||e;this.__listType=r,this.__tag=\"number\"===r?\"ol\":\"ul\",this.__start=t}getTag(){return this.__tag}setListType(e){const t=this.getWritable();t.__listType=e,t.__tag=\"number\"===e?\"ol\":\"ul\"}getListType(){return this.__listType}getStart(){return this.__start}createDOM(e,t){const n=this.__tag,r=document.createElement(n);return 1!==this.__start&&r.setAttribute(\"start\",String(this.__start)),r.__lexicalListType=this.__listType,W(r,e.theme,this),r}updateDOM(e,t,n){return e.__tag!==this.__tag||(W(t,n.theme,this),!1)}static transform(){return e=>{$(e)||_(163),function(e){const t=e.getNextSibling();$(t)&&e.getListType()===t.getListType()&&A(e,t)}(e),function(e){const t=\"check\"!==e.getListType();let n=e.getStart();for(const r of e.getChildren())B(r)&&(r.getValue()!==n&&r.setValue(n),t&&null!=r.getLatest().__checked&&r.setChecked(void 0),$(r.getFirstChild())||n++)}(e)}}static importDOM(){return{ol:()=>({conversion:J,priority:0}),ul:()=>({conversion:J,priority:0})}}static importJSON(e){const t=U(e.listType,e.start);return t.setFormat(e.format),t.setIndent(e.indent),t.setDirection(e.direction),t}exportDOM(e){const{element:t}=super.exportDOM(e);return t&&d(t)&&(1!==this.__start&&t.setAttribute(\"start\",String(this.__start)),\"check\"===this.__listType&&t.setAttribute(\"__lexicalListType\",\"check\")),{element:t}}exportJSON(){return{...super.exportJSON(),listType:this.getListType(),start:this.getStart(),tag:this.getTag(),type:\"list\",version:1}}canBeEmpty(){return!1}canIndent(){return!1}append(...e){for(let t=0;t<e.length;t++){const n=e[t];if(B(n))super.append(n);else{const e=R();if($(n))e.append(n);else if(r(n)){const t=a(n.getTextContent());e.append(t)}else e.append(n);super.append(e)}}return this}extractWithChild(e){return B(e)}}function W(e,t,n){const r=[],i=[],s=t.list;if(void 0!==s){const e=s[`${n.__tag}Depth`]||[],t=m(n)-1,o=t%e.length,c=e[o],l=s[n.__tag];let a;const h=s.nested,u=s.checklist;if(void 0!==h&&h.list&&(a=h.list),void 0!==l&&r.push(l),void 0!==u&&\"check\"===n.__listType&&r.push(u),void 0!==c){r.push(...E(c));for(let t=0;t<e.length;t++)t!==o&&i.push(n.__tag+t)}if(void 0!==a){const e=E(a);t>1?r.push(...e):i.push(...e)}}i.length>0&&g(e,...i),r.length>0&&f(e,...r)}function V(e){const t=[];for(let n=0;n<e.length;n++){const r=e[n];if(B(r)){t.push(r);const e=r.getChildren();e.length>1&&e.forEach((e=>{$(e)&&t.push(k(e))}))}else t.push(k(r))}return t}function J(e){const t=e.nodeName.toLowerCase();let n=null;if(\"ol\"===t){n=U(\"number\",e.start)}else\"ul\"===t&&(n=function(e){if(\"check\"===e.getAttribute(\"__lexicallisttype\")||e.classList.contains(\"contains-task-list\"))return!0;for(const t of e.childNodes)if(d(t)&&t.hasAttribute(\"aria-checked\"))return!0;return!1}(e)?U(\"check\"):U(\"bullet\"));return{after:V,node:n}}const z={ol:\"number\",ul:\"bullet\"};function U(e,t=1){return l(new K(e,t))}function $(e){return e instanceof K}const j=h(\"INSERT_UNORDERED_LIST_COMMAND\"),q=h(\"INSERT_ORDERED_LIST_COMMAND\"),H=h(\"INSERT_CHECK_LIST_COMMAND\"),G=h(\"REMOVE_LIST_COMMAND\");export{R as $createListItemNode,U as $createListNode,m as $getListDepth,O as $handleListInsertParagraph,B as $isListItemNode,$ as $isListNode,H as INSERT_CHECK_LIST_COMMAND,q as INSERT_ORDERED_LIST_COMMAND,j as INSERT_UNORDERED_LIST_COMMAND,M as ListItemNode,K as ListNode,G as REMOVE_LIST_COMMAND,b as insertList,N as removeList};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalList.dev.mjs';\nimport * as modProd from './LexicalList.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createListItemNode = mod.$createListItemNode;\nexport const $createListNode = mod.$createListNode;\nexport const $getListDepth = mod.$getListDepth;\nexport const $handleListInsertParagraph = mod.$handleListInsertParagraph;\nexport const $isListItemNode = mod.$isListItemNode;\nexport const $isListNode = mod.$isListNode;\nexport const INSERT_CHECK_LIST_COMMAND = mod.INSERT_CHECK_LIST_COMMAND;\nexport const INSERT_ORDERED_LIST_COMMAND = mod.INSERT_ORDERED_LIST_COMMAND;\nexport const INSERT_UNORDERED_LIST_COMMAND = mod.INSERT_UNORDERED_LIST_COMMAND;\nexport const ListItemNode = mod.ListItemNode;\nexport const ListNode = mod.ListNode;\nexport const REMOVE_LIST_COMMAND = mod.REMOVE_LIST_COMMAND;\nexport const insertList = mod.insertList;\nexport const removeList = mod.removeList;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    if (anchor instanceof HTMLAnchorElement) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url, attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url, attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      isUnlinked: serializedNode.isUnlinked,\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked,\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url, attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (!$isAutoLinkNode(parent) && $isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || $isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target,\n          title\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, toggleLink };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{addClassNamesToElement as t,isHTMLAnchorElement as e}from\"@lexical/utils\";import{createCommand as r,ElementNode as i,$isRangeSelection as n,$applyNodeReplacement as l,$isElementNode as s,$getSelection as u}from\"lexical\";const _=new Set([\"http:\",\"https:\",\"mailto:\",\"sms:\",\"tel:\"]);class o extends i{static getType(){return\"link\"}static clone(t){return new o(t.__url,{rel:t.__rel,target:t.__target,title:t.__title},t.__key)}constructor(t,e={},r){super(r);const{target:i=null,rel:n=null,title:l=null}=e;this.__url=t,this.__target=i,this.__rel=n,this.__title=l}createDOM(e){const r=document.createElement(\"a\");return r.href=this.sanitizeUrl(this.__url),null!==this.__target&&(r.target=this.__target),null!==this.__rel&&(r.rel=this.__rel),null!==this.__title&&(r.title=this.__title),t(r,e.theme.link),r}updateDOM(t,e,r){if(e instanceof HTMLAnchorElement){const r=this.__url,i=this.__target,n=this.__rel,l=this.__title;r!==t.__url&&(e.href=r),i!==t.__target&&(i?e.target=i:e.removeAttribute(\"target\")),n!==t.__rel&&(n?e.rel=n:e.removeAttribute(\"rel\")),l!==t.__title&&(l?e.title=l:e.removeAttribute(\"title\"))}return!1}static importDOM(){return{a:t=>({conversion:a,priority:1})}}static importJSON(t){const e=h(t.url,{rel:t.rel,target:t.target,title:t.title});return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}sanitizeUrl(t){try{const e=new URL(t);if(!_.has(e.protocol))return\"about:blank\"}catch(e){return t}return t}exportJSON(){return{...super.exportJSON(),rel:this.getRel(),target:this.getTarget(),title:this.getTitle(),type:\"link\",url:this.getURL(),version:1}}getURL(){return this.getLatest().__url}setURL(t){this.getWritable().__url=t}getTarget(){return this.getLatest().__target}setTarget(t){this.getWritable().__target=t}getRel(){return this.getLatest().__rel}setRel(t){this.getWritable().__rel=t}getTitle(){return this.getLatest().__title}setTitle(t){this.getWritable().__title=t}insertNewAfter(t,e=!0){const r=h(this.__url,{rel:this.__rel,target:this.__target,title:this.__title});return this.insertAfter(r,e),r}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}canBeEmpty(){return!1}isInline(){return!0}extractWithChild(t,e,r){if(!n(e))return!1;const i=e.anchor.getNode(),l=e.focus.getNode();return this.isParentOf(i)&&this.isParentOf(l)&&e.getTextContent().length>0}isEmailURI(){return this.__url.startsWith(\"mailto:\")}isWebSiteURI(){return this.__url.startsWith(\"https://\")||this.__url.startsWith(\"http://\")}}function a(t){let r=null;if(e(t)){const e=t.textContent;(null!==e&&\"\"!==e||t.children.length>0)&&(r=h(t.getAttribute(\"href\")||\"\",{rel:t.getAttribute(\"rel\"),target:t.getAttribute(\"target\"),title:t.getAttribute(\"title\")}))}return{node:r}}function h(t,e){return l(new o(t,e))}function c(t){return t instanceof o}class g extends o{constructor(t,e={},r){super(t,e,r),this.__isUnlinked=void 0!==e.isUnlinked&&null!==e.isUnlinked&&e.isUnlinked}static getType(){return\"autolink\"}static clone(t){return new g(t.__url,{isUnlinked:t.__isUnlinked,rel:t.__rel,target:t.__target,title:t.__title},t.__key)}getIsUnlinked(){return this.__isUnlinked}setIsUnlinked(t){const e=this.getWritable();return e.__isUnlinked=t,e}createDOM(t){return this.__isUnlinked?document.createElement(\"span\"):super.createDOM(t)}updateDOM(t,e,r){return super.updateDOM(t,e,r)||t.__isUnlinked!==this.__isUnlinked}static importJSON(t){const e=f(t.url,{isUnlinked:t.isUnlinked,rel:t.rel,target:t.target,title:t.title});return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}static importDOM(){return null}exportJSON(){return{...super.exportJSON(),isUnlinked:this.__isUnlinked,type:\"autolink\",version:1}}insertNewAfter(t,e=!0){const r=this.getParentOrThrow().insertNewAfter(t,e);if(s(r)){const t=f(this.__url,{isUnlinked:this.__isUnlinked,rel:this.__rel,target:this.__target,title:this.__title});return r.append(t),t}return null}}function f(t,e){return l(new g(t,e))}function d(t){return t instanceof g}const p=r(\"TOGGLE_LINK_COMMAND\");function U(t,e={}){const{target:r,title:i}=e,l=void 0===e.rel?\"noreferrer\":e.rel,_=u();if(!n(_))return;const o=_.extract();if(null===t)o.forEach((t=>{const e=t.getParent();if(!d(e)&&c(e)){const t=e.getChildren();for(let r=0;r<t.length;r++)e.insertBefore(t[r]);e.remove()}}));else{if(1===o.length){const e=function(t,e){let r=t;for(;null!==r&&null!==r.getParent()&&!e(r);)r=r.getParentOrThrow();return e(r)?r:null}(o[0],c);if(null!==e)return e.setURL(t),void 0!==r&&e.setTarget(r),null!==l&&e.setRel(l),void(void 0!==i&&e.setTitle(i))}let e=null,n=null;o.forEach((u=>{const _=u.getParent();if(_!==n&&null!==_&&(!s(u)||u.isInline())){if(c(_))return n=_,_.setURL(t),void 0!==r&&_.setTarget(r),null!==l&&n.setRel(l),void(void 0!==i&&n.setTitle(i));if(_.is(e)||(e=_,n=h(t,{rel:l,target:r,title:i}),c(_)?null===u.getPreviousSibling()?_.insertBefore(n):_.insertAfter(n):u.insertBefore(n)),c(u)){if(u.is(n))return;if(null!==n){const t=u.getChildren();for(let e=0;e<t.length;e++)n.append(t[e])}u.remove()}else null!==n&&n.append(u)}}))}}const m=U;export{f as $createAutoLinkNode,h as $createLinkNode,d as $isAutoLinkNode,c as $isLinkNode,U as $toggleLink,g as AutoLinkNode,o as LinkNode,p as TOGGLE_LINK_COMMAND,m as toggleLink};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalLink.dev.mjs';\nimport * as modProd from './LexicalLink.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createAutoLinkNode = mod.$createAutoLinkNode;\nexport const $createLinkNode = mod.$createLinkNode;\nexport const $isAutoLinkNode = mod.$isAutoLinkNode;\nexport const $isLinkNode = mod.$isLinkNode;\nexport const $toggleLink = mod.$toggleLink;\nexport const AutoLinkNode = mod.AutoLinkNode;\nexport const LinkNode = mod.LinkNode;\nexport const TOGGLE_LINK_COMMAND = mod.TOGGLE_LINK_COMMAND;\nexport const toggleLink = mod.toggleLink;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$generateHtmlFromNodes as t,$generateNodesFromDOM as e}from\"@lexical/html\";import{$addNodeStyle as n,$sliceSelectedTextNodeContent as o}from\"@lexical/selection\";import{objectKlassEquals as r}from\"@lexical/utils\";import{$isRangeSelection as l,$getSelection as i,$createTabNode as c,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as s,$getRoot as a,$parseSerializedNode as u,$isTextNode as d,COPY_COMMAND as f,COMMAND_PRIORITY_CRITICAL as p,isSelectionWithinEditor as m,$getEditor as h,$isElementNode as g,$cloneWithProperties as x}from\"lexical\";function w(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,\"default\")?t.default:t}var y=w((function(t){const e=new URLSearchParams;e.append(\"code\",t);for(let t=1;t<arguments.length;t++)e.append(\"v\",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const v=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,C=t=>v?(t||window).getSelection():null;function D(e,n=i()){return null==n&&y(166),l(n)&&n.isCollapsed()||0===n.getNodes().length?\"\":t(e,n)}function N(t,e=i()){return null==e&&y(166),l(e)&&e.isCollapsed()||0===e.getNodes().length?null:JSON.stringify(R(t,e))}function _(t,e){const n=t.getData(\"text/plain\")||t.getData(\"text/uri-list\");null!=n&&e.insertRawText(n)}function T(t,n,o){const r=t.getData(\"application/x-lexical-editor\");if(r)try{const t=JSON.parse(r);if(t.namespace===o._config.namespace&&Array.isArray(t.nodes)){return S(o,E(t.nodes),n)}}catch(t){}const s=t.getData(\"text/html\");if(s)try{const t=(new DOMParser).parseFromString(s,\"text/html\");return S(o,e(o,t),n)}catch(t){}const a=t.getData(\"text/plain\")||t.getData(\"text/uri-list\");if(null!=a)if(l(n)){const t=a.split(/(\\r?\\n|\\t)/);\"\"===t[t.length-1]&&t.pop();for(let e=0;e<t.length;e++){const n=i();if(l(n)){const o=t[e];\"\\n\"===o||\"\\r\\n\"===o?n.insertParagraph():\"\\t\"===o?n.insertNodes([c()]):n.insertText(o)}}}else n.insertRawText(a)}function S(t,e,n){t.dispatchCommand(s,{nodes:e,selection:n})||n.insertNodes(e)}function A(t,e,n,r=[]){let l=null===e||n.isSelected(e);const i=g(n)&&n.excludeFromCopy(\"html\");let c=n;if(null!==e){let t=x(n);t=d(t)&&null!==e?o(e,t):t,c=t}const s=g(c)?c.getChildren():[],a=function(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&y(58,n.name),g(t)){const t=e.children;Array.isArray(t)||y(59,n.name)}return e}(c);if(d(c)){const t=c.__text;t.length>0?a.text=t:l=!1}for(let o=0;o<s.length;o++){const r=s[o],i=A(t,e,r,a.children);!l&&g(n)&&i&&n.extractWithChild(r,e,\"clone\")&&(l=!0)}if(l&&!i)r.push(a);else if(Array.isArray(a.children))for(let t=0;t<a.children.length;t++){const e=a.children[t];r.push(e)}return l}function R(t,e){const n=[],o=a().getChildren();for(let r=0;r<o.length;r++){A(t,e,o[r],n)}return{namespace:t._config.namespace,nodes:n}}function E(t){const e=[];for(let o=0;o<t.length;o++){const r=t[o],l=u(r);d(l)&&n(l),e.push(l)}return e}let O=null;async function P(t,e,n){if(null!==O)return!1;if(null!==e)return new Promise(((o,r)=>{t.update((()=>{o(b(t,e,n))}))}));const o=t.getRootElement(),l=null==t._window?window.document:t._window.document,i=C(t._window);if(null===o||null===i)return!1;const c=l.createElement(\"span\");c.style.cssText=\"position: fixed; top: -1000px;\",c.append(l.createTextNode(\"#\")),o.append(c);const s=new Range;return s.setStart(c,0),s.setEnd(c,1),i.removeAllRanges(),i.addRange(s),new Promise(((e,o)=>{const i=t.registerCommand(f,(o=>(r(o,ClipboardEvent)&&(i(),null!==O&&(window.clearTimeout(O),O=null),e(b(t,o,n))),!0)),p);O=window.setTimeout((()=>{i(),O=null,e(!1)}),50),l.execCommand(\"copy\"),c.remove()}))}function b(t,e,n){if(void 0===n){const e=C(t._window);if(!e)return!1;const o=e.anchorNode,r=e.focusNode;if(null!==o&&null!==r&&!m(t,o,r))return!1;const l=i();if(null===l)return!1;n=M(l)}e.preventDefault();const o=e.clipboardData;return null!==o&&(F(o,n),!0)}const J=[[\"text/html\",D],[\"application/x-lexical-editor\",N]];function M(t=i()){const e={\"text/plain\":t?t.getTextContent():\"\"};if(t){const n=h();for(const[o,r]of J){const l=r(n,t);null!==l&&(e[o]=l)}}return e}function F(t,e){for(const n in e){const o=e[n];void 0!==o&&t.setData(n,o)}}export{R as $generateJSONFromSelectedNodes,E as $generateNodesFromSerializedNodes,M as $getClipboardDataFromSelection,D as $getHtmlContent,N as $getLexicalContent,_ as $insertDataTransferForPlainText,T as $insertDataTransferForRichText,S as $insertGeneratedNodes,P as copyToClipboard,F as setLexicalClipboardDataTransfer};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalClipboard.dev.mjs';\nimport * as modProd from './LexicalClipboard.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateJSONFromSelectedNodes = mod.$generateJSONFromSelectedNodes;\nexport const $generateNodesFromSerializedNodes = mod.$generateNodesFromSerializedNodes;\nexport const $getClipboardDataFromSelection = mod.$getClipboardDataFromSelection;\nexport const $getHtmlContent = mod.$getHtmlContent;\nexport const $getLexicalContent = mod.$getLexicalContent;\nexport const $insertDataTransferForPlainText = mod.$insertDataTransferForPlainText;\nexport const $insertDataTransferForRichText = mod.$insertDataTransferForRichText;\nexport const $insertGeneratedNodes = mod.$insertGeneratedNodes;\nexport const copyToClipboard = mod.copyToClipboard;\nexport const setLexicalClipboardDataTransfer = mod.setLexicalClipboardDataTransfer;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{mergeRegister as t}from\"@lexical/utils\";import{UNDO_COMMAND as e,COMMAND_PRIORITY_EDITOR as n,REDO_COMMAND as r,CLEAR_EDITOR_COMMAND as o,CLEAR_HISTORY_COMMAND as i,CAN_REDO_COMMAND as s,CAN_UNDO_COMMAND as c,$isRangeSelection as a,$isTextNode as u,$isRootNode as d}from\"lexical\";const l=0,f=1,p=2,h=0,m=1,g=2,_=3,S=4;function y(t,e,n,r,o){if(null===t||0===n.size&&0===r.size&&!o)return h;const i=e._selection,s=t._selection;if(o)return m;if(!(a(i)&&a(s)&&s.isCollapsed()&&i.isCollapsed()))return h;const c=function(t,e,n){const r=t._nodeMap,o=[];for(const t of e){const e=r.get(t);void 0!==e&&o.push(e)}for(const[t,e]of n){if(!e)continue;const n=r.get(t);void 0===n||d(n)||o.push(n)}return o}(e,n,r);if(0===c.length)return h;if(c.length>1){const n=e._nodeMap,r=n.get(i.anchor.key),o=n.get(s.anchor.key);return r&&o&&!t._nodeMap.has(r.__key)&&u(r)&&1===r.__text.length&&1===i.anchor.offset?g:h}const l=c[0],f=t._nodeMap.get(l.__key);if(!u(f)||!u(l)||f.__mode!==l.__mode)return h;const p=f.__text,y=l.__text;if(p===y)return h;const k=i.anchor,C=s.anchor;if(k.key!==C.key||\"text\"!==k.type)return h;const x=k.offset,M=C.offset,z=y.length-p.length;return 1===z&&M===x-1?g:-1===z&&M===x+1?_:-1===z&&M===x?S:h}function k(t,e){let n=Date.now(),r=h;return(o,i,s,c,d,m)=>{const g=Date.now();if(m.has(\"historic\"))return r=h,n=g,p;const _=y(o,i,c,d,t.isComposing()),S=(()=>{const S=null===s||s.editor===t,y=m.has(\"history-push\");if(!y&&S&&m.has(\"history-merge\"))return l;if(null===o)return f;const k=i._selection;if(!(c.size>0||d.size>0))return null!==k?l:p;if(!1===y&&_!==h&&_===r&&g<n+e&&S)return l;if(1===c.size){if(function(t,e,n){const r=e._nodeMap.get(t),o=n._nodeMap.get(t),i=e._selection,s=n._selection;return!(a(i)&&a(s)&&\"element\"===i.anchor.type&&\"element\"===i.focus.type&&\"text\"===s.anchor.type&&\"text\"===s.focus.type||!u(r)||!u(o)||r.__parent!==o.__parent)&&JSON.stringify(e.read((()=>r.exportJSON())))===JSON.stringify(n.read((()=>o.exportJSON())))}(Array.from(c)[0],o,i))return l}return f})();return n=g,r=_,S}}function C(t){t.undoStack=[],t.redoStack=[],t.current=null}function x(a,u,d){const l=k(a,d),h=t(a.registerCommand(e,(()=>(function(t,e){const n=e.redoStack,r=e.undoStack;if(0!==r.length){const o=e.current,i=r.pop();null!==o&&(n.push(o),t.dispatchCommand(s,!0)),0===r.length&&t.dispatchCommand(c,!1),e.current=i||null,i&&i.editor.setEditorState(i.editorState,{tag:\"historic\"})}}(a,u),!0)),n),a.registerCommand(r,(()=>(function(t,e){const n=e.redoStack,r=e.undoStack;if(0!==n.length){const o=e.current;null!==o&&(r.push(o),t.dispatchCommand(c,!0));const i=n.pop();0===n.length&&t.dispatchCommand(s,!1),e.current=i||null,i&&i.editor.setEditorState(i.editorState,{tag:\"historic\"})}}(a,u),!0)),n),a.registerCommand(o,(()=>(C(u),!1)),n),a.registerCommand(i,(()=>(C(u),a.dispatchCommand(s,!1),a.dispatchCommand(c,!1),!0)),n),a.registerUpdateListener((({editorState:t,prevEditorState:e,dirtyLeaves:n,dirtyElements:r,tags:o})=>{const i=u.current,d=u.redoStack,h=u.undoStack,m=null===i?null:i.editorState;if(null!==i&&t===m)return;const g=l(e,t,i,n,r,o);if(g===f)0!==d.length&&(u.redoStack=[],a.dispatchCommand(s,!1)),null!==i&&(h.push({...i}),a.dispatchCommand(c,!0));else if(g===p)return;u.current={editor:a,editorState:t}})));return h}function M(){return{current:null,redoStack:[],undoStack:[]}}export{M as createEmptyHistoryState,x as registerHistory};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalHistory.dev.mjs';\nimport * as modProd from './LexicalHistory.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const createEmptyHistoryState = mod.createEmptyHistoryState;\nexport const registerHistory = mod.registerHistory;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$getRoot as t,$isDecoratorNode as e,$isElementNode as n,$isParagraphNode as r,$isTextNode as i,TextNode as o,$createTextNode as l}from\"lexical\";function s(){return t().getTextContent()}function u(t,e=!0){if(t)return!1;let n=s();return e&&(n=n.trim()),\"\"===n}function f(t,e){return()=>u(t,e)}function c(o){if(!u(o,!1))return!1;const l=t().getChildren(),s=l.length;if(s>1)return!1;for(let t=0;t<s;t++){const o=l[t];if(e(o))return!1;if(n(o)){if(!r(o))return!1;if(0!==o.__indent)return!1;const e=o.getChildren(),n=e.length;for(let r=0;r<n;r++){const n=e[t];if(!i(n))return!1}}}return!0}function g(t){return()=>c(t)}function a(t,e){let r=t.getFirstChild(),o=0;t:for(;null!==r;){if(n(r)){const t=r.getFirstChild();if(null!==t){r=t;continue}}else if(i(r)){const t=r.getTextContentSize();if(o+t>e)return{node:r,offset:e-o};o+=t}const t=r.getNextSibling();if(null!==t){r=t;continue}let l=r.getParent();for(;null!==l;){const t=l.getNextSibling();if(null!==t){r=t;continue t}l=l.getParent()}break}return null}function d(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,\"default\")?t.default:t}var x=d((function(t){const e=new URLSearchParams;e.append(\"code\",t);for(let t=1;t<arguments.length;t++)e.append(\"v\",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));function T(t,e,n,r){const s=t=>t instanceof n,u=t=>{const e=l(t.getTextContent());e.setFormat(t.getFormat()),t.replace(e)};return[t.registerNodeTransform(o,(t=>{if(!t.isSimpleText())return;let n,o=t.getPreviousSibling(),l=t.getTextContent(),f=t;if(i(o)){const n=o.getTextContent(),r=e(n+l);if(s(o)){if(null===r||0!==(t=>t.getLatest().__mode)(o))return void u(o);{const e=r.end-n.length;if(e>0){const r=n+l.slice(0,e);if(o.select(),o.setTextContent(r),e===l.length)t.remove();else{const n=l.slice(e);t.setTextContent(n)}return}}}else if(null===r||r.start<n.length)return}let c=0;for(;;){n=e(l);let t,g=null===n?\"\":l.slice(n.end);if(l=g,\"\"===g){const t=f.getNextSibling();if(i(t)){g=f.getTextContent()+t.getTextContent();const n=e(g);if(null===n)return void(s(t)?u(t):t.markDirty());if(0!==n.start)return}}if(null===n)return;if(0===n.start&&i(o)&&o.isTextEntity()){c+=n.end;continue}0===n.start?[t,f]=f.splitText(n.end):[,t,f]=f.splitText(n.start+c,n.end+c),void 0===t&&x(165,\"nodeToReplace\");const a=r(t);if(a.setFormat(t.getFormat()),t.replace(a),null==f)return;c=0,o=a}})),t.registerNodeTransform(n,(t=>{const n=t.getTextContent(),r=e(n);if(null===r||0!==r.start)return void u(t);if(n.length>r.end)return void t.splitText(r.end);const o=t.getPreviousSibling();i(o)&&o.isTextEntity()&&(u(o),u(t));const l=t.getNextSibling();i(l)&&l.isTextEntity()&&(u(l),s(t)&&u(t))}))]}export{c as $canShowPlaceholder,g as $canShowPlaceholderCurry,a as $findTextIntersectionFromCharacters,u as $isRootTextContentEmpty,f as $isRootTextContentEmptyCurry,s as $rootTextContent,T as registerLexicalTextEntity};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalText.dev.mjs';\nimport * as modProd from './LexicalText.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $canShowPlaceholder = mod.$canShowPlaceholder;\nexport const $canShowPlaceholderCurry = mod.$canShowPlaceholderCurry;\nexport const $findTextIntersectionFromCharacters = mod.$findTextIntersectionFromCharacters;\nexport const $isRootTextContentEmpty = mod.$isRootTextContentEmpty;\nexport const $isRootTextContentEmptyCurry = mod.$isRootTextContentEmptyCurry;\nexport const $rootTextContent = mod.$rootTextContent;\nexport const registerLexicalTextEntity = mod.registerLexicalTextEntity;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $createParagraphNode, $applyNodeReplacement, CLICK_COMMAND, $getSelection, $isNodeSelection, DELETE_CHARACTER_COMMAND, $isRangeSelection, COMMAND_PRIORITY_EDITOR, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, $isRootNode, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isSelectionCapturedInDecoratorInput, $getRoot } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !$isRootNode(anchorNode)) {\n      const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{$insertDataTransferForRichText as t,copyToClipboard as e}from\"@lexical/clipboard\";import{$shouldOverrideDefaultCharacterSelection as n,$moveCharacter as r}from\"@lexical/selection\";import{addClassNamesToElement as o,isHTMLElement as i,objectKlassEquals as s,mergeRegister as c,$findMatchingParent as a,$getNearestBlockElementAncestorOrThrow as u}from\"@lexical/utils\";import{createCommand as l,ElementNode as d,$createParagraphNode as m,$applyNodeReplacement as f,CLICK_COMMAND as g,$getSelection as p,$isNodeSelection as h,DELETE_CHARACTER_COMMAND as C,$isRangeSelection as y,COMMAND_PRIORITY_EDITOR as v,DELETE_WORD_COMMAND as D,DELETE_LINE_COMMAND as x,CONTROLLED_TEXT_INSERTION_COMMAND as w,REMOVE_TEXT_COMMAND as E,FORMAT_TEXT_COMMAND as N,FORMAT_ELEMENT_COMMAND as I,$isElementNode as O,INSERT_LINE_BREAK_COMMAND as T,INSERT_PARAGRAPH_COMMAND as A,INSERT_TAB_COMMAND as P,$insertNodes as S,$createTabNode as _,INDENT_CONTENT_COMMAND as M,OUTDENT_CONTENT_COMMAND as b,KEY_ARROW_UP_COMMAND as F,$getAdjacentNode as K,$isDecoratorNode as k,KEY_ARROW_DOWN_COMMAND as J,KEY_ARROW_LEFT_COMMAND as L,KEY_ARROW_RIGHT_COMMAND as q,KEY_BACKSPACE_COMMAND as R,$isRootNode as W,KEY_DELETE_COMMAND as z,KEY_ENTER_COMMAND as X,KEY_ESCAPE_COMMAND as Y,DROP_COMMAND as B,$getNearestNodeFromDOMNode as G,$createRangeSelection as V,$isTextNode as j,$normalizeSelection__EXPERIMENTAL as H,$setSelection as Q,DRAGSTART_COMMAND as U,DRAGOVER_COMMAND as Z,SELECT_ALL_COMMAND as $,$selectAll as tt,COPY_COMMAND as et,CUT_COMMAND as nt,PASTE_COMMAND as rt,isSelectionCapturedInDecoratorInput as ot,$getRoot as it}from\"lexical\";function st(t,e){if(void 0!==document.caretRangeFromPoint){const n=document.caretRangeFromPoint(t,e);return null===n?null:{node:n.startContainer,offset:n.startOffset}}if(\"undefined\"!==document.caretPositionFromPoint){const n=document.caretPositionFromPoint(t,e);return null===n?null:{node:n.offsetNode,offset:n.offset}}return null}const ct=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,at=ct&&\"documentMode\"in document?document.documentMode:null,ut=!(!ct||!(\"InputEvent\"in window)||at)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),lt=ct&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),dt=ct&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,mt=ct&&/^(?=.*Chrome).*/i.test(navigator.userAgent),ft=ct&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!mt,gt=l(\"DRAG_DROP_PASTE_FILE\");class pt extends d{static getType(){return\"quote\"}static clone(t){return new pt(t.__key)}constructor(t){super(t)}createDOM(t){const e=document.createElement(\"blockquote\");return o(e,t.theme.quote),e}updateDOM(t,e){return!1}static importDOM(){return{blockquote:t=>({conversion:xt,priority:0})}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&i(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n)}return{element:e}}static importJSON(t){const e=ht();return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{...super.exportJSON(),type:\"quote\"}}insertNewAfter(t,e){const n=m(),r=this.getDirection();return n.setDirection(r),this.insertAfter(n,e),n}collapseAtStart(){const t=m();return this.getChildren().forEach((e=>t.append(e))),this.replace(t),!0}canMergeWhenEmpty(){return!0}}function ht(){return f(new pt)}function Ct(t){return t instanceof pt}class yt extends d{static getType(){return\"heading\"}static clone(t){return new yt(t.__tag,t.__key)}constructor(t,e){super(e),this.__tag=t}getTag(){return this.__tag}createDOM(t){const e=this.__tag,n=document.createElement(e),r=t.theme.heading;if(void 0!==r){const t=r[e];o(n,t)}return n}updateDOM(t,e){return!1}static importDOM(){return{h1:t=>({conversion:Dt,priority:0}),h2:t=>({conversion:Dt,priority:0}),h3:t=>({conversion:Dt,priority:0}),h4:t=>({conversion:Dt,priority:0}),h5:t=>({conversion:Dt,priority:0}),h6:t=>({conversion:Dt,priority:0}),p:t=>{const e=t.firstChild;return null!==e&&vt(e)?{conversion:()=>({node:null}),priority:3}:null},span:t=>vt(t)?{conversion:t=>({node:wt(\"h1\")}),priority:3}:null}}exportDOM(t){const{element:e}=super.exportDOM(t);if(e&&i(e)){this.isEmpty()&&e.append(document.createElement(\"br\"));const t=this.getFormatType();e.style.textAlign=t;const n=this.getDirection();n&&(e.dir=n)}return{element:e}}static importJSON(t){const e=wt(t.tag);return e.setFormat(t.format),e.setIndent(t.indent),e.setDirection(t.direction),e}exportJSON(){return{...super.exportJSON(),tag:this.getTag(),type:\"heading\",version:1}}insertNewAfter(t,e=!0){const n=t?t.anchor.offset:0,r=this.getLastDescendant(),o=!r||t&&t.anchor.key===r.getKey()&&n===r.getTextContentSize()||!t?m():wt(this.getTag()),i=this.getDirection();if(o.setDirection(i),this.insertAfter(o,e),0===n&&!this.isEmpty()&&t){const t=m();t.select(),this.replace(t,!0)}return o}collapseAtStart(){const t=this.isEmpty()?m():wt(this.getTag());return this.getChildren().forEach((e=>t.append(e))),this.replace(t),!0}extractWithChild(){return!0}}function vt(t){return\"span\"===t.nodeName.toLowerCase()&&\"26pt\"===t.style.fontSize}function Dt(t){const e=t.nodeName.toLowerCase();let n=null;return\"h1\"!==e&&\"h2\"!==e&&\"h3\"!==e&&\"h4\"!==e&&\"h5\"!==e&&\"h6\"!==e||(n=wt(e),null!==t.style&&n.setFormat(t.style.textAlign)),{node:n}}function xt(t){const e=ht();return null!==t.style&&e.setFormat(t.style.textAlign),{node:e}}function wt(t){return f(new yt(t))}function Et(t){return t instanceof yt}function Nt(t){let e=null;if(s(t,DragEvent)?e=t.dataTransfer:s(t,ClipboardEvent)&&(e=t.clipboardData),null===e)return[!1,[],!1];const n=e.types,r=n.includes(\"Files\"),o=n.includes(\"text/html\")||n.includes(\"text/plain\");return[r,Array.from(e.files),o]}function It(t){const e=p();if(!y(e))return!1;const n=new Set,r=e.getNodes();for(let e=0;e<r.length;e++){const o=r[e],i=o.getKey();if(n.has(i))continue;const s=a(o,(t=>O(t)&&!t.isInline()));if(null===s)continue;const c=s.getKey();s.canIndent()&&!n.has(c)&&(n.add(c),t(s))}return n.size>0}function Ot(t){const e=G(t);return k(e)}function Tt(o){return c(o.registerCommand(g,(t=>{const e=p();return!!h(e)&&(e.clear(),!0)}),0),o.registerCommand(C,(t=>{const e=p();return!!y(e)&&(e.deleteCharacter(t),!0)}),v),o.registerCommand(D,(t=>{const e=p();return!!y(e)&&(e.deleteWord(t),!0)}),v),o.registerCommand(x,(t=>{const e=p();return!!y(e)&&(e.deleteLine(t),!0)}),v),o.registerCommand(w,(e=>{const n=p();if(\"string\"==typeof e)null!==n&&n.insertText(e);else{if(null===n)return!1;const r=e.dataTransfer;if(null!=r)t(r,n,o);else if(y(n)){const t=e.data;return t&&n.insertText(t),!0}}return!0}),v),o.registerCommand(E,(()=>{const t=p();return!!y(t)&&(t.removeText(),!0)}),v),o.registerCommand(N,(t=>{const e=p();return!!y(e)&&(e.formatText(t),!0)}),v),o.registerCommand(I,(t=>{const e=p();if(!y(e)&&!h(e))return!1;const n=e.getNodes();for(const e of n){const n=a(e,(t=>O(t)&&!t.isInline()));null!==n&&n.setFormat(t)}return!0}),v),o.registerCommand(T,(t=>{const e=p();return!!y(e)&&(e.insertLineBreak(t),!0)}),v),o.registerCommand(A,(()=>{const t=p();return!!y(t)&&(t.insertParagraph(),!0)}),v),o.registerCommand(P,(()=>(S([_()]),!0)),v),o.registerCommand(M,(()=>It((t=>{const e=t.getIndent();t.setIndent(e+1)}))),v),o.registerCommand(b,(()=>It((t=>{const e=t.getIndent();e>0&&t.setIndent(e-1)}))),v),o.registerCommand(F,(t=>{const e=p();if(h(e)&&!Ot(t.target)){const t=e.getNodes();if(t.length>0)return t[0].selectPrevious(),!0}else if(y(e)){const n=K(e.focus,!0);if(!t.shiftKey&&k(n)&&!n.isIsolated()&&!n.isInline())return n.selectPrevious(),t.preventDefault(),!0}return!1}),v),o.registerCommand(J,(t=>{const e=p();if(h(e)){const t=e.getNodes();if(t.length>0)return t[0].selectNext(0,0),!0}else if(y(e)){if(function(t){const e=t.focus;return\"root\"===e.key&&e.offset===it().getChildrenSize()}(e))return t.preventDefault(),!0;const n=K(e.focus,!1);if(!t.shiftKey&&k(n)&&!n.isIsolated()&&!n.isInline())return n.selectNext(),t.preventDefault(),!0}return!1}),v),o.registerCommand(L,(t=>{const e=p();if(h(e)){const n=e.getNodes();if(n.length>0)return t.preventDefault(),n[0].selectPrevious(),!0}if(!y(e))return!1;if(n(e,!0)){const n=t.shiftKey;return t.preventDefault(),r(e,n,!0),!0}return!1}),v),o.registerCommand(q,(t=>{const e=p();if(h(e)&&!Ot(t.target)){const n=e.getNodes();if(n.length>0)return t.preventDefault(),n[0].selectNext(0,0),!0}if(!y(e))return!1;const o=t.shiftKey;return!!n(e,!1)&&(t.preventDefault(),r(e,o,!1),!0)}),v),o.registerCommand(R,(t=>{if(Ot(t.target))return!1;const e=p();if(!y(e))return!1;t.preventDefault();const{anchor:n}=e,r=n.getNode();if(e.isCollapsed()&&0===n.offset&&!W(r)){if(u(r).getIndent()>0)return o.dispatchCommand(b,void 0)}return o.dispatchCommand(C,!0)}),v),o.registerCommand(z,(t=>{if(Ot(t.target))return!1;const e=p();return!!y(e)&&(t.preventDefault(),o.dispatchCommand(C,!1))}),v),o.registerCommand(X,(t=>{const e=p();if(!y(e))return!1;if(null!==t){if((dt||lt||ft)&&ut)return!1;if(t.preventDefault(),t.shiftKey)return o.dispatchCommand(T,!1)}return o.dispatchCommand(A,void 0)}),v),o.registerCommand(Y,(()=>{const t=p();return!!y(t)&&(o.blur(),!0)}),v),o.registerCommand(B,(t=>{const[,e]=Nt(t);if(e.length>0){const n=st(t.clientX,t.clientY);if(null!==n){const{offset:t,node:r}=n,i=G(r);if(null!==i){const e=V();if(j(i))e.anchor.set(i.getKey(),t,\"text\"),e.focus.set(i.getKey(),t,\"text\");else{const t=i.getParentOrThrow().getKey(),n=i.getIndexWithinParent()+1;e.anchor.set(t,n,\"element\"),e.focus.set(t,n,\"element\")}const n=H(e);Q(n)}o.dispatchCommand(gt,e)}return t.preventDefault(),!0}const n=p();return!!y(n)}),v),o.registerCommand(U,(t=>{const[e]=Nt(t),n=p();return!(e&&!y(n))}),v),o.registerCommand(Z,(t=>{const[e]=Nt(t),n=p();if(e&&!y(n))return!1;const r=st(t.clientX,t.clientY);if(null!==r){const e=G(r.node);k(e)&&t.preventDefault()}return!0}),v),o.registerCommand($,(()=>(tt(),!0)),v),o.registerCommand(et,(t=>(e(o,s(t,ClipboardEvent)?t:null),!0)),v),o.registerCommand(nt,(t=>(async function(t,n){await e(n,s(t,ClipboardEvent)?t:null),n.update((()=>{const t=p();y(t)?t.removeText():h(t)&&t.getNodes().forEach((t=>t.remove()))}))}(t,o),!0)),v),o.registerCommand(rt,(e=>{const[,n,r]=Nt(e);if(n.length>0&&!r)return o.dispatchCommand(gt,n),!0;if(ot(e.target))return!1;return null!==p()&&(function(e,n){e.preventDefault(),n.update((()=>{const r=p(),o=s(e,InputEvent)||s(e,KeyboardEvent)?null:e.clipboardData;null!=o&&null!==r&&t(o,r,n)}),{tag:\"paste\"})}(e,o),!0)}),v))}export{wt as $createHeadingNode,ht as $createQuoteNode,Et as $isHeadingNode,Ct as $isQuoteNode,gt as DRAG_DROP_PASTE,yt as HeadingNode,pt as QuoteNode,Nt as eventFiles,Tt as registerRichText};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalRichText.dev.mjs';\nimport * as modProd from './LexicalRichText.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $createHeadingNode = mod.$createHeadingNode;\nexport const $createQuoteNode = mod.$createQuoteNode;\nexport const $isHeadingNode = mod.$isHeadingNode;\nexport const $isQuoteNode = mod.$isQuoteNode;\nexport const DRAG_DROP_PASTE = mod.DRAG_DROP_PASTE;\nexport const HeadingNode = mod.HeadingNode;\nexport const QuoteNode = mod.QuoteNode;\nexport const eventFiles = mod.eventFiles;\nexport const registerRichText = mod.registerRichText;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $normalizeSelection__EXPERIMENTAL, $getNodeByKey, isCurrentlyReadOnlyMode, $setSelection, SELECTION_CHANGE_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $getRoot, KEY_ARROW_DOWN_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, COMMAND_PRIORITY_CRITICAL, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = style.textDecoration.split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA !== null && cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB !== null && cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected GridNode children to be TableRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          $setSelection(this.tableSelection);\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = $createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      $setSelection(selection);\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove: onMouseMove,\n      onMouseUp: onMouseUp\n    };\n  };\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      const nodes = selection ? selection.getNodes() : null;\n      if (nodes) {\n        const table = nodes.find(node => $isTableNode(node) && node.getKey() === tableObserver.tableNodeKey);\n        if ($isTableNode(table)) {\n          const parentNode = table.getParent();\n          if (!parentNode) {\n            return false;\n          }\n          table.remove();\n        }\n      }\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_BACKSPACE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_DELETE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findMatchingParent(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          const focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableObserverFromTableElement };\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport{addClassNamesToElement as e,$findMatchingParent as t,removeClassNamesFromElement as n,objectKlassEquals as o,isHTMLElement as r}from\"@lexical/utils\";import{ElementNode as l,$createParagraphNode as s,$isElementNode as i,$isLineBreakNode as c,$isTextNode as a,$applyNodeReplacement as d,createCommand as u,$createTextNode as h,$getSelection as g,$isRangeSelection as f,$createPoint as m,$normalizeSelection__EXPERIMENTAL as p,$getNodeByKey as C,isCurrentlyReadOnlyMode as S,$setSelection as _,SELECTION_CHANGE_COMMAND as w,$getNearestNodeFromDOMNode as b,$createRangeSelection as y,$getRoot as N,KEY_ARROW_DOWN_COMMAND as T,COMMAND_PRIORITY_HIGH as x,KEY_ARROW_UP_COMMAND as v,KEY_ARROW_LEFT_COMMAND as E,KEY_ARROW_RIGHT_COMMAND as O,KEY_ESCAPE_COMMAND as M,DELETE_WORD_COMMAND as R,DELETE_LINE_COMMAND as K,DELETE_CHARACTER_COMMAND as F,COMMAND_PRIORITY_CRITICAL as k,KEY_BACKSPACE_COMMAND as A,KEY_DELETE_COMMAND as H,CUT_COMMAND as D,FORMAT_TEXT_COMMAND as P,FORMAT_ELEMENT_COMMAND as B,CONTROLLED_TEXT_INSERTION_COMMAND as L,KEY_TAB_COMMAND as I,FOCUS_COMMAND as W,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as U,$getPreviousSelection as z,$createRangeSelectionFromDom as Y,INSERT_PARAGRAPH_COMMAND as X,$isRootOrShadowRoot as J,$isDecoratorNode as $}from\"lexical\";import{copyToClipboard as j,$getClipboardDataFromSelection as q}from\"@lexical/clipboard\";const G=/^(\\d+(?:\\.\\d+)?)px$/,Q={BOTH:3,COLUMN:2,NO_STATUS:0,ROW:1};class V extends l{static getType(){return\"tablecell\"}static clone(e){const t=new V(e.__headerState,e.__colSpan,e.__width,e.__key);return t.__rowSpan=e.__rowSpan,t.__backgroundColor=e.__backgroundColor,t}static importDOM(){return{td:e=>({conversion:Z,priority:0}),th:e=>({conversion:Z,priority:0})}}static importJSON(e){const t=e.colSpan||1,n=e.rowSpan||1,o=ee(e.headerState,t,e.width||void 0);return o.__rowSpan=n,o.__backgroundColor=e.backgroundColor||null,o}constructor(e=Q.NO_STATUS,t=1,n,o){super(o),this.__colSpan=t,this.__rowSpan=1,this.__headerState=e,this.__width=n,this.__backgroundColor=null}createDOM(t){const n=document.createElement(this.getTag());return this.__width&&(n.style.width=`${this.__width}px`),this.__colSpan>1&&(n.colSpan=this.__colSpan),this.__rowSpan>1&&(n.rowSpan=this.__rowSpan),null!==this.__backgroundColor&&(n.style.backgroundColor=this.__backgroundColor),e(n,t.theme.tableCell,this.hasHeader()&&t.theme.tableCellHeader),n}exportDOM(e){const{element:t}=super.exportDOM(e);if(t){const e=t;e.style.border=\"1px solid black\",this.__colSpan>1&&(e.colSpan=this.__colSpan),this.__rowSpan>1&&(e.rowSpan=this.__rowSpan),e.style.width=`${this.getWidth()||75}px`,e.style.verticalAlign=\"top\",e.style.textAlign=\"start\";const n=this.getBackgroundColor();null!==n?e.style.backgroundColor=n:this.hasHeader()&&(e.style.backgroundColor=\"#f2f3f5\")}return{element:t}}exportJSON(){return{...super.exportJSON(),backgroundColor:this.getBackgroundColor(),colSpan:this.__colSpan,headerState:this.__headerState,rowSpan:this.__rowSpan,type:\"tablecell\",width:this.getWidth()}}getColSpan(){return this.__colSpan}setColSpan(e){return this.getWritable().__colSpan=e,this}getRowSpan(){return this.__rowSpan}setRowSpan(e){return this.getWritable().__rowSpan=e,this}getTag(){return this.hasHeader()?\"th\":\"td\"}setHeaderStyles(e){return this.getWritable().__headerState=e,this.__headerState}getHeaderStyles(){return this.getLatest().__headerState}setWidth(e){return this.getWritable().__width=e,this.__width}getWidth(){return this.getLatest().__width}getBackgroundColor(){return this.getLatest().__backgroundColor}setBackgroundColor(e){this.getWritable().__backgroundColor=e}toggleHeaderStyle(e){const t=this.getWritable();return(t.__headerState&e)===e?t.__headerState-=e:t.__headerState+=e,t}hasHeaderState(e){return(this.getHeaderStyles()&e)===e}hasHeader(){return this.getLatest().__headerState!==Q.NO_STATUS}updateDOM(e){return e.__headerState!==this.__headerState||e.__width!==this.__width||e.__colSpan!==this.__colSpan||e.__rowSpan!==this.__rowSpan||e.__backgroundColor!==this.__backgroundColor}isShadowRoot(){return!0}collapseAtStart(){return!0}canBeEmpty(){return!1}canIndent(){return!1}}function Z(e){const t=e,n=e.nodeName.toLowerCase();let o;G.test(t.style.width)&&(o=parseFloat(t.style.width));const r=ee(\"th\"===n?Q.ROW:Q.NO_STATUS,t.colSpan,o);r.__rowSpan=t.rowSpan;const l=t.style.backgroundColor;\"\"!==l&&(r.__backgroundColor=l);const d=t.style,u=d.textDecoration.split(\" \"),h=\"700\"===d.fontWeight||\"bold\"===d.fontWeight,g=u.includes(\"line-through\"),f=\"italic\"===d.fontStyle,m=u.includes(\"underline\");return{after:e=>(0===e.length&&e.push(s()),e),forChild:(e,t)=>{if(te(t)&&!i(e)){const t=s();return c(e)&&\"\\n\"===e.getTextContent()?null:(a(e)&&(h&&e.toggleFormat(\"bold\"),g&&e.toggleFormat(\"strikethrough\"),f&&e.toggleFormat(\"italic\"),m&&e.toggleFormat(\"underline\")),t.append(e),t)}return e},node:r}}function ee(e,t=1,n){return d(new V(e,t,n))}function te(e){return e instanceof V}const ne=u(\"INSERT_TABLE_COMMAND\");class oe extends l{static getType(){return\"tablerow\"}static clone(e){return new oe(e.__height,e.__key)}static importDOM(){return{tr:e=>({conversion:re,priority:0})}}static importJSON(e){return le(e.height)}constructor(e,t){super(t),this.__height=e}exportJSON(){return{...super.exportJSON(),...this.getHeight()&&{height:this.getHeight()},type:\"tablerow\",version:1}}createDOM(t){const n=document.createElement(\"tr\");return this.__height&&(n.style.height=`${this.__height}px`),e(n,t.theme.tableRow),n}isShadowRoot(){return!0}setHeight(e){return this.getWritable().__height=e,this.__height}getHeight(){return this.getLatest().__height}updateDOM(e){return e.__height!==this.__height}canBeEmpty(){return!1}canIndent(){return!1}}function re(e){const t=e;let n;return G.test(t.style.height)&&(n=parseFloat(t.style.height)),{node:le(n)}}function le(e){return d(new oe(e))}function se(e){return e instanceof oe}function ie(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var ce=ie((function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const ae=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement;function de(e,t,n=!0){const o=at();for(let r=0;r<e;r++){const e=le();for(let o=0;o<t;o++){let t=Q.NO_STATUS;\"object\"==typeof n?(0===r&&n.rows&&(t|=Q.ROW),0===o&&n.columns&&(t|=Q.COLUMN)):n&&(0===r&&(t|=Q.ROW),0===o&&(t|=Q.COLUMN));const l=ee(t),i=s();i.append(h()),l.append(i),e.append(l)}o.append(e)}return o}function ue(e){const n=t(e,(e=>te(e)));return te(n)?n:null}function he(e){const n=t(e,(e=>se(e)));if(se(n))return n;throw new Error(\"Expected table cell to be inside of table row.\")}function ge(e){const n=t(e,(e=>dt(e)));if(dt(n))return n;throw new Error(\"Expected table cell to be inside of table.\")}function fe(e){const t=he(e);return ge(t).getChildren().findIndex((e=>e.is(t)))}function me(e){return he(e).getChildren().findIndex((t=>t.is(e)))}function pe(e,t){const n=ge(e),{x:o,y:r}=n.getCordsFromCellNode(e,t);return{above:n.getCellNodeFromCords(o,r-1,t),below:n.getCellNodeFromCords(o,r+1,t),left:n.getCellNodeFromCords(o-1,r,t),right:n.getCellNodeFromCords(o+1,r,t)}}function Ce(e,t){const n=e.getChildren();if(t>=n.length||t<0)throw new Error(\"Expected table cell to be inside of table row.\");return n[t].remove(),e}function Se(e,t,n=!0,o,r){const l=e.getChildren();if(t>=l.length||t<0)throw new Error(\"Table row target index out of range\");const i=l[t];if(!se(i))throw new Error(\"Row before insertion index does not exist.\");for(let e=0;e<o;e++){const e=i.getChildren(),t=e.length,o=le();for(let n=0;n<t;n++){const t=e[n];te(t)||ce(12);const{above:l,below:i}=pe(t,r);let c=Q.NO_STATUS;const a=l&&l.getWidth()||i&&i.getWidth()||void 0;(l&&l.hasHeaderState(Q.COLUMN)||i&&i.hasHeaderState(Q.COLUMN))&&(c|=Q.COLUMN);const d=ee(c,1,a);d.append(s()),o.append(d)}n?i.insertAfter(o):i.insertBefore(o)}return e}const _e=(e,t)=>e===Q.BOTH||e===t?t:Q.NO_STATUS;function we(e=!0){const t=g();f(t)||Ae(t)||ce(188);const n=t.focus.getNode(),[o,,r]=Ke(n),[l,i]=Me(r,o,o),c=l[0].length,{startRow:a}=i;if(e){const e=a+o.__rowSpan-1,t=l[e],n=le();for(let o=0;o<c;o++){const{cell:r,startRow:l}=t[o];if(l+r.__rowSpan-1<=e){const e=t[o].cell.__headerState,r=_e(e,Q.COLUMN);n.append(ee(r).append(s()))}else r.setRowSpan(r.__rowSpan+1)}const i=r.getChildAtIndex(e);se(i)||ce(145),i.insertAfter(n)}else{const e=l[a],t=le();for(let n=0;n<c;n++){const{cell:o,startRow:r}=e[n];if(r===a){const o=e[n].cell.__headerState,r=_e(o,Q.COLUMN);t.append(ee(r).append(s()))}else o.setRowSpan(o.__rowSpan+1)}const n=r.getChildAtIndex(a);se(n)||ce(145),n.insertBefore(t)}}function be(e,t,n=!0,o,r){const l=e.getChildren(),i=[];for(let e=0;e<l.length;e++){const n=l[e];if(se(n))for(let e=0;e<o;e++){const e=n.getChildren();if(t>=e.length||t<0)throw new Error(\"Table column target index out of range\");const o=e[t];te(o)||ce(12);const{left:l,right:c}=pe(o,r);let a=Q.NO_STATUS;(l&&l.hasHeaderState(Q.ROW)||c&&c.hasHeaderState(Q.ROW))&&(a|=Q.ROW);const d=ee(a);d.append(s()),i.push({newTableCell:d,targetCell:o})}}return i.forEach((({newTableCell:e,targetCell:t})=>{n?t.insertAfter(e):t.insertBefore(e)})),e}function ye(e=!0){const t=g();f(t)||Ae(t)||ce(188);const n=t.anchor.getNode(),o=t.focus.getNode(),[r]=Ke(n),[l,,i]=Ke(o),[c,a,d]=Me(i,l,r),u=c.length,h=e?Math.max(a.startColumn,d.startColumn):Math.min(a.startColumn,d.startColumn),m=e?h+l.__colSpan-1:h-1,p=i.getFirstChild();se(p)||ce(120);let C=null;function S(e=Q.NO_STATUS){const t=ee(e).append(s());return null===C&&(C=t),t}let _=p;e:for(let e=0;e<u;e++){if(0!==e){const e=_.getNextSibling();se(e)||ce(121),_=e}const t=c[e],n=t[m<0?0:m].cell.__headerState,o=_e(n,Q.ROW);if(m<0){Ee(_,S(o));continue}const{cell:r,startColumn:l,startRow:s}=t[m];if(l+r.__colSpan-1<=m){let n=r,l=s,i=m;for(;l!==e&&n.__rowSpan>1;){if(i-=r.__colSpan,!(i>=0)){_.append(S(o));continue e}{const{cell:e,startRow:o}=t[i];n=e,l=o}}n.insertAfter(S(o))}else r.setColSpan(r.__colSpan+1)}null!==C&&ve(C)}function Ne(e,t){const n=e.getChildren();for(let e=0;e<n.length;e++){const o=n[e];if(se(o)){const e=o.getChildren();if(t>=e.length||t<0)throw new Error(\"Table column target index out of range\");e[t].remove()}}return e}function Te(){const e=g();f(e)||Ae(e)||ce(188);const t=e.anchor.getNode(),n=e.focus.getNode(),[o,,r]=Ke(t),[l]=Ke(n),[s,i,c]=Me(r,o,l),{startRow:a}=i,{startRow:d}=c,u=d+l.__rowSpan-1;if(s.length===u-a+1)return void r.remove();const h=s[0].length,m=s[u+1],p=r.getChildAtIndex(u+1);for(let e=u;e>=a;e--){for(let t=h-1;t>=0;t--){const{cell:n,startRow:o,startColumn:r}=s[e][t];if(r===t&&(e===a&&o<a&&n.setRowSpan(n.__rowSpan-(o-a)),o>=a&&o+n.__rowSpan-1>u))if(n.setRowSpan(n.__rowSpan-(u-o+1)),null===p&&ce(122),0===t)Ee(p,n);else{const{cell:e}=m[t-1];e.insertAfter(n)}}const t=r.getChildAtIndex(e);se(t)||ce(123,String(e)),t.remove()}if(void 0!==m){const{cell:e}=m[0];ve(e)}else{const e=s[a-1],{cell:t}=e[0];ve(t)}}function xe(){const e=g();f(e)||Ae(e)||ce(188);const t=e.anchor.getNode(),n=e.focus.getNode(),[o,,r]=Ke(t),[l]=Ke(n),[s,i,c]=Me(r,o,l),{startColumn:a}=i,{startRow:d,startColumn:u}=c,h=Math.min(a,u),m=Math.max(a+o.__colSpan-1,u+l.__colSpan-1),p=m-h+1;if(s[0].length===m-h+1)return r.selectPrevious(),void r.remove();const C=s.length;for(let e=0;e<C;e++)for(let t=h;t<=m;t++){const{cell:n,startColumn:o}=s[e][t];if(o<h){if(t===h){const e=h-o;n.setColSpan(n.__colSpan-Math.min(p,n.__colSpan-e))}}else if(o+n.__colSpan-1>m){if(t===m){const e=m-o+1;n.setColSpan(n.__colSpan-e)}}else n.remove()}const S=s[d],_=a>u?S[a+o.__colSpan]:S[u+l.__colSpan];if(void 0!==_){const{cell:e}=_;ve(e)}else{const e=u<a?S[u-1]:S[a-1],{cell:t}=e;ve(t)}}function ve(e){const t=e.getFirstDescendant();null==t?e.selectStart():t.getParentOrThrow().selectStart()}function Ee(e,t){const n=e.getFirstChild();null!==n?n.insertBefore(t):e.append(t)}function Oe(){const e=g();f(e)||Ae(e)||ce(188);const t=e.anchor.getNode(),[n,o,r]=Ke(t),l=n.__colSpan,i=n.__rowSpan;if(l>1){for(let e=1;e<l;e++)n.insertAfter(ee(Q.NO_STATUS).append(s()));n.setColSpan(1)}if(i>1){const[e,t]=Me(r,n,n),{startColumn:c,startRow:a}=t;let d;for(let t=1;t<i;t++){const n=a+t,r=e[n];d=(d||o).getNextSibling(),se(d)||ce(125);let i=null;for(let e=0;e<c;e++){const t=r[e],o=t.cell;t.startRow===n&&(i=o),o.__colSpan>1&&(e+=o.__colSpan-1)}if(null===i)for(let e=0;e<l;e++)Ee(d,ee(Q.NO_STATUS).append(s()));else for(let e=0;e<l;e++)i.insertAfter(ee(Q.NO_STATUS).append(s()))}n.setRowSpan(1)}}function Me(e,t,n){const[o,r,l]=Re(e,t,n);return null===r&&ce(110),null===l&&ce(111),[o,r,l]}function Re(e,t,n){const o=[];let r=null,l=null;function s(e,s,i){const c={cell:i,startColumn:s,startRow:e},a=i.__rowSpan,d=i.__colSpan;for(let t=0;t<a;t++){void 0===o[e+t]&&(o[e+t]=[]);for(let n=0;n<d;n++)o[e+t][s+n]=c}null!==t&&t.is(i)&&(r=c),null!==n&&n.is(i)&&(l=c)}function i(e,t){return void 0===o[e]||void 0===o[e][t]}const c=e.getChildren();for(let e=0;e<c.length;e++){const t=c[e];se(t)||ce(146);const n=t.getChildren();let o=0;for(const t of n){for(te(t)||ce(147);!i(e,o);)o++;s(e,o,t),o+=t.__colSpan}}return[o,r,l]}function Ke(e){let n;if(e instanceof V)n=e;else if(\"__type\"in e){const o=t(e,te);te(o)||ce(148),n=o}else{const o=t(e.getNode(),te);te(o)||ce(148),n=o}const o=n.getParent();se(o)||ce(149);const r=o.getParent();return dt(r)||ce(150),[n,o,r]}function Fe(e){const[t,,n]=Ke(e),o=n.getChildren(),r=o.length,l=o[0].getChildren().length,s=new Array(r);for(let e=0;e<r;e++)s[e]=new Array(l);for(let e=0;e<r;e++){const n=o[e].getChildren();let r=0;for(let o=0;o<n.length;o++){for(;s[e][r];)r++;const l=n[o],i=l.__rowSpan||1,c=l.__colSpan||1;for(let t=0;t<i;t++)for(let n=0;n<c;n++)s[e+t][r+n]=l;if(t===l)return{colSpan:c,columnIndex:r,rowIndex:e,rowSpan:i};r+=c}}return null}class ke{constructor(e,t,n){this.anchor=t,this.focus=n,t._selection=this,n._selection=this,this._cachedNodes=null,this.dirty=!1,this.tableKey=e}getStartEndPoints(){return[this.anchor,this.focus]}isBackward(){return this.focus.isBefore(this.anchor)}getCachedNodes(){return this._cachedNodes}setCachedNodes(e){this._cachedNodes=e}is(e){return!!Ae(e)&&(this.tableKey===e.tableKey&&this.anchor.is(e.anchor)&&this.focus.is(e.focus))}set(e,t,n){this.dirty=!0,this.tableKey=e,this.anchor.key=t,this.focus.key=n,this._cachedNodes=null}clone(){return new ke(this.tableKey,this.anchor,this.focus)}isCollapsed(){return!1}extract(){return this.getNodes()}insertRawText(e){}insertText(){}insertNodes(e){const t=this.focus.getNode();i(t)||ce(151);p(t.select(0,t.getChildrenSize())).insertNodes(e)}getShape(){const e=C(this.anchor.key);te(e)||ce(152);const t=Fe(e);null===t&&ce(153);const n=C(this.focus.key);te(n)||ce(154);const o=Fe(n);null===o&&ce(155);const r=Math.min(t.columnIndex,o.columnIndex),l=Math.max(t.columnIndex,o.columnIndex),s=Math.min(t.rowIndex,o.rowIndex),i=Math.max(t.rowIndex,o.rowIndex);return{fromX:Math.min(r,l),fromY:Math.min(s,i),toX:Math.max(r,l),toY:Math.max(s,i)}}getNodes(){const e=this._cachedNodes;if(null!==e)return e;const n=this.anchor.getNode(),o=this.focus.getNode(),r=t(n,te),l=t(o,te);te(r)||ce(152),te(l)||ce(154);const s=r.getParent();se(s)||ce(156);const i=s.getParent();dt(i)||ce(157);const c=l.getParents()[1];if(c!==i){if(i.isParentOf(l)){const e=c.getParent();null==e&&ce(159),this.set(this.tableKey,l.getKey(),e.getKey())}else{const e=i.getParent();null==e&&ce(158),this.set(this.tableKey,e.getKey(),l.getKey())}return this.getNodes()}const[a,d,u]=Me(i,r,l);let h=Math.min(d.startColumn,u.startColumn),g=Math.min(d.startRow,u.startRow),f=Math.max(d.startColumn+d.cell.__colSpan-1,u.startColumn+u.cell.__colSpan-1),m=Math.max(d.startRow+d.cell.__rowSpan-1,u.startRow+u.cell.__rowSpan-1),p=h,C=g,_=h,w=g;function b(e){const{cell:t,startColumn:n,startRow:o}=e;h=Math.min(h,n),g=Math.min(g,o),f=Math.max(f,n+t.__colSpan-1),m=Math.max(m,o+t.__rowSpan-1)}for(;h<p||g<C||f>_||m>w;){if(h<p){const e=w-C,t=p-1;for(let n=0;n<=e;n++)b(a[C+n][t]);p=t}if(g<C){const e=_-p,t=C-1;for(let n=0;n<=e;n++)b(a[t][p+n]);C=t}if(f>_){const e=w-C,t=_+1;for(let n=0;n<=e;n++)b(a[C+n][t]);_=t}if(m>w){const e=_-p,t=w+1;for(let n=0;n<=e;n++)b(a[t][p+n]);w=t}}const y=[i];let N=null;for(let e=g;e<=m;e++)for(let t=h;t<=f;t++){const{cell:n}=a[e][t],o=n.getParent();se(o)||ce(160),o!==N&&y.push(o),y.push(n,...De(n)),N=o}return S()||(this._cachedNodes=y),y}getTextContent(){const e=this.getNodes().filter((e=>te(e)));let t=\"\";for(let n=0;n<e.length;n++){const o=e[n],r=o.__parent,l=(e[n+1]||{}).__parent;t+=o.getTextContent()+(l!==r?\"\\n\":\"\\t\")}return t}}function Ae(e){return e instanceof ke}function He(){const e=m(\"root\",0,\"element\"),t=m(\"root\",0,\"element\");return new ke(\"root\",e,t)}function De(e){const t=[],n=[e];for(;n.length>0;){const o=n.pop();void 0===o&&ce(112),i(o)&&n.unshift(...o.getChildren()),o!==e&&t.push(o)}return t}class Pe{constructor(e,t){this.isHighlightingCells=!1,this.anchorX=-1,this.anchorY=-1,this.focusX=-1,this.focusY=-1,this.listenersToRemove=new Set,this.tableNodeKey=t,this.editor=e,this.table={columns:0,domRows:[],rows:0},this.tableSelection=null,this.anchorCellNodeKey=null,this.focusCellNodeKey=null,this.anchorCell=null,this.focusCell=null,this.hasHijackedSelectionStyles=!1,this.trackTable(),this.isSelecting=!1}getTable(){return this.table}removeListeners(){Array.from(this.listenersToRemove).forEach((e=>e()))}trackTable(){const e=new MutationObserver((e=>{this.editor.update((()=>{let t=!1;for(let n=0;n<e.length;n++){const o=e[n].target.nodeName;if(\"TABLE\"===o||\"TBODY\"===o||\"THEAD\"===o||\"TR\"===o){t=!0;break}}if(!t)return;const n=this.editor.getElementByKey(this.tableNodeKey);if(!n)throw new Error(\"Expected to find TableElement in DOM\");this.table=ze(n)}))}));this.editor.update((()=>{const t=this.editor.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");this.table=ze(t),e.observe(t,{attributes:!0,childList:!0,subtree:!0})}))}clearHighlight(){const e=this.editor;this.isHighlightingCells=!1,this.anchorX=-1,this.anchorY=-1,this.focusX=-1,this.focusY=-1,this.tableSelection=null,this.anchorCellNodeKey=null,this.focusCellNodeKey=null,this.anchorCell=null,this.focusCell=null,this.hasHijackedSelectionStyles=!1,this.enableHighlightStyle(),e.update((()=>{if(!dt(C(this.tableNodeKey)))throw new Error(\"Expected TableNode.\");const t=e.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");const n=ze(t);Ye(e,n,null),_(null),e.dispatchCommand(w,void 0)}))}enableHighlightStyle(){const e=this.editor;e.update((()=>{const t=e.getElementByKey(this.tableNodeKey);if(!t)throw new Error(\"Expected to find TableElement in DOM\");n(t,e._config.theme.tableSelection),t.classList.remove(\"disable-selection\"),this.hasHijackedSelectionStyles=!1}))}disableHighlightStyle(){const t=this.editor;t.update((()=>{const n=t.getElementByKey(this.tableNodeKey);if(!n)throw new Error(\"Expected to find TableElement in DOM\");e(n,t._config.theme.tableSelection),this.hasHijackedSelectionStyles=!0}))}updateTableTableSelection(e){if(null!==e&&e.tableKey===this.tableNodeKey){const t=this.editor;this.tableSelection=e,this.isHighlightingCells=!0,this.disableHighlightStyle(),Ye(t,this.table,this.tableSelection)}else null==e?this.clearHighlight():(this.tableNodeKey=e.tableKey,this.updateTableTableSelection(e))}setFocusCellForSelection(e,t=!1){const n=this.editor;n.update((()=>{const o=C(this.tableNodeKey);if(!dt(o))throw new Error(\"Expected TableNode.\");if(!n.getElementByKey(this.tableNodeKey))throw new Error(\"Expected to find TableElement in DOM\");const r=e.x,l=e.y;if(this.focusCell=e,null!==this.anchorCell){const e=Le(n._window);e&&e.setBaseAndExtent(this.anchorCell.elem,0,this.focusCell.elem,0)}if(this.isHighlightingCells||this.anchorX===r&&this.anchorY===l&&!t){if(r===this.focusX&&l===this.focusY)return}else this.isHighlightingCells=!0,this.disableHighlightStyle();if(this.focusX=r,this.focusY=l,this.isHighlightingCells){const t=b(e.elem);if(null!=this.tableSelection&&null!=this.anchorCellNodeKey&&te(t)&&o.is(tt(t))){const e=t.getKey();this.tableSelection=this.tableSelection.clone()||He(),this.focusCellNodeKey=e,this.tableSelection.set(this.tableNodeKey,this.anchorCellNodeKey,this.focusCellNodeKey),_(this.tableSelection),n.dispatchCommand(w,void 0),Ye(n,this.table,this.tableSelection)}}}))}setAnchorCellForSelection(e){this.isHighlightingCells=!1,this.anchorCell=e,this.anchorX=e.x,this.anchorY=e.y,this.editor.update((()=>{const t=b(e.elem);if(te(t)){const e=t.getKey();this.tableSelection=null!=this.tableSelection?this.tableSelection.clone():He(),this.anchorCellNodeKey=e}}))}formatCells(e){this.editor.update((()=>{const t=g();Ae(t)||ce(11);const n=y(),o=n.anchor,r=n.focus;t.getNodes().forEach((t=>{te(t)&&0!==t.getTextContentSize()&&(o.set(t.getKey(),0,\"element\"),r.set(t.getKey(),t.getChildrenSize(),\"element\"),n.formatText(e))})),_(t),this.editor.dispatchCommand(w,void 0)}))}clearText(){const e=this.editor;e.update((()=>{const t=C(this.tableNodeKey);if(!dt(t))throw new Error(\"Expected TableNode.\");const n=g();Ae(n)||ce(11);const o=n.getNodes().filter(te);if(o.length!==this.table.columns*this.table.rows)o.forEach((e=>{if(i(e)){const t=s(),n=h();t.append(n),e.append(t),e.getChildren().forEach((e=>{e!==t&&e.remove()}))}})),Ye(e,this.table,null),_(null),e.dispatchCommand(w,void 0);else{t.selectPrevious(),t.remove();N().selectStart()}}))}}const Be=\"__lexicalTableSelection\",Le=e=>ae?(e||window).getSelection():null;function Ie(e,n,r,l){const c=r.getRootElement();if(null===c)throw new Error(\"No root element.\");const d=new Pe(r,e.getKey()),u=r._window||window;!function(e,t){e[Be]=t}(n,d);const m=()=>{const e=()=>{d.isSelecting=!1,u.removeEventListener(\"mouseup\",e),u.removeEventListener(\"mousemove\",t)},t=n=>{setTimeout((()=>{if(1&~n.buttons&&d.isSelecting)return d.isSelecting=!1,u.removeEventListener(\"mouseup\",e),void u.removeEventListener(\"mousemove\",t);const o=Ue(n.target);null===o||d.anchorX===o.x&&d.anchorY===o.y||(n.preventDefault(),d.setFocusCellForSelection(o))}),0)};return{onMouseMove:t,onMouseUp:e}};n.addEventListener(\"mousedown\",(e=>{setTimeout((()=>{if(0!==e.button)return;if(!u)return;const t=Ue(e.target);null!==t&&(ot(e),d.setAnchorCellForSelection(t));const{onMouseUp:n,onMouseMove:o}=m();d.isSelecting=!0,u.addEventListener(\"mouseup\",n),u.addEventListener(\"mousemove\",o)}),0)}));const p=e=>{0===e.button&&r.update((()=>{const t=g(),n=e.target;Ae(t)&&t.tableKey===d.tableNodeKey&&c.contains(n)&&d.clearHighlight()}))};u.addEventListener(\"mousedown\",p),d.listenersToRemove.add((()=>u.removeEventListener(\"mousedown\",p))),d.listenersToRemove.add(r.registerCommand(T,(t=>nt(r,t,\"down\",e,d)),x)),d.listenersToRemove.add(r.registerCommand(v,(t=>nt(r,t,\"up\",e,d)),x)),d.listenersToRemove.add(r.registerCommand(E,(t=>nt(r,t,\"backward\",e,d)),x)),d.listenersToRemove.add(r.registerCommand(O,(t=>nt(r,t,\"forward\",e,d)),x)),d.listenersToRemove.add(r.registerCommand(M,(e=>{const n=g();if(Ae(n)){const o=t(n.focus.getNode(),te);if(te(o))return ot(e),o.selectEnd(),!0}return!1}),x));[R,K,F].forEach((n=>{d.listenersToRemove.add(r.registerCommand(n,(n=>()=>{const o=g();if(!qe(o,e))return!1;if(Ae(o))return d.clearText(),!0;if(f(o)){const r=t(o.anchor.getNode(),(e=>te(e)));if(!te(r))return!1;const l=o.anchor.getNode(),s=o.focus.getNode(),c=e.isParentOf(l),a=e.isParentOf(s);if(c&&!a||a&&!c)return d.clearText(),!0;const u=t(o.anchor.getNode(),(e=>i(e))),h=u&&t(u,(e=>i(e)&&te(e.getParent())));if(!i(h)||!i(u))return!1;if(n===K&&null===h.getPreviousSibling())return!0}return!1})(n),k))}));const C=n=>{const o=g();if(!qe(o,e)){const e=o?o.getNodes():null;if(e){const t=e.find((e=>dt(e)&&e.getKey()===d.tableNodeKey));if(dt(t)){if(!t.getParent())return!1;t.remove()}}return!1}if(Ae(o))return n&&(n.preventDefault(),n.stopPropagation()),d.clearText(),!0;if(f(o)){const e=t(o.anchor.getNode(),(e=>te(e)));if(!te(e))return!1}return!1};function S(t){const n=e.getCordsFromCellNode(t,d.table);return e.getDOMCellFromCordsOrThrow(n.x,n.y,d.table)}return d.listenersToRemove.add(r.registerCommand(A,C,k)),d.listenersToRemove.add(r.registerCommand(H,C,k)),d.listenersToRemove.add(r.registerCommand(D,(e=>{const t=g();if(t){if(!Ae(t)&&!f(t))return!1;j(r,o(e,ClipboardEvent)?e:null,q(t));const n=C(e);return f(t)&&t.removeText(),n}return!1}),k)),d.listenersToRemove.add(r.registerCommand(P,(n=>{const o=g();if(!qe(o,e))return!1;if(Ae(o))return d.formatCells(n),!0;if(f(o)){const e=t(o.anchor.getNode(),(e=>te(e)));if(!te(e))return!1}return!1}),k)),d.listenersToRemove.add(r.registerCommand(B,(t=>{const n=g();if(!Ae(n)||!qe(n,e))return!1;const o=n.anchor.getNode(),r=n.focus.getNode();if(!te(o)||!te(r))return!1;const[l,s,c]=Me(e,o,r),a=Math.max(s.startRow,c.startRow),d=Math.max(s.startColumn,c.startColumn),u=Math.min(s.startRow,c.startRow),h=Math.min(s.startColumn,c.startColumn);for(let e=u;e<=a;e++)for(let n=h;n<=d;n++){const o=l[e][n].cell;o.setFormat(t);const r=o.getChildren();for(let e=0;e<r.length;e++){const n=r[e];i(n)&&!n.isInline()&&n.setFormat(t)}}return!0}),k)),d.listenersToRemove.add(r.registerCommand(L,(n=>{const o=g();if(!qe(o,e))return!1;if(Ae(o))return d.clearHighlight(),!1;if(f(o)){const l=t(o.anchor.getNode(),(e=>te(e)));if(!te(l))return!1;if(\"string\"==typeof n){const t=lt(r,o,e);if(t)return rt(t,e,[h(n)]),!0}}return!1}),k)),l&&d.listenersToRemove.add(r.registerCommand(I,(t=>{const n=g();if(!f(n)||!n.isCollapsed()||!qe(n,e))return!1;const o=et(n.anchor.getNode());if(null===o)return!1;ot(t);const r=e.getCordsFromCellNode(o,d.table);return $e(d,e,r.x,r.y,t.shiftKey?\"backward\":\"forward\"),!0}),k)),d.listenersToRemove.add(r.registerCommand(W,(t=>e.isSelected()),x)),d.listenersToRemove.add(r.registerCommand(U,(e=>{const{nodes:n,selection:o}=e,r=o.getStartEndPoints(),l=Ae(o),i=f(o)&&null!==t(o.anchor.getNode(),(e=>te(e)))&&null!==t(o.focus.getNode(),(e=>te(e)))||l;if(1!==n.length||!dt(n[0])||!i||null===r)return!1;const[c]=r,d=n[0],u=d.getChildren(),h=d.getFirstChildOrThrow().getChildrenSize(),g=d.getChildrenSize(),m=t(c.getNode(),(e=>te(e))),p=m&&t(m,(e=>se(e))),C=p&&t(p,(e=>dt(e)));if(!te(m)||!se(p)||!dt(C))return!1;const S=p.getIndexWithinParent(),_=Math.min(C.getChildrenSize()-1,S+g-1),w=m.getIndexWithinParent(),b=Math.min(p.getChildrenSize()-1,w+h-1),y=Math.min(w,b),N=Math.min(S,_),T=Math.max(w,b),x=Math.max(S,_),v=C.getChildren();let E=0;for(let e=N;e<=x;e++){const t=v[e];if(!se(t))return!1;const n=u[E];if(!se(n))return!1;const o=t.getChildren(),r=n.getChildren();let l=0;for(let e=y;e<=T;e++){const t=o[e];if(!te(t))return!1;const n=r[l];if(!te(n))return!1;const i=t.getChildren();n.getChildren().forEach((e=>{if(a(e)){s().append(e),t.append(e)}else t.append(e)})),i.forEach((e=>e.remove())),l++}E++}return!0}),k)),d.listenersToRemove.add(r.registerCommand(w,(()=>{const t=g(),n=z();if(f(t)){const{anchor:n,focus:o}=t,l=n.getNode(),s=o.getNode(),i=et(l),c=et(s),a=!(!i||!e.is(tt(i))),h=!(!c||!e.is(tt(c))),g=a!==h,f=a&&h,p=t.isBackward();if(g){const n=t.clone();if(h){const[t]=Me(e,c,c),o=t[0][0].cell,r=t[t.length-1].at(-1).cell;n.focus.set(p?o.getKey():r.getKey(),p?o.getChildrenSize():r.getChildrenSize(),\"element\")}_(n),Je(r,d)}else f&&(i.is(c)||(d.setAnchorCellForSelection(S(i)),d.setFocusCellForSelection(S(c),!0),d.isSelecting||setTimeout((()=>{const{onMouseUp:e,onMouseMove:t}=m();d.isSelecting=!0,u.addEventListener(\"mouseup\",e),u.addEventListener(\"mousemove\",t)}),0)))}else if(t&&Ae(t)&&t.is(n)&&t.tableKey===e.getKey()){const n=Le(r._window);if(n&&n.anchorNode&&n.focusNode){const o=b(n.focusNode),l=o&&!e.is(tt(o)),s=b(n.anchorNode),i=s&&e.is(tt(s));if(l&&i&&n.rangeCount>0){const o=Y(n,r);o&&(o.anchor.set(e.getKey(),t.isBackward()?e.getChildrenSize():0,\"element\"),n.removeAllRanges(),_(o))}}}return t&&!t.is(n)&&(Ae(t)||Ae(n))&&d.tableSelection&&!d.tableSelection.is(n)?(Ae(t)&&t.tableKey===d.tableNodeKey?d.updateTableTableSelection(t):!Ae(t)&&Ae(n)&&n.tableKey===d.tableNodeKey&&d.updateTableTableSelection(null),!1):(d.hasHijackedSelectionStyles&&!e.isSelected()?function(e,t){t.enableHighlightStyle(),Xe(t.table,(t=>{const n=t.elem;t.highlighted=!1,Ze(e,t),n.getAttribute(\"style\")||n.removeAttribute(\"style\")}))}(r,d):!d.hasHijackedSelectionStyles&&e.isSelected()&&Je(r,d),!1)}),k)),d.listenersToRemove.add(r.registerCommand(X,(()=>{const t=g();if(!f(t)||!t.isCollapsed()||!qe(t,e))return!1;const n=lt(r,t,e);return!!n&&(rt(n,e),!0)}),k)),d}function We(e){return e[Be]}function Ue(e){let t=e;for(;null!=t;){const e=t.nodeName;if(\"TD\"===e||\"TH\"===e){const e=t._cell;return void 0===e?null:e}t=t.parentNode}return null}function ze(e){const t=[],n={columns:0,domRows:t,rows:0};let o=e.firstChild,r=0,l=0;for(t.length=0;null!=o;){const e=o.nodeName;if(\"TD\"===e||\"TH\"===e){const e={elem:o,hasBackgroundColor:\"\"!==o.style.backgroundColor,highlighted:!1,x:r,y:l};o._cell=e;let n=t[l];void 0===n&&(n=t[l]=[]),n[r]=e}else{const e=o.firstChild;if(null!=e){o=e;continue}}const n=o.nextSibling;if(null!=n){r++,o=n;continue}const s=o.parentNode;if(null!=s){const e=s.nextSibling;if(null==e)break;l++,r=0,o=e}}return n.columns=r+1,n.rows=l+1,n}function Ye(e,t,n){const o=new Set(n?n.getNodes():[]);Xe(t,((t,n)=>{const r=t.elem;o.has(n)?(t.highlighted=!0,Ve(e,t)):(t.highlighted=!1,Ze(e,t),r.getAttribute(\"style\")||r.removeAttribute(\"style\"))}))}function Xe(e,t){const{domRows:n}=e;for(let e=0;e<n.length;e++){const o=n[e];if(o)for(let n=0;n<o.length;n++){const r=o[n];if(!r)continue;const l=b(r.elem);null!==l&&t(r,l,{x:n,y:e})}}}function Je(e,t){t.disableHighlightStyle(),Xe(t.table,(t=>{t.highlighted=!0,Ve(e,t)}))}const $e=(e,t,n,o,r)=>{const l=\"forward\"===r;switch(r){case\"backward\":case\"forward\":return n!==(l?e.table.columns-1:0)?Ge(t.getCellNodeFromCordsOrThrow(n+(l?1:-1),o,e.table),l):o!==(l?e.table.rows-1:0)?Ge(t.getCellNodeFromCordsOrThrow(l?0:e.table.columns-1,o+(l?1:-1),e.table),l):l?t.selectNext():t.selectPrevious(),!0;case\"up\":return 0!==o?Ge(t.getCellNodeFromCordsOrThrow(n,o-1,e.table),!1):t.selectPrevious(),!0;case\"down\":return o!==e.table.rows-1?Ge(t.getCellNodeFromCordsOrThrow(n,o+1,e.table),!0):t.selectNext(),!0;default:return!1}},je=(e,t,n,o,r)=>{const l=\"forward\"===r;switch(r){case\"backward\":case\"forward\":return n!==(l?e.table.columns-1:0)&&e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n+(l?1:-1),o,e.table)),!0;case\"up\":return 0!==o&&(e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n,o-1,e.table)),!0);case\"down\":return o!==e.table.rows-1&&(e.setFocusCellForSelection(t.getDOMCellFromCordsOrThrow(n,o+1,e.table)),!0);default:return!1}};function qe(e,t){if(f(e)||Ae(e)){const n=t.isParentOf(e.anchor.getNode()),o=t.isParentOf(e.focus.getNode());return n&&o}return!1}function Ge(e,t){t?e.selectStart():e.selectEnd()}const Qe=\"172,206,247\";function Ve(e,t){const n=t.elem,o=b(n);te(o)||ce(131);null===o.getBackgroundColor()?n.style.setProperty(\"background-color\",`rgb(${Qe})`):n.style.setProperty(\"background-image\",`linear-gradient(to right, rgba(${Qe},0.85), rgba(${Qe},0.85))`),n.style.setProperty(\"caret-color\",\"transparent\")}function Ze(e,t){const n=t.elem,o=b(n);te(o)||ce(131);null===o.getBackgroundColor()&&n.style.removeProperty(\"background-color\"),n.style.removeProperty(\"background-image\"),n.style.removeProperty(\"caret-color\")}function et(e){const n=t(e,te);return te(n)?n:null}function tt(e){const n=t(e,dt);return dt(n)?n:null}function nt(e,n,o,r,l){if((\"up\"===o||\"down\"===o)&&function(e){const t=e.getRootElement();if(!t)return!1;return t.hasAttribute(\"aria-controls\")&&\"typeahead-menu\"===t.getAttribute(\"aria-controls\")}(e))return!1;const s=g();if(!qe(s,r)){if(f(s)){if(s.isCollapsed()&&\"backward\"===o){const e=s.anchor.type,o=s.anchor.offset;if(\"element\"!==e&&(\"text\"!==e||0!==o))return!1;const r=s.anchor.getNode();if(!r)return!1;const l=t(r,(e=>i(e)&&!e.isInline()));if(!l)return!1;const c=l.getPreviousSibling();return!(!c||!dt(c))&&(ot(n),c.selectEnd(),!0)}if(n.shiftKey&&(\"up\"===o||\"down\"===o)){const e=s.focus.getNode();if(J(e)){const e=s.getNodes()[0];if(e){const n=t(e,te);if(n&&r.isParentOf(n)){const e=r.getFirstDescendant(),t=r.getLastDescendant();if(!e||!t)return!1;const[n]=Ke(e),[o]=Ke(t),s=r.getCordsFromCellNode(n,l.table),i=r.getCordsFromCellNode(o,l.table),c=r.getDOMCellFromCordsOrThrow(s.x,s.y,l.table),a=r.getDOMCellFromCordsOrThrow(i.x,i.y,l.table);return l.setAnchorCellForSelection(c),l.setFocusCellForSelection(a,!0),!0}}return!1}{const n=t(e,(e=>i(e)&&!e.isInline()));if(!n)return!1;const r=\"down\"===o?n.getNextSibling():n.getPreviousSibling();if(dt(r)&&l.tableNodeKey===r.getKey()){const e=r.getFirstDescendant(),t=r.getLastDescendant();if(!e||!t)return!1;const[n]=Ke(e),[l]=Ke(t),i=s.clone();return i.focus.set((\"up\"===o?n:l).getKey(),\"up\"===o?0:l.getChildrenSize(),\"element\"),_(i),!0}}}}return!1}if(f(s)&&s.isCollapsed()){const{anchor:c,focus:a}=s,d=t(c.getNode(),te),u=t(a.getNode(),te);if(!te(d)||!d.is(u))return!1;const h=tt(d);if(h!==r&&null!=h){const t=e.getElementByKey(h.getKey());if(null!=t)return l.table=ze(t),nt(e,n,o,h,l)}if(\"backward\"===o||\"forward\"===o){const e=c.type,l=c.offset,a=c.getNode();if(!a)return!1;const d=s.getNodes();return(1!==d.length||!$(d[0]))&&(!!function(e,n,o,r){return function(e,t,n){return\"element\"===e&&(\"backward\"===n?null===t.getPreviousSibling():null===t.getNextSibling())}(e,o,r)||function(e,n,o,r){const l=t(o,(e=>i(e)&&!e.isInline()));if(!l)return!1;const s=\"backward\"===r?0===n:n===o.getTextContentSize();return\"text\"===e&&s&&(\"backward\"===r?null===l.getPreviousSibling():null===l.getNextSibling())}(e,n,o,r)}(e,l,a,o)&&function(e,n,o,r){const l=t(n,te);if(!te(l))return!1;const[s,c]=Me(o,l,l);if(!function(e,t,n){const o=e[0][0],r=e[e.length-1][e[0].length-1],{startColumn:l,startRow:s}=t;return\"backward\"===n?l===o.startColumn&&s===o.startRow:l===r.startColumn&&s===r.startRow}(s,c,r))return!1;const a=function(e,n,o){const r=t(e,(e=>i(e)&&!e.isInline()));if(!r)return;const l=\"backward\"===n?r.getPreviousSibling():r.getNextSibling();return l&&dt(l)?l:\"backward\"===n?o.getPreviousSibling():o.getNextSibling()}(n,r,o);if(!a||dt(a))return!1;ot(e),\"backward\"===r?a.selectEnd():a.selectStart();return!0}(n,a,r,o))}const g=e.getElementByKey(d.__key),f=e.getElementByKey(c.key);if(null==f||null==g)return!1;let m;if(\"element\"===c.type)m=f.getBoundingClientRect();else{const e=window.getSelection();if(null===e||0===e.rangeCount)return!1;m=e.getRangeAt(0).getBoundingClientRect()}const p=\"up\"===o?d.getFirstChild():d.getLastChild();if(null==p)return!1;const C=e.getElementByKey(p.__key);if(null==C)return!1;const S=C.getBoundingClientRect();if(\"up\"===o?S.top>m.top-m.height:m.bottom+m.height>S.bottom){ot(n);const e=r.getCordsFromCellNode(d,l.table);if(!n.shiftKey)return $e(l,r,e.x,e.y,o);{const t=r.getDOMCellFromCordsOrThrow(e.x,e.y,l.table);l.setAnchorCellForSelection(t),l.setFocusCellForSelection(t,!0)}return!0}}else if(Ae(s)){const{anchor:i,focus:c}=s,a=t(i.getNode(),te),d=t(c.getNode(),te),[u]=s.getNodes(),h=e.getElementByKey(u.getKey());if(!te(a)||!te(d)||!dt(u)||null==h)return!1;l.updateTableTableSelection(s);const g=ze(h),f=r.getCordsFromCellNode(a,g),m=r.getDOMCellFromCordsOrThrow(f.x,f.y,g);if(l.setAnchorCellForSelection(m),ot(n),n.shiftKey){const e=r.getCordsFromCellNode(d,g);return je(l,u,e.x,e.y,o)}return d.selectEnd(),!0}return!1}function ot(e){e.preventDefault(),e.stopImmediatePropagation(),e.stopPropagation()}function rt(e,t,n){const o=s();\"first\"===e?t.insertBefore(o):t.insertAfter(o),o.append(...n||[]),o.selectEnd()}function lt(e,n,o){const r=o.getParent();if(!r)return;const l=e.getElementByKey(r.getKey());if(!l)return;const s=window.getSelection();if(!s||s.anchorNode!==l)return;const i=t(n.anchor.getNode(),(e=>te(e)));if(!i)return;const c=t(i,(e=>dt(e)));if(!dt(c)||!c.is(o))return;const[a,d]=Me(o,i,i),u=a[0][0],h=a[a.length-1][a[0].length-1],{startRow:g,startColumn:f}=d,m=g===u.startRow&&f===u.startColumn,p=g===h.startRow&&f===h.startColumn;return m?\"first\":p?\"last\":void 0}class st extends l{static getType(){return\"table\"}static clone(e){return new st(e.__key)}static importDOM(){return{table:e=>({conversion:ct,priority:1})}}static importJSON(e){return at()}constructor(e){super(e)}exportJSON(){return{...super.exportJSON(),type:\"table\",version:1}}createDOM(t,n){const o=document.createElement(\"table\");return e(o,t.theme.table),o}updateDOM(){return!1}exportDOM(e){return{...super.exportDOM(e),after:e=>{if(e){const t=e.cloneNode(),n=document.createElement(\"colgroup\"),o=document.createElement(\"tbody\");r(e)&&o.append(...e.children);const l=this.getFirstChildOrThrow();if(!se(l))throw new Error(\"Expected to find row node.\");const s=l.getChildrenSize();for(let e=0;e<s;e++){const e=document.createElement(\"col\");n.append(e)}return t.replaceChildren(n,o),t}}}}canBeEmpty(){return!1}isShadowRoot(){return!0}getCordsFromCellNode(e,t){const{rows:n,domRows:o}=t;for(let t=0;t<n;t++){const n=o[t];if(null==n)continue;const r=n.findIndex((t=>{if(!t)return;const{elem:n}=t;return b(n)===e}));if(-1!==r)return{x:r,y:t}}throw new Error(\"Cell not found in table.\")}getDOMCellFromCords(e,t,n){const{domRows:o}=n,r=o[t];if(null==r)return null;const l=r[e<r.length?e:r.length-1];return null==l?null:l}getDOMCellFromCordsOrThrow(e,t,n){const o=this.getDOMCellFromCords(e,t,n);if(!o)throw new Error(\"Cell not found at cords.\");return o}getCellNodeFromCords(e,t,n){const o=this.getDOMCellFromCords(e,t,n);if(null==o)return null;const r=b(o.elem);return te(r)?r:null}getCellNodeFromCordsOrThrow(e,t,n){const o=this.getCellNodeFromCords(e,t,n);if(!o)throw new Error(\"Node at cords not TableCellNode.\");return o}canSelectBefore(){return!0}canIndent(){return!1}}function it(e,t){const n=e.getElementByKey(t.getKey());if(null==n)throw new Error(\"Table Element Not Found\");return ze(n)}function ct(e){return{node:at()}}function at(){return d(new st)}function dt(e){return e instanceof st}export{Me as $computeTableMap,Re as $computeTableMapSkipCellCheck,ee as $createTableCellNode,at as $createTableNode,de as $createTableNodeWithDimensions,le as $createTableRowNode,He as $createTableSelection,Ne as $deleteTableColumn,xe as $deleteTableColumn__EXPERIMENTAL,Te as $deleteTableRow__EXPERIMENTAL,et as $findCellNode,tt as $findTableNode,it as $getElementForTableNode,Ke as $getNodeTriplet,ue as $getTableCellNodeFromLexicalNode,Fe as $getTableCellNodeRect,me as $getTableColumnIndexFromTableCellNode,ge as $getTableNodeFromLexicalNodeOrThrow,fe as $getTableRowIndexFromTableCellNode,he as $getTableRowNodeFromTableCellNodeOrThrow,be as $insertTableColumn,ye as $insertTableColumn__EXPERIMENTAL,Se as $insertTableRow,we as $insertTableRow__EXPERIMENTAL,te as $isTableCellNode,dt as $isTableNode,se as $isTableRowNode,Ae as $isTableSelection,Ce as $removeTableRowAtIndex,Oe as $unmergeCell,ne as INSERT_TABLE_COMMAND,Q as TableCellHeaderStates,V as TableCellNode,st as TableNode,Pe as TableObserver,oe as TableRowNode,Ie as applyTableHandlers,Ue as getDOMCellFromTarget,We as getTableObserverFromTableElement};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as modDev from './LexicalTable.dev.mjs';\nimport * as modProd from './LexicalTable.prod.mjs';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $computeTableMap = mod.$computeTableMap;\nexport const $computeTableMapSkipCellCheck = mod.$computeTableMapSkipCellCheck;\nexport const $createTableCellNode = mod.$createTableCellNode;\nexport const $createTableNode = mod.$createTableNode;\nexport const $createTableNodeWithDimensions = mod.$createTableNodeWithDimensions;\nexport const $createTableRowNode = mod.$createTableRowNode;\nexport const $createTableSelection = mod.$createTableSelection;\nexport const $deleteTableColumn = mod.$deleteTableColumn;\nexport const $deleteTableColumn__EXPERIMENTAL = mod.$deleteTableColumn__EXPERIMENTAL;\nexport const $deleteTableRow__EXPERIMENTAL = mod.$deleteTableRow__EXPERIMENTAL;\nexport const $findCellNode = mod.$findCellNode;\nexport const $findTableNode = mod.$findTableNode;\nexport const $getElementForTableNode = mod.$getElementForTableNode;\nexport const $getNodeTriplet = mod.$getNodeTriplet;\nexport const $getTableCellNodeFromLexicalNode = mod.$getTableCellNodeFromLexicalNode;\nexport const $getTableCellNodeRect = mod.$getTableCellNodeRect;\nexport const $getTableColumnIndexFromTableCellNode = mod.$getTableColumnIndexFromTableCellNode;\nexport const $getTableNodeFromLexicalNodeOrThrow = mod.$getTableNodeFromLexicalNodeOrThrow;\nexport const $getTableRowIndexFromTableCellNode = mod.$getTableRowIndexFromTableCellNode;\nexport const $getTableRowNodeFromTableCellNodeOrThrow = mod.$getTableRowNodeFromTableCellNodeOrThrow;\nexport const $insertTableColumn = mod.$insertTableColumn;\nexport const $insertTableColumn__EXPERIMENTAL = mod.$insertTableColumn__EXPERIMENTAL;\nexport const $insertTableRow = mod.$insertTableRow;\nexport const $insertTableRow__EXPERIMENTAL = mod.$insertTableRow__EXPERIMENTAL;\nexport const $isTableCellNode = mod.$isTableCellNode;\nexport const $isTableNode = mod.$isTableNode;\nexport const $isTableRowNode = mod.$isTableRowNode;\nexport const $isTableSelection = mod.$isTableSelection;\nexport const $removeTableRowAtIndex = mod.$removeTableRowAtIndex;\nexport const $unmergeCell = mod.$unmergeCell;\nexport const INSERT_TABLE_COMMAND = mod.INSERT_TABLE_COMMAND;\nexport const TableCellHeaderStates = mod.TableCellHeaderStates;\nexport const TableCellNode = mod.TableCellNode;\nexport const TableNode = mod.TableNode;\nexport const TableObserver = mod.TableObserver;\nexport const TableRowNode = mod.TableRowNode;\nexport const applyTableHandlers = mod.applyTableHandlers;\nexport const getDOMCellFromTarget = mod.getDOMCellFromTarget;\nexport const getTableObserverFromTableElement = mod.getTableObserverFromTableElement;"],"names":["createCommand","type","SELECTION_CHANGE_COMMAND","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","CLICK_COMMAND","DELETE_CHARACTER_COMMAND","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","PASTE_COMMAND","REMOVE_TEXT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","FORMAT_TEXT_COMMAND","UNDO_COMMAND","REDO_COMMAND","KEY_DOWN_COMMAND","KEY_ARROW_RIGHT_COMMAND","MOVE_TO_END","KEY_ARROW_LEFT_COMMAND","MOVE_TO_START","KEY_ARROW_UP_COMMAND","KEY_ARROW_DOWN_COMMAND","KEY_ENTER_COMMAND","KEY_SPACE_COMMAND","KEY_BACKSPACE_COMMAND","KEY_ESCAPE_COMMAND","KEY_DELETE_COMMAND","KEY_TAB_COMMAND","INSERT_TAB_COMMAND","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","DROP_COMMAND","FORMAT_ELEMENT_COMMAND","DRAGSTART_COMMAND","DRAGOVER_COMMAND","DRAGEND_COMMAND","COPY_COMMAND","CUT_COMMAND","SELECT_ALL_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","FOCUS_COMMAND","BLUR_COMMAND","KEY_MODIFIER_COMMAND","CAN_USE_DOM","window","document","createElement","documentMode","IS_APPLE","test","navigator","platform","IS_FIREFOX","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_ANDROID","IS_CHROME","IS_ANDROID_CHROME","IS_APPLE_WEBKIT","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_ALL_FORMATTING","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","NON_BREAKING_SPACE","ZERO_WIDTH_SPACE","COMPOSITION_SUFFIX","DOUBLE_LINE_BREAK","COMPOSITION_START_CHAR","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","code","highlight","italic","strikethrough","subscript","superscript","underline","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE","normalizeClassNames","classNames","rval","className","s","matchAll","push","TEXT_MUTATION_VARIANCE","isProcessingMutations","lastTextEntryTimeStamp","getIsProcessingMutations","updateTimeStamp","event","timeStamp","initTextEntryListener","editor","getWindow","addEventListener","isManagedLineBreak","dom","target","__lexicalLineBreak","_key","undefined","getLastSelection","getEditorState","read","selection","$getSelection","clone","$handleTextMutation","node","domSelection","getDOMSelection","_window","anchorOffset","focusOffset","anchorNode","text","nodeValue","$updateTextNodeFromDOMContent","shouldUpdateTextNodeFromMutation","targetDOM","targetNode","$isRangeSelection","anchor","getNode","is","format","getFormat","nodeType","isAttached","$flushMutations$1","mutations","observer","shouldFlushTextMutations","performance","now","updateEditor","badDOMTargets","Map","rootElement","getRootElement","currentEditorState","_editorState","blockCursorElement","_blockCursorElement","shouldRevertSelection","possibleTextForFirefoxPaste","i","length","mutation","$getNearestNodeFromDOMNode","$isDecoratorNode","$isTextNode","addedDOMs","addedNodes","addedDOM","$getNodeFromDOMNode","parentDOM","parentNode","nodeName","possibleText","innerText","removeChild","removedDOMs","removedNodes","removedDOMsLength","unremovedBRs","removedDOM","appendChild","internalGetRoot","set","size","$isElementNode","childKeys","getChildrenKeys","currentDOM","firstChild","key","correctDOM","getElementByKey","replaceChild","nextSibling","markDirty","records","takeRecords","record","dirty","$setSelection","isFirefoxClipboardEvents","insertRawText","$flushRootMutations","_observer","initMutationObserver","MutationObserver","$canSimpleTextNodesBeMerged","node1","node2","node1Mode","__mode","node1Format","__format","node1Style","__style","node2Mode","node2Format","node2Style","$mergeTextNodes","writableNode1","mergeWithSibling","normalizedNodes","getActiveEditor","_normalizedNodes","add","__key","$normalizeTextNode","textNode","__text","isSimpleText","isUnmergeable","remove","previousNode","getPreviousSibling","nextNode","getNextSibling","$normalizeSelection","$normalizePoint","focus","point","offset","nextOffsetAtEnd","getChildrenSize","getChildAtIndex","getTextContentSize","keyCounter","resetRandomKey","generateRandomKey","getRegisteredNodeOrThrow","registeredNode","_nodes","get","Error","scheduleMicroTask","queueMicrotask","fn","Promise","resolve","then","$isSelectionCapturedInDecorator","isSelectionCapturedInDecoratorInput","anchorDOM","activeElement","contentEditable","getEditorPropertyFromDOMNode","isSelectionWithinEditor","focusDOM","contains","getNearestEditorFromDOMNode","error","isLexicalEditor","LexicalEditor","currentNode","getParentElement","__lexicalEditor","getTextDirection","$isTokenOrSegmented","isToken","isSegmented","isDOMNodeLexicalTextNode","getDOMTextNode","element","toggleTextFormatType","alignWithFormat","activeFormat","newFormat","$isLeafNode","$isLineBreakNode","$setNodeKey","existingKey","errorOnNodeKeyConstructorMismatch","errorOnReadOnly","errorOnInfiniteTransforms","editorState","getActiveEditorState","_nodeMap","_dirtyElements","_dirtyLeaves","_cloneNotNeeded","_dirtyType","internalGetActiveEditorState","existingNode","constructor","name","internalMarkParentElementsAsDirty","parentKey","nodeMap","dirtyElements","nextParentKey","has","__parent","removeFromParent","oldParent","getParent","writableNode","getWritable","writableParent","prevSibling","writableNextSibling","__first","__prev","writablePrevSibling","__next","__last","__size","internalMarkNodeAsDirty","latest","getLatest","parent","internalMarkSiblingsAsDirty","$setCompositionKey","compositionKey","previousCompositionKey","_compositionKey","$getNodeByKey","$getCompositionKey","isCurrentlyReadOnlyMode","startingDOM","cloneDecorators","currentDecorators","_decorators","pendingDecorators","Object","assign","_pendingDecorators","getEditorStateTextContent","$getRoot","getTextContent","markAllNodesAsDirty","isEmpty","_pendingEditorState","tag","isFrozen","setCachedNodes","_selection","$flushMutations","$getNodeFromDOM","nodeKey","getNodeKeyFromDOM","getTextNodeOffset","moveSelectionToEnd","doesContainGrapheme","str","getEditorsToPropagate","editorsToPropagate","currentEditor","_parentEditor","createUID","Math","random","toString","replace","substr","getAnchorTextFromDOM","$updateSelectedTextFromDOM","isCompositionEnd","data","textContent","compositionEnd","isDirty","isComposing","normalizedTextContent","slice","prevTextContent","setTimeout","update","prevSelection","$getPreviousSelection","prevTextContentSize","getKey","canInsertTextBefore","canInsertTextAfter","setTextContent","setTextNodeRange","originalTextContent","replacement","$createTextNode","$previousSiblingDoesNotAcceptText","previousSibling","isInline","$shouldInsertTextAfterOrBeforeTextNode","isCollapsed","getParentOrThrow","isTab","altKey","ctrlKey","metaKey","isBold","toLowerCase","controlOrMeta","isItalic","isUnderline","isParagraph","shiftKey","isReturn","isLineBreak","isOpenLineBreak","isDeleteWordBackward","isBackspace","isDeleteWordForward","isDelete","isDeleteLineBackward","isDeleteLineForward","isDeleteBackward","isDeleteForward","isUndo","isRedo","isCopy","isCut","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","isMoveBackward","isMoveToStart","isMoveForward","isMoveToEnd","isMoveUp","isMoveDown","isModifier","isSpace","isEscape","isSelectAll","$selectAll","root","select","getCachedClassNameArray","classNamesTheme","classNameThemeType","__lexicalClassNameCache","classNamesCache","cachedClassNames","classNamesArr","setMutatedNode","mutatedNodes","registeredNodes","mutationListeners","__type","klass","mutatedNodesByType","prevMutation","isMove","$nodesOfType","klassType","getType","_readOnly","nodes","getCachedTypeToNodeMap","Array","from","values","nodesOfType","resolveElement","isBackward","block","getIndexWithinParent","$getAdjacentNode","focusNode","possibleNode","inputType","dispatchCommand","command","payload","triggerCommandListeners","$textContentRequiresDoubleLinebreakAtEnd","$isRootNode","isLastChild","getElementByKeyOrThrow","_keyToDOMMap","parentElement","assignedSlot","host","scrollIntoViewIfNeeded","selectionRect","doc","ownerDocument","defaultView","top","currentTop","bottom","currentBottom","targetTop","targetBottom","isBodyElement","body","innerHeight","targetRect","getBoundingClientRect","diff","scrollBy","scrollTop","yOffset","$hasUpdateTag","_updateTags","$addUpdateTag","$maybeMoveChildrenSelectionToParent","$hasAncestor","child","getDefaultView","domElem","ownerDoc","windowObj","$isInlineElementOrDecoratorNode","$getNearestRootOrShadowRoot","$isRootOrShadowRoot","isShadowRoot","$copyNode","copy","$applyNodeReplacement","replaceFunc","replacementNode","errorOnInsertTextNodeOnRoot","insertNode","$getNodeByKeyOrThrow","createBlockCursorElement","editorConfig","theme","setAttribute","blockCursorTheme","blockCursor","classList","needsBlockCursor","canBeEmpty","removeDOMBlockCursorElement","style","removeProperty","updateDOMBlockCursorElement","nextSelection","elementNode","elementNodeSize","isBlockCursor","insertBeforeElement","sibling","elementDOM","_config","caretColor","insertBefore","targetWindow","getSelection","$splitNode","startNode","recurse","isParentRoot","nodeToMove","insertAfter","leftTree","rightTree","newParent","nextSiblings","getNextSiblings","append","isHTMLAnchorElement","x","isHTMLElement","tagName","isInlineDomNode","inlineNodes","match","isBlockDomNode","blockNodes","INTERNAL_$isBlock","getFirstChild","isLeafElement","$getAncestor","predicate","$getEditor","cachedNodeMaps","WeakMap","EMPTY_TYPE_TO_NODE_MAP","typeToNodeMap","$cloneWithProperties","latestNode","mutableNode","afterCloneFrom","$garbageCollectDetachedDecorators","pendingEditorState","decorators","$garbageCollectDetachedDeepChildNodes","prevNodeMap","nodeMapDelete","dirtyNodes","childKey","delete","$garbageCollectDetachedNodes","prevEditorState","dirtyLeaves","subTreeTextContent","subTreeDirectionedTextContent","subTreeTextFormat","subTreeTextStyle","editorTextContent","activeEditorConfig","activeEditor$1","activeEditorNodes","treatAllNodesAsDirty","activeEditorStateReadOnly","activeMutationListeners","activeTextDirection","activeDirtyElements","activeDirtyLeaves","activePrevNodeMap","activeNextNodeMap","activePrevKeyToDOMMap","destroyNode","getPrevElementByKeyOrThrow","children","createChildrenArray","destroyChildren","_startIndex","endIndex","startIndex","setTextAlign","domStyle","value","setProperty","DEFAULT_INDENT_VALUE","setElementIndent","indent","indentClassName","elementHasClassName","indentationBaseValue","getComputedStyle","getPropertyValue","setElementFormat","$createNode","insertDOM","createDOM","storeDOMWithKey","__indent","childrenSize","$createChildrenWithDirection","reconcileElementTerminatingLineBreak","decorator","decorate","reconcileDecorator","isDirectionless","possibleLineBreak","freeze","previousSubTreeDirectionedTextContent","$createChildren","reconcileBlockDirection","previousSubTreeTextContent","getStyle","__lexicalTextContent","isLastChildLineBreakOrDecorator","prevElement","nextElement","prevLineBreak","nextLineBreak","msg","reconcileParagraphFormat","$isParagraphNode","__textFormat","setTextFormat","setTextStyle","reconcileParagraphStyle","__textStyle","previousSubTreeDirectionTextContent","__lexicalDirTextContent","previousDirection","__lexicalDir","hasEmptyDirectionedTextContent","direction","previousDirectionTheme","nextDirectionTheme","removeAttribute","dir","__dir","$reconcileChildrenWithDirection","$reconcileChildren","prevChildrenSize","nextChildrenSize","prevFirstChildKey","nextFrstChildKey","$reconcileNode","lastDOM","replacementDOM","nextChildNode","prevChildren","nextChildren","lexicalLineBreak","canUseFastPath","$reconcileNodeChildren","prevNode","updateDOM","nextIndent","nextFormat","__cachedText","nextRootNode","prevChildrenLength","nextChildrenLength","prevEndIndex","nextEndIndex","prevChildrenSet","nextChildrenSet","siblingDOM","prevIndex","nextIndex","prevKey","nextKey","Set","nextHasPrevKey","prevHasNextKey","childDOM","appendNewChildren","removeOldChildren","$reconcileRoot","nextEditorState","dirtyType","_listeners","currentMutatedNodes","keyToDOMMap","PASS_THROUGH_COMMAND","ANDROID_COMPOSITION_LATENCY","rootElementEvents","onKeyDown","onPointerDown","onCompositionStart","onCompositionEnd","onInput","onClick","onBeforeInput","lastKeyDownTimeStamp","lastKeyCode","lastBeforeInputInsertTextTimeStamp","unprocessedBeforeInputData","rootElementsRegistered","isSelectionChangeFromDOMUpdate","isSelectionChangeFromMouseDown","isInsertLineBreak","isFirefoxEndingComposition","collapsedSelectionFormat","$shouldPreventDefaultAndInsertText","domTargetRange","isBeforeInput","domAnchorNode","anchorKey","backingAnchorElement","textLength","collapsed","startContainer","startOffset","shouldSkipSelectionChange","domNode","onSelectionChange","isActive","windowEvent","currentTimeStamp","lastFormat","lastStyle","lastOffset","lastKey","isRootTextContentEmpty","lastNode","ParagraphNode","getTextFormat","getTextStyle","focusKey","getNodes","nodesLength","endOffset","startKey","endKey","combinedFormat","hasTextNodes","textContentSize","lastSelection","getTopLevelElementOrThrow","removeAllRanges","detail","pointerType","newSelection","$internalCreateRangeSelection","Node","getTargetRange","getTargetRanges","targetRanges","$canRemoveText","isPossiblyAndroidKeyPress","targetRange","isSelectionAnchorSameAsFocus","preventDefault","selectedNodeText","hasSelectedAllTextInNode","shouldLetBrowserHandleDelete","applyDOMRange","dataTransfer","getData","stopPropagation","$onCompositionEndImpl","characterData","$isNodeSelection","getRootElementRemoveHandles","eventHandles","__lexicalEventHandles","activeNestedEditorsMap","onDocumentSelectionChange","nextActiveEditor","editors","rootEditor","rootEditorKey","activeNestedEditor","prevActiveEditor","stopLexicalPropagation","_lexicalHandled","hasStoppedLexicalPropagation","stopped","addRootElementEvents","documentRootElementsCount","removeHandles","eventName","onEvent","eventHandler","isEditable","removeEventListener","removeRootElementEvents","newCount","cleanActiveNestedEditorsMap","markSelectionChangeFromDOMUpdate","markCollapsedSelectionFormat","$removeNode","nodeToRemove","restoreSelection","preserveEmptyParent","selectionMoved","moveSelectionPointToSibling","isSelected","selectPrevious","index","$updateElementSelectionOnCreateDeleteNode","selectEnd","LexicalNode","_data","errorOnTypeKlassMismatch","targetSelection","some","n","isElementRangeSelection","firstPoint","firstElement","getLastChildOrThrow","getTopLevelElement","getParents","parents","getParentKeys","self","getPreviousSiblings","siblings","getCommonAncestor","a","b","unshift","aLength","bLength","bSet","ancestor","object","isBefore","isParentOf","commonAncestor","indexA","indexB","getNodesBetween","visited","getLastChild","parentSibling","reverse","cloneNotNeeded","_editor","_prevNode","_dom","exportDOM","exportJSON","importJSON","_serializedNode","transform","replaceWith","includeChildren","toReplaceKey","writableReplaceWith","getChildren","forEach","$moveSelectionPointToEnd","nodeToInsert","writableSelf","writableNodeToInsert","elementAnchorSelectionOnNode","elementFocusSelectionOnNode","oldIndex","oldParentKey","insertKey","writableParentKey","isParentRequired","createParentElementNode","$createParagraphNode","selectStart","selectNext","editorKlass","insertRangeAfter","firstToInsert","lastToInsert","lastToInsert2","current","nodesToInsert","LineBreakNode","importDOM","br","isOnlyChildInBlockNode","isLastChildInBlockNode","conversion","$convertLineBreakElement","priority","serializedLineBreakNode","$createLineBreakNode","version","isWhitespaceDomTextNode","lastChild","getElementOuterTag","getElementInnerTag","setTextThemeClassNames","prevFormat","textClassNames","domClassList","hasUnderlineStrikethrough","prevUnderlineStrikethrough","nextUnderlineStrikethrough","flag","diffComposedText","nextText","suffix","insert","deleteData","insertData","createTextInnerDOM","innerDOM","innerTag","config","wrapElementWith","el","TextNode","__detail","getDetail","getMode","hasFormat","formatFlag","getFormatFlags","canHaveFormat","outerTag","cssText","prevOuterTag","nextOuterTag","prevInnerTag","nextInnerTag","prevTag","nextTag","prevInnerDOM","nextInnerDOM","prevStyle","nextStyle","$convertTextDOMNode","convertBringAttentionToElement","convertTextFormatElement","em","span","convertSpanElement","strong","sub","sup","u","serializedNode","setFormat","setDetail","setMode","mode","setStyle","whiteSpace","selectionTransform","toggleFormat","toggleDirectionless","toggleUnmergeable","_anchorOffset","_focusOffset","$internalMakeRangeSelection","spliceText","delCount","newText","moveSelection","handledTextLength","newOffset","updatedText","splitText","splitOffsets","offsetsSet","parts","string","partsLength","firstPart","hasReplacedSelf","splitNodes","textSize","part","partSize","siblingKey","nextTextSize","insertionIndex","splice","targetKey","adjustPointOffsetForMergedSibling","targetText","isTextEntity","forChild","applyTextFormatFromStyle","hasNormalFontWeight","fontWeight","preParentCache","isNodePre","startsWith","findParentPreDOMNode","cached","resultNode","domNode_","parentDom","split","$createTabNode","previousText","isStartOfLine","findTextInLine","previousTextContent","isEndOfLine","nextTextContent","forward","display","descendant","nodeNameToTextFormat","shouldApply","textDecoration","hasBoldFontWeight","hasLinethroughTextDecoration","includes","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","verticalAlign","lexicalNode","TabNode","serializedTabNode","_text","_detail","_type","$isTabNode","Point","aNode","bNode","aOffset","bOffset","aNodeDescendant","getDescendantByIndex","bNodeDescendant","oldKey","$createPoint","selectPointOnNode","textContentLength","getLastDescendant","$transferStartingElementPointToTextPoint","placementNode","$setPointValues","NodeSelection","objects","_cachedNodes","getCachedNodes","every","getStartEndPoints","clear","extract","insertText","insertNodes","selectedNodes","selectedNodesLength","lastSelectedNode","selectionAtEnd","cachedNodes","RangeSelection","lastPoint","firstNode","firstNodeDescendant","lastNodeDescendant","$getCharacterOffsets","prevWasElement","range","resolvedSelectionPoints","$internalResolveSelectionPoints","endContainer","anchorPoint","focusPoint","endPoint","firstNodeText","firstNodeTextLength","firstNodeParent","lastIndex","lastNodeParent","$normalizeSelectionPointsForBoundaries","firstNodeFormat","firstNodeStyle","markedNodeKeysForKeep","lastElement","lastElementChild","lastNodeChildren","selectedNodesSet","firstAndLastElementsAreEqual","insertionTarget","lastNodeChild","lastRemovedParent","childrenLength","selectedNode","removeText","formatText","formatType","selectedTextNodes","selectedTextNodesLength","startPoint","firstIndex","firstNextFormat","lastNextFormat","insertParagraph","firstBlock","last","$removeTextAndSplitBlock","notInline","blocksParent","$wrapInlineNodes","nodeToSelect","blocks","isMergeable","canMergeWhenEmpty","shouldInsert","insertedParagraph","lastInsertedBlock","paragraph","firstToAppend","newBlock","insertNewAfter","insertLineBreak","lineBreak","shift","lastNodeText","lastNodeTextLength","pop","modify","alter","granularity","collapse","isIsolated","isKeyboardSelectable","nodeSelection","$createNodeSelection","elementKey","_rootElement","moveNativeSelection","rangeCount","getRangeAt","validNodes","shrinkSelection","firstValidNode","lastValidNode","$swapPoints","forwardDeletion","deleteCharacter","wasCollapsed","$removeSegment","$updateCaretSelectionForUnicodeCharacter","collapseAtStart","deleteLine","anchorIsElement","deleteWord","getCharacterOffset","anchorAndFocus","anchorType","characterOffset","splitLength","segmentOffset","restoreOffset","isLast","join","trim","shouldResolveAncestor","resolvedElement","resolvedOffset","$internalResolveSelectionPoint","resolvedNode","childNodes","childNodesLength","hasBlockCursor","blockCursorElementParent","blockCursorOffset","prototype","indexOf","call","min","getFirstDescendant","resolveSelectionPointOnBoundary","lastAnchor","lastFocus","resolvedAnchorPoint","resolvedFocusPoint","$isBlockElementNode","focusType","$createRangeSelection","$internalCreateSelection","$createRangeSelectionFromDom","eventType","isSelectionChange","useDOMSelection","nodeOffset","times","selectionOffset","newSelectionOffset","max","$updateSelectionResolveTextNodes","firstPointNode","lastPointNode","firstPointOffset","lastPointOffset","childSize","anchorOffsetAtEnd","focusOffsetAtEnd","applySelectionTransforms","updateDOMSelection","tags","nodeCount","anchorDOMNode","focusDOMNode","nextAnchorOffset","nextFocusOffset","nextAnchorNode","nextFocusNode","anchorFormatOrStyleChanged","preventScroll","setBaseAndExtent","console","warn","selectionTarget","Text","createRange","selectNode","$insertNodes","$getTextContent","selection_","$splitNodeAtPoint","insertPoint","newElement","virtualRoot","currentBlock","isLineBreakNode","activeEditorState","activeEditor","isReadOnlyMode","isAttemptingToRecoverFromReconcilerError","infiniteTransformCount","observerOptions","childList","subtree","collectBuildInformation","compatibleEditors","incompatibleEditors","thisVersion","querySelectorAll","String","output","internalGetActiveEditor","$applyTransforms","transformsCache","transformsArr","transforms","transformsArrLength","$isNodeValidForTransform","$normalizeAllDirtyTextNodes","$applyAllTransforms","untransformedDirtyLeaves","untransformedDirtyLeavesLength","untransformedDirtyElements","untransformedDirtyElementsLength","currentUntransformedDirtyElement","intentionallyMarkedAsDirty","$parseSerializedNode","internalSerializedNode","$parseSerializedNodeImpl","nodeClass","isArray","serializedJSONChildNode","childNode","parseEditorState","serializedEditorState","updateFn","createEmptyEditorState","previousActiveEditorState","previousReadOnlyMode","previousActiveEditor","previousDirtyElements","previousDirtyLeaves","previousCloneNotNeeded","previousDirtyType","handleDEVOnlyPendingUpdateGuarantees","_onError","readEditorState","callbackFn","$commitPendingUpdates","recoveryEditorState","shouldSkipDOM","_headless","currentSelection","pendingSelection","needsUpdate","previouslyUpdating","_updating","disconnect","resetEditor","observe","deferred","_deferred","_editable","triggerMutationListeners","triggerListeners","triggerTextContentListeners","triggerDeferredUpdateCallbacks","$triggerEnqueuedUpdates","currentTextContent","latestTextContent","updateTags","listeners","listenersLength","listener","isCurrentlyEnqueuingUpdates","apply","returnVal","e","commandListeners","_commands","listenerInPriorityOrder","listenersSet","j","queuedUpdates","_updates","queuedUpdate","options","$beginUpdate","processNestedUpdates","initialSkipTransforms","skipTransforms","nextUpdateFn","onUpdate","discrete","_flushSync","editorStateWasCloned","cloneEditorState","startingCompositionKey","endingCompositionKey","pendingNodeMap","shouldUpdate","editorStateHasDirtySelection","ElementNode","getFormatType","getIndent","parentLastChild","getAllTextNodes","textNodes","subChildrenNodes","firstKey","getFirstChildOrThrow","getDirection","childrenCount","nodesToAppend","setDirection","setIndent","indentLevel","deleteCount","nodesToInsertLength","oldSize","writableSelfKey","nodesToInsertKeys","nodesToRemoveKeys","nodeAfterRange","nodeBeforeRange","newSize","nodeToDelete","nodeKeyToDelete","writableNodeToDelete","nodeKeyToInsert","writablePrevNode","writableNodeAfterRange","nodesToRemoveKeySet","nodesToInsertKeySet","isPointRemoved","canIndent","excludeFromCopy","destination","canReplaceWith","canInsertAfter","canMergeWith","extractWithChild","DecoratorNode","RootNode","cachedText","$createRootNode","EditorState","exportNodeToJSON","serializedChildren","serializedChildNode","toJSON","ArtificialNode__DO_NOT_USE","hasTextFormat","p","$convertParagraphElement","textAlign","textIndent","textFormat","textStyle","rangeSelection","parseInt","DEFAULT_SKIP_INITIALIZATION","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","COMMAND_PRIORITY_NORMAL","COMMAND_PRIORITY_HIGH","COMMAND_PRIORITY_CRITICAL","prevRootElement","nextRootElement","keyNodeMap","initializeConversionCache","additionalConversions","conversionCache","handledConversions","addConversionsToCache","map","keys","currentCache","createEditor","parentEditor","disableEvents","namespace","initialEditorState","onError","html","editable","replaceWithKlass","with","withKlass","hasOwnProperty","proto","method","export","import","htmlConversions","textcontent","_htmlConversions","registerUpdateListener","listenerSetOrMap","registerEditableListener","registerDecoratorListener","registerTextContentListener","registerRootListener","registerCommand","commandsMap","listenersInPriorityOrder","registerMutationListener","klassToMutate","resolveRegisteredNodeAfterReplacements","getRegisteredNode","skipInitialization","initializeMutationListener","nodeMutationMap","k","registerNodeTransformToKlass","registerNodeTransform","registeredReplaceWithNode","hasNode","hasNodes","bind","getDecorators","setRootElement","userSelect","wordBreak","setEditorState","maybeStringifiedEditorState","JSON","parse","defaultSelection","blur","setEditable","H","q","Q","X","Y","Z","G","tt","et","nt","Bt","t","__esModule","default","Rt","URLSearchParams","arguments","hr","mod","modDev","$normalizeSelection__EXPERIMENTAL","CSS_TO_STYLES","TEXT_NODE","getDOMIndexWithinParent","createDOMRange","setStart","setEnd","createRectsFromDOMRange","rootRect","computedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","sort","abs","prevRect","isOverlappingRect","height","width","selectionSpansElement","getStyleObjectFromRawCSS","css","styleObject","styles","getStyleObjectFromCSS","getCSSFromStyleObject","$sliceSelectedTextNodeContent","isAnchor","isFocus","isSame","isFirst","$isAtNodeEnd","$trimTextContentFromAnchor","remaining","descendantNode","lastDescendant","additionalElementWhitespace","currentNodeSize","slicedText","prevOffset","splitStart","splitEnd","excessNode","$addNodeStyle","CSSText","$patchStyle","patch","prevStyles","newStyles","entries","reduce","newCSSText","$patchStyleText","startType","endType","selectedNodeKey","$setBlocksType","firstSelectedBlock","targetElement","isPointAttached","$removeParentEmptyElements","startingNode","$wrapNodes","wrappingElement","topLevelNode","descendants","$wrapNodesImpl","elementMapping","elements","targetIsPrevSibling","emptyElements","movedNodes","$shouldOverrideDefaultCharacterSelection","$moveCaretSelection","isHoldingShift","$isParentElementRTL","$moveCharacter","isRTL","topParent","firstType","lastType","$getNodeStyleValueForProperty","styleProperty","defaultValue","$getSelectionStyleValueForProperty","styleValue","endNode","nodeStyleValue","trimTextContentFromAnchor","m","T","CAN_USE_DOM$1","IS_APPLE$1","IS_FIREFOX$1","CAN_USE_BEFORE_INPUT$1","IS_SAFARI$1","IS_IOS$1","IS_ANDROID$1","IS_CHROME$1","IS_ANDROID_CHROME$1","IS_APPLE_WEBKIT$1","mergeRegister","func","px","mutationObserverConfig","attributes","positionNodeOnRange","onReposition","rootDOMNode","parentDOMNode","lastNodes","wrapperNode","position","rootLeft","rootTop","parentDOMNode_","rects","isConnected","hasRepositioned","rect","rectNode","rectNodeStyle","stop","restart","currentRootDOMNode","currentParentDOMNode","HTMLElement","nextRootDOMNode","nextParentDOMNode","removeRootListener","markSelection","previousAnchorNode","previousAnchorOffset","previousFocusNode","previousFocusOffset","removeRangeListener","compute","currentAnchorNode","currentAnchorNodeKey","currentAnchorOffset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","currentFocusNodeDOM","differentAnchorDOM","differentFocusDOM","anchorHTMLElement","focusHTMLElement","firstHTMLElement","firstOffset","lastHTMLElement","firstTextNode","lastTextNode","domNodes","domNodeStyle","background","color","zIndex","pointerEvents","marginTop","paddingTop","paddingBottom","addClassNamesToElement","classesToAdd","removeClassNamesFromElement","classesToRemove","isMimeType","file","acceptableMimeTypes","acceptableType","mediaFileReader","files","filesIterator","Symbol","iterator","reject","processed","handleNextFile","done","next","fileReader","FileReader","result","readAsDataURL","$dfs","endingNode","depth","$getDepth","innerNode","$getNextRightPreorderNode","$getNearestNodeOfType","$getNearestBlockElementAncestorOrThrow","blockNode","$findMatchingParent","findFn","curr","registerNestedElementResolver","cloneNode","handleOverlap","$isTargetNode","$findMatch","$elementNodeTransform","nextSiblingsLength","$restoreEditorState","$insertNodeToNearestRoot","focusChild","splitNode","splitOffset","paragraphNode","$wrapNodeInElement","createElementNode","objectKlassEquals","objectClass","getPrototypeOf","$filter","filterFn","$insertFirst","calculateZoomLevel","zoom","Number","$isEditorIsNestedEditor","g","h","v","y","w","E","P","S","N","A","$generateNodesFromDOM","lexicalNodes","allArtificialNodes","IGNORE_TAGS","$createNodesFromDOM","concat","$unwrapArtificalNodes","$generateHtmlFromNodes","global","container","topLevelChildren","$appendNodesToHTML","innerHTML","shouldInclude","shouldExclude","exportOutput","after","fragment","createDocumentFragment","shouldIncludeChild","getConversionFunction","cachedConversions","currentConversion","cachedConversion","domConversion","hasBlockAncestorLexicalNode","forChildMap","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","forChildFunction","childLexicalNodes","hasBlockAncestorLexicalNodeForChildren","wrapContinuousInlines","artificialNode","isDomNodeBetweenTwoInlineNodes","createWrapperFn","out","continuousInlines","wrapper","$getListDepth","listNode","$isListItemNode","parentList","$isListNode","$getTopListNode","listItem","list","$getAllListItems","listItemNodes","listChildren","filter","listItemNode","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","$wrapInListItem","listItemWrapper","$createListItemNode","$isSelectingEmptyListItem","insertList","listType","anchorNodeParent","$createListNode","handled","$createListOrMerge","newListNode","nextParent","getListType","mergeLists","list1","list2","listItem1","listItem2","toMerge","removeList","listNodes","ListItemNode","insertionPoint","listItems","updateChildrenListItemValue","isNotChecklist","getStart","getValue","setValue","__checked","setChecked","mergeNextSiblingListIfSameType","$handleIndent","removed","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","previousSiblingsListItem","previousSiblingsList","nextSiblingsListItem","nextSiblingsList","$handleListInsertParagraph","topListNode","grandparent","__value","checked","updateListItemChecked","$setListItemThemeClassNames","getChecked","li","$convertListItemElement","replaceWithNode","nodeToAppend","_","listNodeParent","isIndented","Boolean","toggleChecked","floor","currentIndent","editorThemeClasses","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","prevListItemNode","isGitHubCheckList","$convertCheckboxInput","ariaCheckedAttr","getAttribute","isCheckboxInput","hasAttribute","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","_listType","getTag","setListType","writable","__lexicalListType","$setListThemeClassNames","ol","$convertListNode","ul","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","checklistClassName","checklist","$normalizeChildren","normalizedListItems","isDomChecklist","INSERT_UNORDERED_LIST_COMMAND","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","SUPPORTED_URL_PROTOCOLS","LinkNode","__url","rel","__rel","__target","title","__title","url","href","sanitizeUrl","link","HTMLAnchorElement","$convertAnchorElement","$createLinkNode","parsedUrl","URL","protocol","_unused","getRel","getTarget","getTitle","getURL","setURL","setTarget","setRel","setTitle","linkNode","isEmailURI","isWebSiteURI","content","$isLinkNode","AutoLinkNode","__isUnlinked","isUnlinked","getIsUnlinked","setIsUnlinked","$createAutoLinkNode","$isAutoLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","prevParent","toggleLink","r","$getHtmlContent","$getLexicalContent","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","$insertDataTransferForRichText","lexicalString","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","parseFromString","_unused2","$appendNodesToJSON","targetArray","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","$copyToClipboardEvent","windowDocument","createTextNode","Range","addRange","removeListener","secondEvent","ClipboardEvent","clearTimeout","execCommand","$getClipboardDataFromSelection","clipboardData","setLexicalClipboardDataTransfer","clipboardDataFunctions","mimeType","$editorFn","setData","HISTORY_MERGE","HISTORY_PUSH","DISCARD_HISTORY_CANDIDATE","OTHER","COMPOSING_CHARACTER","INSERT_CHARACTER_AFTER_SELECTION","DELETE_CHARACTER_BEFORE_SELECTION","DELETE_CHARACTER_AFTER_SELECTION","getDirtyNodes","dirtyLeafKey","dirtyLeaf","dirtyElementKey","dirtyElement","getChangeType","dirtyLeavesSet","dirtyElementsSet","nextNodeMap","prevAnchorNode","nextDirtyNode","prevDirtyNode","prevText","nextAnchor","prevAnchor","prevAnchorOffset","textDiff","isTextNodeUnchanged","isDeletingLine","createMergeActionGetter","delay","prevChangeTime","Date","prevChangeType","currentHistoryEntry","changeTime","changeType","mergeAction","isSameEditor","shouldPushHistory","shouldMergeHistory","hasDirtyNodes","redo","historyState","redoStack","undoStack","historyStateEntry","undo","undoStackLength","clearHistory","registerHistory","getMergeAction","applyChange","unregister","createEmptyHistoryState","$rootTextContent","$isRootTextContentEmpty","isEditorComposing","$isRootTextContentEmptyCurry","$canShowPlaceholder","topBlock","topBlockChildren","topBlockChildrenLength","$canShowPlaceholderCurry","$findTextIntersectionFromCharacters","targetCharacters","currentCharacters","mainLoop","characters","registerLexicalTextEntity","getMatch","createNode","isTargetNode","$replaceWithSimpleText","$textNodeTransform","combinedText","prevMatch","concatText","newTextContent","remainingText","prevMatchLengthToSkip","nextMatch","nodeToReplace","$reverseNodeTransform","removePlainTextTransform","removeReverseNodeTransform","d","caretFromPoint","caretRangeFromPoint","caretPositionFromPoint","offsetNode","DRAG_DROP_PASTE","QuoteNode","quote","blockquote","$convertBlockquoteElement","$createQuoteNode","$isQuoteNode","HeadingNode","heading","h1","$convertHeadingElement","h2","h3","h4","h5","h6","isGoogleDocsTitle","$createHeadingNode","anchorOffet","lastDesc","isAtEnd","fontSize","headingTag","$isHeadingNode","onPasteForRichText","KeyboardEvent","onCutForRichText","eventFiles","DragEvent","types","hasFiles","hasContent","$handleIndentAndOutdent","indentOrOutdent","alreadyHandled","parentBlock","$isTargetWithinDecorator","$isSelectionAtEndOfRoot","registerRichText","eventOrText","clientX","clientY","eventRange","domOffset","normalizedSelection","isFileTransfer","hasTextContent","ct","at","ut","lt","dt","mt","ft","gt","l","PIXEL_VALUE_REG_EXP","COLUMN_WIDTH","TableCellHeaderStates","BOTH","COLUMN","NO_STATUS","ROW","TableCellNode","cellNode","__headerState","__colSpan","__width","__rowSpan","__backgroundColor","td","$convertTableCellNodeElement","th","colSpan","rowSpan","$createTableCellNode","headerState","backgroundColor","tableCell","hasHeader","tableCellHeader","element_","border","getWidth","getBackgroundColor","getColSpan","setColSpan","getRowSpan","setRowSpan","setHeaderStyles","getHeaderStyles","setWidth","setBackgroundColor","newBackgroundColor","toggleHeaderStyle","headerStateToToggle","hasHeaderState","tableCellNode","$isTableCellNode","INSERT_TABLE_COMMAND","TableRowNode","__height","tr","$convertTableRowElement","$createTableRowNode","getHeight","tableRow","setHeight","$isTableRowNode","$createTableNodeWithDimensions","rowCount","columnCount","includeHeaders","tableNode","$createTableNode","iRow","tableRowNode","iColumn","rows","columns","$getTableCellNodeFromLexicalNode","$getTableRowNodeFromTableCellNodeOrThrow","$getTableNodeFromLexicalNodeOrThrow","$isTableNode","$getTableRowIndexFromTableCellNode","findIndex","$getTableColumnIndexFromTableCellNode","$getTableCellSiblingsFromTableCellNode","table","getCordsFromCellNode","above","getCellNodeFromCords","below","$removeTableRowAtIndex","indexToDelete","tableRows","targetRowNode","$insertTableRow","targetIndex","shouldInsertAfter","tableRowCells","tableColumnCount","newTableRowNode","c","tableCellFromTargetRow","getHeaderState","currentState","possibleState","$insertTableRow__EXPERIMENTAL","$isTableSelection","focusCell","grid","$getNodeTriplet","gridMap","focusCellMap","$computeTableMap","startRow","focusStartRow","focusEndRow","focusEndRowMap","newRow","cell","currentCell","currentCellHeaderState","focusEndRowNode","focusStartRowMap","focusStartRowNode","$insertTableColumn","tableCellsToBeInserted","currentTableRowNode","tableRowChildren","targetCell","newTableCell","$insertTableColumn__EXPERIMENTAL","anchorCell","anchorCellMap","startColumn","insertAfterColumn","gridFirstChild","firstInsertedCell","$createTableCellNodeForInsertTableColumn","loopRow","rowLoop","currentRow","rowMap","currentStartColumn","currentStartRow","insertAfterCell","insertAfterCellRowStart","prevCellIndex","cell_","startRow_","$moveSelectionToCell","$deleteTableColumn","$deleteTableRow__EXPERIMENTAL","anchorStartRow","nextRow","nextRowNode","row","column","cellStartRow","cellStartColumn","previousCell","rowNode","previousRow","$deleteTableColumn__EXPERIMENTAL","anchorStartColumn","focusStartColumn","endColumn","selectedColumnCount","overflowLeft","inSelectedArea","focusRowMap","nextColumn","firstDescendant","$unmergeCell","cellMap","currentRowNode","currentRowMap","currentCellMap","cellA","cellB","tableMap","cellAValue","cellBValue","$computeTableMapSkipCellCheck","write","gridChildren","rowChildren","source","$getTableCellNodeRect","gridNode","cellMatrix","rowIndex","cells","columnIndex","cellIndex","TableSelection","tableKey","anchorCellKey","focusCellKey","getShape","anchorCellNode","anchorCellNodeRect","focusCellNode","focusCellNodeRect","startX","stopX","startY","stopY","fromX","fromY","toX","toY","anchorRow","focusCellGrid","gridParent","focusCellParent","cellAMap","cellBMap","minColumn","minRow","maxColumn","maxRow","exploredMinColumn","exploredMinRow","exploredMaxColumn","exploredMaxRow","expandBoundary","mapValue","rowDiff","previousColumn","columnDiff","lastRow","$getChildrenRecursively","$createTableSelection","stack","TableObserver","tableNodeKey","isHighlightingCells","anchorX","anchorY","focusX","focusY","listenersToRemove","domRows","tableSelection","anchorCellNodeKey","focusCellNodeKey","hasHijackedSelectionStyles","trackTable","isSelecting","getTable","removeListeners","gridNeedsRedraw","tableElement","clearHighlight","enableHighlightStyle","$updateDOMForSelection","disableHighlightStyle","updateTableTableSelection","setFocusCellForSelection","ignoreStart","cellX","cellY","elem","focusTableCellNode","$findTableNode","focusNodeKey","setAnchorCellForSelection","anchorTableCellNode","anchorNodeKey","formatCells","formatSelection","clearText","rootNode","LEXICAL_ELEMENT_KEY","isMouseDownOnEvent","buttons","applyTableHandlers","hasTabHandler","tableObserver","editorWindow","attachTableObserverToTableElement","createMouseHandlers","onMouseUp","onMouseMove","moveEvent","getDOMCellFromTarget","button","stopEvent","mouseDownCallback","$handleArrowKey","deleteTextHandler","$isSelectionInTable","isAnchorInside","isFocusInside","selectionContainsPartialTable","nearestElementNode","topLevelCellElementNode","$deleteCellHandler","find","intercepted","cellChildren","edgePosition","$getTableEdgeCursorPosition","$insertParagraphAtTableEdge","$findCellNode","currentCords","selectTableNodeInDirection","getObserverCellFromCellNode","getDOMCellFromCordsOrThrow","selectionPayload","isTableSelection","isRangeSelection","isSelectionInsideOfGrid","newGrid","newGridRows","newColumnCount","newRowCount","gridCellNode","gridRowNode","gridRowNodes","newRowIdx","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","currentGridCellNode","newGridCellNode","originalChildren","isPartialyWithinTable","isWithinTable","firstCell","lastCell","$addHighlightStyleToTable","isFocusOutside","$removeHighlightStyleToTable","getTableObserverFromTableElement","_cell","nodeMame","hasBackgroundColor","highlighted","selectedCellNodes","$forEachTableCell","$addHighlightToDOM","$removeHighlightFromDOM","cb","isForward","selectTableCellNode","getCellNodeFromCordsOrThrow","adjustFocusNodeInDirection","fromStart","BROWSER_BLUE_RGB","isTypeaheadMenuInView","siblingNode","firstCellNode","lastCellNode","firstCellCoords","lastCellCoords","firstCellDOM","lastCellDOM","focusParentNode","anchorCellTable","anchorCellTableElement","isExitingTableAnchor","$handleTableExit","anchorCellDom","edgeSelectionRect","edgeChild","edgeChildDOM","edgeRect","isExiting","cords","tableNodeFromSelection","cordsAnchor","stopImmediatePropagation","isExitingTableElementAnchor","$isExitingTableTextAnchor","hasValidOffset","cellValue","isExitingCell","toNode","$getExitingToNode","anchorSibling","tableNodeParent","tableNodeParentDOM","parentTable","isAtFirstCell","isAtLastCell","TableNode","_node","$convertTableElement","colGroup","tBody","firstRow","colCount","col","replaceChildren","getDOMCellFromCords","canSelectBefore","$getElementForTableNode","_domNode","ne","ie","ce","ae"],"mappings":"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"}